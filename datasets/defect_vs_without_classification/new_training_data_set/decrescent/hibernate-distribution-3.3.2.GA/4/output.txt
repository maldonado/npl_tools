test out the optimizer:	WITHOUT_CLASSIFICATION	0.9999649109684737	WITHOUT_CLASSIFICATION	3.508903152631105E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
| this | bean | args | raw bean |	WITHOUT_CLASSIFICATION	0.9994149524470205	WITHOUT_CLASSIFICATION	5.850475529793831E-4	DEFECT
invokeinterface	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
astore 4 store the raw bean	WITHOUT_CLASSIFICATION	0.9999181122065881	WITHOUT_CLASSIFICATION	8.188779341180527E-5	DEFECT
current stack len = 0	WITHOUT_CLASSIFICATION	0.9999341499020659	WITHOUT_CLASSIFICATION	6.58500979341334E-5	DEFECT
current stack len = 0	WITHOUT_CLASSIFICATION	0.9999341499020659	WITHOUT_CLASSIFICATION	6.58500979341334E-5	DEFECT
local variables | target obj | each oldvalue |	WITHOUT_CLASSIFICATION	0.9999893529819501	WITHOUT_CLASSIFICATION	1.0647018049897665E-5	DEFECT
invokeinterface invoke Enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9998154103637006	WITHOUT_CLASSIFICATION	1.8458963629942553E-4	DEFECT
putfield new value of the field	WITHOUT_CLASSIFICATION	0.9999446607081041	WITHOUT_CLASSIFICATION	5.533929189604047E-5	DEFECT
reference type	WITHOUT_CLASSIFICATION	0.9999182243961765	WITHOUT_CLASSIFICATION	8.177560382345038E-5	DEFECT
double	WITHOUT_CLASSIFICATION	0.9999889331532725	WITHOUT_CLASSIFICATION	1.1066846727550567E-5	DEFECT
double	WITHOUT_CLASSIFICATION	0.9999889331532725	WITHOUT_CLASSIFICATION	1.1066846727550567E-5	DEFECT
long	WITHOUT_CLASSIFICATION	0.9999874558113997	WITHOUT_CLASSIFICATION	1.2544188600190343E-5	DEFECT
just decrement the lock, don't recache (we don't know which transaction won)	WITHOUT_CLASSIFICATION	0.999790564813684	WITHOUT_CLASSIFICATION	2.094351863159981E-4	DEFECT
decode row selection...	WITHOUT_CLASSIFICATION	0.9999235833864937	WITHOUT_CLASSIFICATION	7.641661350624668E-5	DEFECT
disassembled state gets put in a new array (we write to cache by value!)	WITHOUT_CLASSIFICATION	0.9999332187869439	WITHOUT_CLASSIFICATION	6.678121305613415E-5	DEFECT
again, CCS did not have such a concept; but a reasonable proximity is to clear the cache after transaction as long as the underlying cache is not JTA aware.	WITHOUT_CLASSIFICATION	0.9999097074420278	WITHOUT_CLASSIFICATION	9.029255797230479E-5	DEFECT
CHECK	WITHOUT_CLASSIFICATION	0.9999770609890836	WITHOUT_CLASSIFICATION	2.293901091652638E-5	DEFECT
ROW ID	WITHOUT_CLASSIFICATION	0.9999773800611349	WITHOUT_CLASSIFICATION	2.2619938865065564E-5	DEFECT
COMPOSITE-ID	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Property prop = new Property(); prop.setName("id"); prop.setPropertyAccessorName("embedded"); prop.setValue(id); entity.setIdentifierProperty(prop);	WITHOUT_CLASSIFICATION	0.9999093387293027	WITHOUT_CLASSIFICATION	9.066127069723248E-5	DEFECT
DYNAMIC INSERT	WITHOUT_CLASSIFICATION	0.9998378686974615	WITHOUT_CLASSIFICATION	1.6213130253845472E-4	DEFECT
PERSISTER	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
get meta's from <subclass>	WITHOUT_CLASSIFICATION	0.9999429598056846	WITHOUT_CLASSIFICATION	5.704019431545946E-5	DEFECT
PROPERTIES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
PROPERTIES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
generated properties can never be insertable...	WITHOUT_CLASSIFICATION	0.9992209323435508	WITHOUT_CLASSIFICATION	7.790676564491381E-4	DEFECT
TABLE	WITHOUT_CLASSIFICATION	0.9999819150325552	WITHOUT_CLASSIFICATION	1.8084967444784438E-5	DEFECT
by default, natural-ids are "immutable" (constant)	WITHOUT_CLASSIFICATION	0.9999246061209976	WITHOUT_CLASSIFICATION	7.539387900234707E-5	DEFECT
( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() ).setNullable(false);	WITHOUT_CLASSIFICATION	0.9999143921871652	WITHOUT_CLASSIFICATION	8.560781283482628E-5	DEFECT
we found some extends attributes referencing entities which were not already processed. here we need to locate all entity-names and class-names contained in this document itself, making sure that these get removed from the extendz list such that only extends names which require us to delay processing (i.e. external to this document and not yet processed) are contained in the returned result	WITHOUT_CLASSIFICATION	0.9833077591201776	WITHOUT_CLASSIFICATION	0.016692240879822393	DEFECT
Build a ResultSetMappingDefinition given a containing element for the "return-XXX" elements @param resultSetElem The element containing the return definitions. @param path No clue... @param mappings The current processing state. @return The description of the mappings...	WITHOUT_CLASSIFICATION	0.9999990509068841	WITHOUT_CLASSIFICATION	9.490931159929305E-7	DEFECT
private boolean showSql; private boolean formatSql;	WITHOUT_CLASSIFICATION	0.9997752536900643	WITHOUT_CLASSIFICATION	2.2474630993583533E-4	DEFECT
public boolean isShowSqlEnabled() { return showSql; } public boolean isFormatSqlEnabled() { return formatSql; }	WITHOUT_CLASSIFICATION	0.9999907314049592	WITHOUT_CLASSIFICATION	9.268595040880274E-6	DEFECT
Set a custom entity resolver. This entity resolver must be set before addXXX(misc) call. Default value is {@link org.hibernate.util.DTDEntityResolver} @param entityResolver entity resolver to use	WITHOUT_CLASSIFICATION	0.9992867517649784	WITHOUT_CLASSIFICATION	7.132482350214814E-4	DEFECT
final List extendsQueue,	WITHOUT_CLASSIFICATION	0.9999342760844022	WITHOUT_CLASSIFICATION	6.572391559782695E-5	DEFECT
If close() is called, guarantee unbind()	WITHOUT_CLASSIFICATION	0.9994379137476381	WITHOUT_CLASSIFICATION	5.620862523619019E-4	DEFECT
if a ThreadLocalSessionContext-bound session happens to get serialized, to be completely correct, we need to make sure that unbinding of that session occurs.	WITHOUT_CLASSIFICATION	0.9999262475123348	WITHOUT_CLASSIFICATION	7.375248766524722E-5	DEFECT
on the inverse, it makes sense that if a ThreadLocalSessionContext- bound session then gets deserialized to go ahead and re-bind it to the ThreadLocalSessionContext session map.	WITHOUT_CLASSIFICATION	0.9999058678546275	WITHOUT_CLASSIFICATION	9.413214537247382E-5	DEFECT
cannot be instantiated	WITHOUT_CLASSIFICATION	0.9998873000165274	WITHOUT_CLASSIFICATION	1.1269998347265642E-4	DEFECT
60 second lock timeout	WITHOUT_CLASSIFICATION	0.9999208916606268	WITHOUT_CLASSIFICATION	7.910833937315987E-5	DEFECT
OptimisticCache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
Cache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997202743258552	WITHOUT_CLASSIFICATION	2.797256741447782E-4	DEFECT
option.setDataVersion( NonLockingDataVersion.INSTANCE );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
do the put outside the scope of the JTA txn	WITHOUT_CLASSIFICATION	0.9999287025643713	WITHOUT_CLASSIFICATION	7.129743562865201E-5	DEFECT
ignore!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
tree cache in optimistic mode seems to have as very difficult time with remove calls on non-existent nodes (NPEs)...	WITHOUT_CLASSIFICATION	0.8514321052200837	WITHOUT_CLASSIFICATION	0.14856789477991622	DEFECT
60 seconds	WITHOUT_CLASSIFICATION	0.9999771915159669	WITHOUT_CLASSIFICATION	2.2808484033148915E-5	DEFECT
ignore!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
60 seconds	WITHOUT_CLASSIFICATION	0.9999771915159669	WITHOUT_CLASSIFICATION	2.2808484033148915E-5	DEFECT
do the failfast put outside the scope of the JTA txn	WITHOUT_CLASSIFICATION	0.9999287025643713	WITHOUT_CLASSIFICATION	7.129743562865201E-5	DEFECT
NOTE : evict() operates locally only (i.e., does not propogate to any other nodes in the potential cluster). This is exactly what is needed when we destroy() here; destroy() is used as part of the process of shutting down a SessionFactory; thus these removals should not be propogated	WITHOUT_CLASSIFICATION	0.9959364816379618	WITHOUT_CLASSIFICATION	0.004063518362038256	DEFECT
protected RegionRootListener listener;	WITHOUT_CLASSIFICATION	0.9997937184995455	WITHOUT_CLASSIFICATION	2.0628150045464458E-4	DEFECT
Establish the region root node with a non-locking data version	WITHOUT_CLASSIFICATION	0.9996119717814917	WITHOUT_CLASSIFICATION	3.8802821850828504E-4	DEFECT
If we've been blocking for the mutex, perhaps another thread has already reestablished the root. In case the node was reestablised via replication, confirm it's marked "resident" (a status which doesn't replicate)	WITHOUT_CLASSIFICATION	0.9999419269604914	WITHOUT_CLASSIFICATION	5.8073039508562936E-5	DEFECT
For pessimistic locking, we just want to toss out our ref to any old invalid root node and get the latest (may be null)	WITHOUT_CLASSIFICATION	0.9999996075634658	WITHOUT_CLASSIFICATION	3.9243653426463206E-7	DEFECT
The rest only matters for optimistic locking, where we need to establish the proper data version on the region root	WITHOUT_CLASSIFICATION	0.9916497815198548	WITHOUT_CLASSIFICATION	0.008350218480145114	DEFECT
Don't hold a transactional lock for this	WITHOUT_CLASSIFICATION	0.9997157096478085	WITHOUT_CLASSIFICATION	2.8429035219144477E-4	DEFECT
Make sure the root node for the region exists and has a DataVersion that never complains	WITHOUT_CLASSIFICATION	0.9999316675005778	WITHOUT_CLASSIFICATION	6.833249942217359E-5	DEFECT
Never evict this node	WITHOUT_CLASSIFICATION	0.9997842920139289	WITHOUT_CLASSIFICATION	2.1570798607108165E-4	DEFECT
Fix up the resident flag	WITHOUT_CLASSIFICATION	0.999904265981181	WITHOUT_CLASSIFICATION	9.573401881900221E-5	DEFECT
60 seconds	WITHOUT_CLASSIFICATION	0.9999771915159669	WITHOUT_CLASSIFICATION	2.2808484033148915E-5	DEFECT
We ignore minimalPutOverride. JBossCache putForExternalRead is already about as minimal as we can get; it will promptly return if it discovers that the node we want to write to already exists	WITHOUT_CLASSIFICATION	0.9999906364949043	WITHOUT_CLASSIFICATION	9.363505095683894E-6	DEFECT
no-op. We don't own the cache so we shouldn't stop it.	WITHOUT_CLASSIFICATION	0.9992059399665285	WITHOUT_CLASSIFICATION	7.940600334713873E-4	DEFECT
This should only be possible if the caches are constructor injected	WITHOUT_CLASSIFICATION	0.9913921030855071	WITHOUT_CLASSIFICATION	0.00860789691449306	DEFECT
We only build caches if none were passed in. Passing in caches counts as a clear statement of exactly what is wanted	WITHOUT_CLASSIFICATION	0.9950056913243237	WITHOUT_CLASSIFICATION	0.004994308675676221	DEFECT
Set up the cache factory	WITHOUT_CLASSIFICATION	0.999936456321307	WITHOUT_CLASSIFICATION	6.354367869300166E-5	DEFECT
See if the user configured a multiplexer stack	WITHOUT_CLASSIFICATION	0.9989035858919146	WITHOUT_CLASSIFICATION	0.0010964141080853935	DEFECT
Default to collections sharing entity cache if there is one	WITHOUT_CLASSIFICATION	0.9997461243386351	WITHOUT_CLASSIFICATION	2.538756613648551E-4	DEFECT
Default to sharing the entity cache if there is one	WITHOUT_CLASSIFICATION	0.9998148451334412	WITHOUT_CLASSIFICATION	1.8515486655870536E-4	DEFECT
For Timestamps, we default to a separate config	WITHOUT_CLASSIFICATION	0.9999866383416315	WITHOUT_CLASSIFICATION	1.3361658368597196E-5	DEFECT
We can't change the TM on a running cache; just check if the cache has no TM and we're OK with that	WITHOUT_CLASSIFICATION	0.9999992798725735	WITHOUT_CLASSIFICATION	7.201274263405584E-7	DEFECT
Configure the cache to use our TM	WITHOUT_CLASSIFICATION	0.9999226130671367	WITHOUT_CLASSIFICATION	7.738693286324633E-5	DEFECT
Make sure JBC doesn't look one up	WITHOUT_CLASSIFICATION	0.9997669070881626	WITHOUT_CLASSIFICATION	2.3309291183730538E-4	DEFECT
This method should be implemented assuming it's valid to do start/stop/start -- leave state appropriate for another start	WITHOUT_CLASSIFICATION	0.9971493519063552	WITHOUT_CLASSIFICATION	0.002850648093644882	DEFECT
Make sure we don't re-release the same cache	WITHOUT_CLASSIFICATION	0.999830457134075	WITHOUT_CLASSIFICATION	1.6954286592501692E-4	DEFECT
We use a different delegate than the non-optimistic superclass default	WITHOUT_CLASSIFICATION	0.9999515023622951	WITHOUT_CLASSIFICATION	4.849763770483734E-5	DEFECT
Following methods we don't delegate since they have so little logic it's clearer to just implement them here	WITHOUT_CLASSIFICATION	0.9999884424160446	WITHOUT_CLASSIFICATION	1.1557583955496518E-5	DEFECT
If JBC is using INVALIDATION, we don't want to propagate changes. We use the Timestamps cache to manage invalidation	WITHOUT_CLASSIFICATION	0.9981453283989307	WITHOUT_CLASSIFICATION	0.0018546716010692846	DEFECT
We don't want to waste effort setting an option if JBC is already in LOCAL mode. If JBC is REPL_(A)SYNC then check if they passed an config option to disable query replication	WITHOUT_CLASSIFICATION	0.9999335809910069	WITHOUT_CLASSIFICATION	6.64190089930953E-5	DEFECT
Don't hold the JBC node lock throughout the tx, as that prevents updates Add a zero (or low) timeout option so we don't block waiting for tx's that did a put to commit	WITHOUT_CLASSIFICATION	0.9999947275381205	WITHOUT_CLASSIFICATION	5.272461879623039E-6	DEFECT
Double check the distributed cache	WITHOUT_CLASSIFICATION	0.9999797088933664	WITHOUT_CLASSIFICATION	2.029110663358095E-5	DEFECT
Get an exclusive right to update JBC for this key from this node.	WITHOUT_CLASSIFICATION	0.9999289874261693	WITHOUT_CLASSIFICATION	7.101257383074428E-5	DEFECT
We ensure ASYNC semantics (JBCACHE-1175)	WITHOUT_CLASSIFICATION	0.9992917212448867	WITHOUT_CLASSIFICATION	7.082787551132169E-4	DEFECT
Initial load from JBC	WITHOUT_CLASSIFICATION	0.9998998072757763	WITHOUT_CLASSIFICATION	1.0019272422358199E-4	DEFECT
See if we had a 2nd invalidation from the same initial preinvalidation timestamp. If so, only increment if the new current value is an increase	WITHOUT_CLASSIFICATION	0.9999146877843293	WITHOUT_CLASSIFICATION	8.531221567059691E-5	DEFECT
We ensure ASYNC semantics (JBCACHE-1175)	WITHOUT_CLASSIFICATION	0.9992917212448867	WITHOUT_CLASSIFICATION	7.082787551132169E-4	DEFECT
If the workspace node has null as well, OK; if not we've been modified in a non-comparable manner, which we have to treat as us being newer	WITHOUT_CLASSIFICATION	0.9994988980315955	WITHOUT_CLASSIFICATION	5.011019684044442E-4	DEFECT
The standard comparator types are not Serializable but are singletons	WITHOUT_CLASSIFICATION	0.9991828538242133	WITHOUT_CLASSIFICATION	8.171461757866461E-4	DEFECT
ignore!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
ignore it	WITHOUT_CLASSIFICATION	0.9999813463475701	WITHOUT_CLASSIFICATION	1.8653652429912334E-5	DEFECT
construct the cache	WITHOUT_CLASSIFICATION	0.99993270379163	WITHOUT_CLASSIFICATION	6.729620837006667E-5	DEFECT
local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999730417312245	WITHOUT_CLASSIFICATION	2.6958268775457967E-5	DEFECT
local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999730417312245	WITHOUT_CLASSIFICATION	2.6958268775457967E-5	DEFECT
ie. 60 seconds	WITHOUT_CLASSIFICATION	0.9998378989860842	WITHOUT_CLASSIFICATION	1.621010139158601E-4	DEFECT
swaldman 2006-08-28: define c3p0-style configuration parameters for initialPoolSize, which hibernate sensibly lets default to minPoolSize, but we'll let users override it with the c3p0-style property if they want.	WITHOUT_CLASSIFICATION	0.9999992931446426	WITHOUT_CLASSIFICATION	7.068553573151735E-7	DEFECT
DataSource unpooled = DataSources.unpooledDataSource(jdbcUrl, props.getProperty(Environment.USER), props.getProperty(Environment.PASS));	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
TRUE if the pool is borrowed from the outside, FALSE if we used to create it	WITHOUT_CLASSIFICATION	0.9999657283766593	WITHOUT_CLASSIFICATION	3.427162334067164E-5	DEFECT
get a connection from the pool (thru DriverManager, cfr. Proxool doc)	WITHOUT_CLASSIFICATION	0.999941046683485	WITHOUT_CLASSIFICATION	5.895331651490396E-5	DEFECT
set the Transaction Isolation if defined	WITHOUT_CLASSIFICATION	0.9999815227958299	WITHOUT_CLASSIFICATION	1.847720417010049E-5	DEFECT
toggle autoCommit to false if set	WITHOUT_CLASSIFICATION	0.9998110872519191	WITHOUT_CLASSIFICATION	1.8891274808099188E-4	DEFECT
return the connection	WITHOUT_CLASSIFICATION	0.9999849929153516	WITHOUT_CLASSIFICATION	1.5007084648495707E-5	DEFECT
Get the configurator files (if available)	WITHOUT_CLASSIFICATION	0.9999220489508472	WITHOUT_CLASSIFICATION	7.795104915272897E-5	DEFECT
Default the Proxool alias setting	WITHOUT_CLASSIFICATION	0.9999271641825155	WITHOUT_CLASSIFICATION	7.283581748455172E-5	DEFECT
Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999927449366672	WITHOUT_CLASSIFICATION	7.255063332732149E-6	DEFECT
Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999927449366672	WITHOUT_CLASSIFICATION	7.255063332732149E-6	DEFECT
Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9998170680306943	WITHOUT_CLASSIFICATION	1.829319693057768E-4	DEFECT
Set the existing pool flag to true	WITHOUT_CLASSIFICATION	0.9998960663124525	WITHOUT_CLASSIFICATION	1.0393368754750276E-4	DEFECT
Configured using the JAXP Configurator	WITHOUT_CLASSIFICATION	0.9998582343509675	WITHOUT_CLASSIFICATION	1.417656490324011E-4	DEFECT
Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999927449366672	WITHOUT_CLASSIFICATION	7.255063332732149E-6	DEFECT
Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9998170680306943	WITHOUT_CLASSIFICATION	1.829319693057768E-4	DEFECT
Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9998170680306943	WITHOUT_CLASSIFICATION	1.829319693057768E-4	DEFECT
Configured using the Properties File Configurator	WITHOUT_CLASSIFICATION	0.999882034828859	WITHOUT_CLASSIFICATION	1.1796517114107078E-4	DEFECT
Remember Isolation level	WITHOUT_CLASSIFICATION	0.9999181669152074	WITHOUT_CLASSIFICATION	8.183308479267156E-5	DEFECT
If the provider was leeching off an existing pool don't close it	WITHOUT_CLASSIFICATION	0.999967878832057	WITHOUT_CLASSIFICATION	3.212116794307186E-5	DEFECT
We have created the pool ourselves, so shut it down	WITHOUT_CLASSIFICATION	0.99997827478098	WITHOUT_CLASSIFICATION	2.1725219019942532E-5	DEFECT
not really a many-to-one association necessarily	WITHOUT_CLASSIFICATION	0.9994011117928158	WITHOUT_CLASSIFICATION	5.988882071842437E-4	DEFECT
not really a many-to-one association necessarily	WITHOUT_CLASSIFICATION	0.9994011117928158	WITHOUT_CLASSIFICATION	5.988882071842437E-4	DEFECT
always overwrite nonversioned data	WITHOUT_CLASSIFICATION	0.999742446336246	WITHOUT_CLASSIFICATION	2.575536637540179E-4	DEFECT
public Currency getCurrency(int col) throws HibernateException;	WITHOUT_CLASSIFICATION	0.9998857842820137	WITHOUT_CLASSIFICATION	1.1421571798627481E-4	DEFECT
default is POJO	WITHOUT_CLASSIFICATION	0.9999574273559355	WITHOUT_CLASSIFICATION	4.257264406447953E-5	DEFECT
use setParameter for null values	WITHOUT_CLASSIFICATION	0.9998721580637113	WITHOUT_CLASSIFICATION	1.278419362887002E-4	DEFECT
use setParameter for null values	WITHOUT_CLASSIFICATION	0.9998721580637113	WITHOUT_CLASSIFICATION	1.278419362887002E-4	DEFECT
private CacheEntry cacheEntry;	WITHOUT_CLASSIFICATION	0.9998325255438357	WITHOUT_CLASSIFICATION	1.6747445616424502E-4	DEFECT
Don't need to lock the cache here, since if someone else inserted the same pk first, the insert would fail	WITHOUT_CLASSIFICATION	0.9992892157244926	WITHOUT_CLASSIFICATION	7.107842755075148E-4	DEFECT
Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!	WITHOUT_CLASSIFICATION	0.9996223747302136	WITHOUT_CLASSIFICATION	3.7762526978636087E-4	DEFECT
get the updated snapshot of the entity state by cloning current state; it is safe to copy in place, since by this time no-one else (should have) has a reference to the array	WITHOUT_CLASSIFICATION	0.999938857238076	WITHOUT_CLASSIFICATION	6.114276192413117E-5	DEFECT
this entity defines proeprty generation, so process those generated values...	WITHOUT_CLASSIFICATION	0.999978046005249	WITHOUT_CLASSIFICATION	2.1953994751051863E-5	DEFECT
have the entity entry perform post-update processing, passing it the update state and the new version (if one).	WITHOUT_CLASSIFICATION	0.9999129871757128	WITHOUT_CLASSIFICATION	8.701282428722634E-5	DEFECT
!persister.isCacheInvalidationRequired()	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
need to look it up from the persistence-context	WITHOUT_CLASSIFICATION	0.9997626378676563	WITHOUT_CLASSIFICATION	2.3736213234364342E-4	DEFECT
sort first by role name	WITHOUT_CLASSIFICATION	0.9999777969090737	WITHOUT_CLASSIFICATION	2.22030909263529E-5	DEFECT
Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!	WITHOUT_CLASSIFICATION	0.9996223747302136	WITHOUT_CLASSIFICATION	3.7762526978636087E-4	DEFECT
then by fk	WITHOUT_CLASSIFICATION	0.9999739918088998	WITHOUT_CLASSIFICATION	2.600819110018921E-5	DEFECT
nothing to do	WITHOUT_CLASSIFICATION	0.9999417257014112	WITHOUT_CLASSIFICATION	5.827429858879218E-5	DEFECT
nothing to do	WITHOUT_CLASSIFICATION	0.9999417257014112	WITHOUT_CLASSIFICATION	5.827429858879218E-5	DEFECT
an existing collection that was either non-empty or uninitialized is replaced by null or a different collection (if the collection is uninitialized, hibernate has no way of knowing if the collection is actually empty without querying the db)	WITHOUT_CLASSIFICATION	0.9999973494754797	WITHOUT_CLASSIFICATION	2.6505245204134485E-6	DEFECT
this method is called when a new non-null collection is persisted or when an existing (non-null) collection is moved to a new owner	WITHOUT_CLASSIFICATION	0.9999243436526927	WITHOUT_CLASSIFICATION	7.565634730732341E-5	DEFECT
boolean put = persister.getCache().insert(ck, cacheEntry);	WITHOUT_CLASSIFICATION	0.999925665782473	WITHOUT_CLASSIFICATION	7.433421752705364E-5	DEFECT
we need to grab the version value from the entity, otherwise we have issues with generated-version entities that may have multiple actions queued during the same flush	WITHOUT_CLASSIFICATION	0.9995721032563025	WITHOUT_CLASSIFICATION	4.2789674369750374E-4	DEFECT
do nothing - we only need to notify the cache...	WITHOUT_CLASSIFICATION	0.9994363775120182	WITHOUT_CLASSIFICATION	5.636224879817372E-4	DEFECT
sort first by entity name	WITHOUT_CLASSIFICATION	0.999977472045892	WITHOUT_CLASSIFICATION	2.2527954107965502E-5	DEFECT
then by id	WITHOUT_CLASSIFICATION	0.9999745630913468	WITHOUT_CLASSIFICATION	2.5436908653201633E-5	DEFECT
to be safe...	WITHOUT_CLASSIFICATION	0.999688993137367	WITHOUT_CLASSIFICATION	3.1100686263294425E-4	DEFECT
no transformations took place, so handle it as we would a non-instrumented class	WITHOUT_CLASSIFICATION	0.9999645357446301	WITHOUT_CLASSIFICATION	3.546425536993559E-5	DEFECT
see if the entry represents a class file	WITHOUT_CLASSIFICATION	0.999944905875337	WITHOUT_CLASSIFICATION	5.509412466296133E-5	DEFECT
see if the entry represents a class file	WITHOUT_CLASSIFICATION	0.999944905875337	WITHOUT_CLASSIFICATION	5.509412466296133E-5	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
test out the optimizer:	WITHOUT_CLASSIFICATION	0.9999649109684737	WITHOUT_CLASSIFICATION	3.508903152631105E-5	DEFECT
set the name of bulk accessor.	WITHOUT_CLASSIFICATION	0.9999726435787504	WITHOUT_CLASSIFICATION	2.7356421249625114E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
invokespecial	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
aload_1 load bean	WITHOUT_CLASSIFICATION	0.999867997554491	WITHOUT_CLASSIFICATION	1.320024455089681E-4	DEFECT
checkcast cast bean	WITHOUT_CLASSIFICATION	0.9998507911725515	WITHOUT_CLASSIFICATION	1.4920882744853437E-4	DEFECT
astore_3 store bean	WITHOUT_CLASSIFICATION	0.999889040344038	WITHOUT_CLASSIFICATION	1.1095965596206385E-4	DEFECT
aload_2 args	WITHOUT_CLASSIFICATION	0.9996353991216587	WITHOUT_CLASSIFICATION	3.6460087834127534E-4	DEFECT
iconst_i continue to aastore growing stack is 1	WITHOUT_CLASSIFICATION	0.9985252143411782	WITHOUT_CLASSIFICATION	0.00147478565882175	DEFECT
new	WITHOUT_CLASSIFICATION	0.9999839553486869	WITHOUT_CLASSIFICATION	1.6044651313179904E-5	DEFECT
dup	WITHOUT_CLASSIFICATION	0.9999768310717404	WITHOUT_CLASSIFICATION	2.316892825965638E-5	DEFECT
aload_3 load the raw bean	WITHOUT_CLASSIFICATION	0.9999377149450828	WITHOUT_CLASSIFICATION	6.228505491720558E-5	DEFECT
invokeinterface	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
invokevirtual	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
invokevirtual	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
aastore args	WITHOUT_CLASSIFICATION	0.9996353991216587	WITHOUT_CLASSIFICATION	3.6460087834127534E-4	DEFECT
| this | bean | args | i | raw bean | exception |	WITHOUT_CLASSIFICATION	0.9984327591498208	WITHOUT_CLASSIFICATION	0.0015672408501791891	DEFECT
required to exception table iconst_0 i	WITHOUT_CLASSIFICATION	0.9989850438674637	WITHOUT_CLASSIFICATION	0.0010149561325363187	DEFECT
istore_3 store i	WITHOUT_CLASSIFICATION	0.9998931940787464	WITHOUT_CLASSIFICATION	1.0680592125357079E-4	DEFECT
aload_1 load the bean	WITHOUT_CLASSIFICATION	0.9999387407720347	WITHOUT_CLASSIFICATION	6.125922796532413E-5	DEFECT
checkcast cast the bean into a raw bean	WITHOUT_CLASSIFICATION	0.9996581184961778	WITHOUT_CLASSIFICATION	3.4188150382223343E-4	DEFECT
current stack len = 0	WITHOUT_CLASSIFICATION	0.9999341499020659	WITHOUT_CLASSIFICATION	6.58500979341334E-5	DEFECT
start region to handling exception (BulkAccessorException)	WITHOUT_CLASSIFICATION	0.9995204779787555	WITHOUT_CLASSIFICATION	4.795220212445029E-4	DEFECT
iinc 3, 1	WITHOUT_CLASSIFICATION	0.9999878102652289	WITHOUT_CLASSIFICATION	1.2189734771060745E-5	DEFECT
aload 4 load the raw bean	WITHOUT_CLASSIFICATION	0.9999025821728066	WITHOUT_CLASSIFICATION	9.741782719348858E-5	DEFECT
aload_2 load the args	WITHOUT_CLASSIFICATION	0.9998642502305591	WITHOUT_CLASSIFICATION	1.3574976944082088E-4	DEFECT
iconst_i	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aaload	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
checkcast	WITHOUT_CLASSIFICATION	0.9999767859895251	WITHOUT_CLASSIFICATION	2.3214010474944542E-5	DEFECT
checkcast (case of primitive type) invokevirtual (case of primitive type)	WITHOUT_CLASSIFICATION	0.9998717701466846	WITHOUT_CLASSIFICATION	1.2822985331543873E-4	DEFECT
checkcast (case of reference type)	WITHOUT_CLASSIFICATION	0.9999131813621257	WITHOUT_CLASSIFICATION	8.681863787430272E-5	DEFECT
current stack len = 2	WITHOUT_CLASSIFICATION	0.9991297139582095	WITHOUT_CLASSIFICATION	8.702860417905741E-4	DEFECT
end region to handling exception (BulkAccessorException)	WITHOUT_CLASSIFICATION	0.9993754029773897	WITHOUT_CLASSIFICATION	6.245970226104156E-4	DEFECT
register in exception table	WITHOUT_CLASSIFICATION	0.9999443606150309	WITHOUT_CLASSIFICATION	5.563938496915879E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aload_0	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
dup	WITHOUT_CLASSIFICATION	0.9999768310717404	WITHOUT_CLASSIFICATION	2.316892825965638E-5	DEFECT
invokevirtual	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
checkcast	WITHOUT_CLASSIFICATION	0.9999767859895251	WITHOUT_CLASSIFICATION	2.3214010474944542E-5	DEFECT
local variables | target obj | each oldvalue |	WITHOUT_CLASSIFICATION	0.9999893529819501	WITHOUT_CLASSIFICATION	1.0647018049897665E-5	DEFECT
astore 5 store exception	WITHOUT_CLASSIFICATION	0.9998265863889262	WITHOUT_CLASSIFICATION	1.7341361107379042E-4	DEFECT
new BulkAccessorException	WITHOUT_CLASSIFICATION	0.9999269261304355	WITHOUT_CLASSIFICATION	7.307386956447966E-5	DEFECT
aload 5 load exception	WITHOUT_CLASSIFICATION	0.9997937020496339	WITHOUT_CLASSIFICATION	2.0629795036615609E-4	DEFECT
iload_3 i	WITHOUT_CLASSIFICATION	0.9999777133350687	WITHOUT_CLASSIFICATION	2.228666493127885E-5	DEFECT
invokespecial BulkAccessorException.<init>	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
athrow	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
WARNING: classfile only	WITHOUT_CLASSIFICATION	0.9964126799855824	WITHOUT_CLASSIFICATION	0.00358732001441772	DEFECT
swallow	WITHOUT_CLASSIFICATION	0.999977275959827	WITHOUT_CLASSIFICATION	2.2724040173023583E-5	DEFECT
local variable | this |	WITHOUT_CLASSIFICATION	0.9999419012131598	WITHOUT_CLASSIFICATION	5.809878684012813E-5	DEFECT
aload_0 load this	WITHOUT_CLASSIFICATION	0.9997149200618354	WITHOUT_CLASSIFICATION	2.850799381645961E-4	DEFECT
aload_0 load this	WITHOUT_CLASSIFICATION	0.9997149200618354	WITHOUT_CLASSIFICATION	2.850799381645961E-4	DEFECT
getfield get field "$JAVASSIST_CALLBACK" defined already	WITHOUT_CLASSIFICATION	0.999994465552769	WITHOUT_CLASSIFICATION	5.534447230885107E-6	DEFECT
areturn return the value of the field	WITHOUT_CLASSIFICATION	0.9999789890155039	WITHOUT_CLASSIFICATION	2.1010984496170073E-5	DEFECT
local variables | this | callback |	WITHOUT_CLASSIFICATION	0.9998659114485517	WITHOUT_CLASSIFICATION	1.3408855144830145E-4	DEFECT
aload_1 load callback	WITHOUT_CLASSIFICATION	0.9999164293728852	WITHOUT_CLASSIFICATION	8.357062711481642E-5	DEFECT
putfield put field "$JAVASSIST_CALLBACK" defined already	WITHOUT_CLASSIFICATION	0.9999919077000379	WITHOUT_CLASSIFICATION	8.092299962058659E-6	DEFECT
case of non-static field	WITHOUT_CLASSIFICATION	0.9999335932084015	WITHOUT_CLASSIFICATION	6.64067915986265E-5	DEFECT
getfield get each field	WITHOUT_CLASSIFICATION	0.9999830333157493	WITHOUT_CLASSIFICATION	1.6966684250645032E-5	DEFECT
invokeinterface invoke Enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9998154103637006	WITHOUT_CLASSIFICATION	1.8458963629942553E-4	DEFECT
ifnonnull	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
return each type	WITHOUT_CLASSIFICATION	0.999969599156932	WITHOUT_CLASSIFICATION	3.0400843068023806E-5	DEFECT
return each type	WITHOUT_CLASSIFICATION	0.999969599156932	WITHOUT_CLASSIFICATION	3.0400843068023806E-5	DEFECT
store_1 each type	WITHOUT_CLASSIFICATION	0.9998840434140776	WITHOUT_CLASSIFICATION	1.1595658592243287E-4	DEFECT
ldc name of the field	WITHOUT_CLASSIFICATION	0.9999723957966916	WITHOUT_CLASSIFICATION	2.7604203308391666E-5	DEFECT
load_1 each type	WITHOUT_CLASSIFICATION	0.9998840434140776	WITHOUT_CLASSIFICATION	1.1595658592243287E-4	DEFECT
invokeinterface invoke Callback.read() each type	WITHOUT_CLASSIFICATION	0.9998703880429867	WITHOUT_CLASSIFICATION	1.2961195701335318E-4	DEFECT
int	WITHOUT_CLASSIFICATION	0.9999244204956926	WITHOUT_CLASSIFICATION	7.55795043073485E-5	DEFECT
return	WITHOUT_CLASSIFICATION	0.9999939083842441	WITHOUT_CLASSIFICATION	6.091615755998672E-6	DEFECT
dup	WITHOUT_CLASSIFICATION	0.9999768310717404	WITHOUT_CLASSIFICATION	2.316892825965638E-5	DEFECT
invokeinterface	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
checkcast	WITHOUT_CLASSIFICATION	0.9999767859895251	WITHOUT_CLASSIFICATION	2.3214010474944542E-5	DEFECT
checkcast	WITHOUT_CLASSIFICATION	0.9999767859895251	WITHOUT_CLASSIFICATION	2.3214010474944542E-5	DEFECT
invokeinterface enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
invokeinterface enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
ifnonnull (label1)	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
load_1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
load_1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
putfield	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
return ;	WITHOUT_CLASSIFICATION	0.999993953781856	WITHOUT_CLASSIFICATION	6.046218144085516E-6	DEFECT
ldc field name	WITHOUT_CLASSIFICATION	0.9999389206112553	WITHOUT_CLASSIFICATION	6.107938874463222E-5	DEFECT
getfield old value of the field	WITHOUT_CLASSIFICATION	0.9999328601468769	WITHOUT_CLASSIFICATION	6.713985312310173E-5	DEFECT
invokeinterface callback.write(..)	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
reference type	WITHOUT_CLASSIFICATION	0.9999182243961765	WITHOUT_CLASSIFICATION	8.177560382345038E-5	DEFECT
reference type	WITHOUT_CLASSIFICATION	0.9999182243961765	WITHOUT_CLASSIFICATION	8.177560382345038E-5	DEFECT
not array	WITHOUT_CLASSIFICATION	0.99986562740211	WITHOUT_CLASSIFICATION	1.3437259789001618E-4	DEFECT
array of reference type	WITHOUT_CLASSIFICATION	0.9999529734076612	WITHOUT_CLASSIFICATION	4.7026592338885285E-5	DEFECT
boolean	WITHOUT_CLASSIFICATION	0.9999844518001724	WITHOUT_CLASSIFICATION	1.5548199827612493E-5	DEFECT
byte	WITHOUT_CLASSIFICATION	0.9999815782531498	WITHOUT_CLASSIFICATION	1.8421746850223455E-5	DEFECT
char	WITHOUT_CLASSIFICATION	0.9999818298188518	WITHOUT_CLASSIFICATION	1.8170181148265178E-5	DEFECT
short	WITHOUT_CLASSIFICATION	0.9999783106525199	WITHOUT_CLASSIFICATION	2.1689347480109528E-5	DEFECT
double	WITHOUT_CLASSIFICATION	0.9999889331532725	WITHOUT_CLASSIFICATION	1.1066846727550567E-5	DEFECT
float	WITHOUT_CLASSIFICATION	0.9999773151953177	WITHOUT_CLASSIFICATION	2.2684804682199283E-5	DEFECT
float	WITHOUT_CLASSIFICATION	0.9999773151953177	WITHOUT_CLASSIFICATION	2.2684804682199283E-5	DEFECT
long	WITHOUT_CLASSIFICATION	0.9999874558113997	WITHOUT_CLASSIFICATION	1.2544188600190343E-5	DEFECT
long	WITHOUT_CLASSIFICATION	0.9999874558113997	WITHOUT_CLASSIFICATION	1.2544188600190343E-5	DEFECT
bad type	WITHOUT_CLASSIFICATION	0.9998170728172227	WITHOUT_CLASSIFICATION	1.8292718277732343E-4	DEFECT
bad type	WITHOUT_CLASSIFICATION	0.9998170728172227	WITHOUT_CLASSIFICATION	1.8292718277732343E-4	DEFECT
boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9998091574599649	WITHOUT_CLASSIFICATION	1.908425400350399E-4	DEFECT
boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9998091574599649	WITHOUT_CLASSIFICATION	1.908425400350399E-4	DEFECT
reference type	WITHOUT_CLASSIFICATION	0.9999182243961765	WITHOUT_CLASSIFICATION	8.177560382345038E-5	DEFECT
double	WITHOUT_CLASSIFICATION	0.9999889331532725	WITHOUT_CLASSIFICATION	1.1066846727550567E-5	DEFECT
float	WITHOUT_CLASSIFICATION	0.9999773151953177	WITHOUT_CLASSIFICATION	2.2684804682199283E-5	DEFECT
float	WITHOUT_CLASSIFICATION	0.9999773151953177	WITHOUT_CLASSIFICATION	2.2684804682199283E-5	DEFECT
long	WITHOUT_CLASSIFICATION	0.9999874558113997	WITHOUT_CLASSIFICATION	1.2544188600190343E-5	DEFECT
bad type	WITHOUT_CLASSIFICATION	0.9998170728172227	WITHOUT_CLASSIFICATION	1.8292718277732343E-4	DEFECT
bad type	WITHOUT_CLASSIFICATION	0.9998170728172227	WITHOUT_CLASSIFICATION	1.8292718277732343E-4	DEFECT
boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9998091574599649	WITHOUT_CLASSIFICATION	1.908425400350399E-4	DEFECT
skip finalize methods	WITHOUT_CLASSIFICATION	0.9999454227349753	WITHOUT_CLASSIFICATION	5.4577265024681016E-5	DEFECT
Mainly for OSCache	WITHOUT_CLASSIFICATION	0.9998433175153818	WITHOUT_CLASSIFICATION	1.5668248461830257E-4	DEFECT
decrement the lock	WITHOUT_CLASSIFICATION	0.9999321642664072	WITHOUT_CLASSIFICATION	6.783573359280864E-5	DEFECT
create new lock that times out immediately	WITHOUT_CLASSIFICATION	0.9999711926662214	WITHOUT_CLASSIFICATION	2.880733377872557E-5	DEFECT
recache the updated state	WITHOUT_CLASSIFICATION	0.9999392831459433	WITHOUT_CLASSIFICATION	6.0716854056773416E-5	DEFECT
noop	WITHOUT_CLASSIFICATION	0.9999770556436615	WITHOUT_CLASSIFICATION	2.2944356338565953E-5	DEFECT
null clientLock is remotely possible but will never happen in practice	WITHOUT_CLASSIFICATION	0.9970095636210763	WITHOUT_CLASSIFICATION	0.0029904363789236654	DEFECT
we really could refresh the item if it is not a lock, but it might be slower return freshTimestamp < txTimestamp	WITHOUT_CLASSIFICATION	0.9979140839198823	WITHOUT_CLASSIFICATION	0.0020859160801176536	DEFECT
by requiring <, we rely on lock timeout in the case of an unsuccessful update!	WITHOUT_CLASSIFICATION	0.9999127644037428	WITHOUT_CLASSIFICATION	8.723559625724261E-5	DEFECT
the user provided resulttransformer, not the one used with "select new". Here to avoid mangling transformed/non-transformed results.	WITHOUT_CLASSIFICATION	0.9999282554102763	WITHOUT_CLASSIFICATION	7.174458972364598E-5	DEFECT
disassemble positional parameters	WITHOUT_CLASSIFICATION	0.9998269523810646	WITHOUT_CLASSIFICATION	1.730476189354522E-4	DEFECT
disassemble named parameters	WITHOUT_CLASSIFICATION	0.9999250233678764	WITHOUT_CLASSIFICATION	7.497663212366611E-5	DEFECT
ie. 60 seconds	WITHOUT_CLASSIFICATION	0.9998378989860842	WITHOUT_CLASSIFICATION	1.621010139158601E-4	DEFECT
noop	WITHOUT_CLASSIFICATION	0.9999770556436615	WITHOUT_CLASSIFICATION	2.2944356338565953E-5	DEFECT
noop	WITHOUT_CLASSIFICATION	0.9999770556436615	WITHOUT_CLASSIFICATION	2.2944356338565953E-5	DEFECT
noop	WITHOUT_CLASSIFICATION	0.9999770556436615	WITHOUT_CLASSIFICATION	2.2944356338565953E-5	DEFECT
this is called from SettingsFactory irregardless; trivial to simply disregard	WITHOUT_CLASSIFICATION	0.9990970415160572	WITHOUT_CLASSIFICATION	9.029584839428265E-4	DEFECT
Do nothing; subclasses may override.	WITHOUT_CLASSIFICATION	0.9999415344342463	WITHOUT_CLASSIFICATION	5.8465565753798475E-5	DEFECT
Do nothing; subclasses may override.	WITHOUT_CLASSIFICATION	0.9999415344342463	WITHOUT_CLASSIFICATION	5.8465565753798475E-5	DEFECT
throw new UnsupportedOperationException("Can't write to a readonly object");	WITHOUT_CLASSIFICATION	0.9994187850495384	WITHOUT_CLASSIFICATION	5.8121495046163E-4	DEFECT
assembled state gets put in a new array (we read from cache by value!)	WITHOUT_CLASSIFICATION	0.9999699105812507	WITHOUT_CLASSIFICATION	3.0089418749271114E-5	DEFECT
persister.setIdentifier(result, id); before calling interceptor, for consistency with normal load	WITHOUT_CLASSIFICATION	0.9991277061628878	WITHOUT_CLASSIFICATION	8.722938371122339E-4	DEFECT
no-op; CCS did not have such a concept	WITHOUT_CLASSIFICATION	0.9989088919974977	WITHOUT_CLASSIFICATION	0.0010911080025023169	DEFECT
no-op; CCS did not have such a concept	WITHOUT_CLASSIFICATION	0.9989088919974977	WITHOUT_CLASSIFICATION	0.0010911080025023169	DEFECT
again, CCS did not have such a concept; but a reasonable proximity is to clear the cache after transaction as long as the underlying cache is not JTA aware.	WITHOUT_CLASSIFICATION	0.9999097074420278	WITHOUT_CLASSIFICATION	9.029255797230479E-5	DEFECT
again, CCS did not have such a concept; however a reasonable proximity is to clear the cache. For non-transaction aware caches, we will also do a clear at the end of the transaction	WITHOUT_CLASSIFICATION	0.9997408300232539	WITHOUT_CLASSIFICATION	2.5916997674612453E-4	DEFECT
again, CCS did not have such a concept; however a reasonable proximity is to clear the cache. For non-transaction aware caches, we will also do a clear at the end of the transaction	WITHOUT_CLASSIFICATION	0.9997408300232539	WITHOUT_CLASSIFICATION	2.5916997674612453E-4	DEFECT
classes mentioned in extends not available - so put it in queue	WITHOUT_CLASSIFICATION	0.9997741920440142	WITHOUT_CLASSIFICATION	2.2580795598573804E-4	DEFECT
get meta's from <hibernate-mapping>	WITHOUT_CLASSIFICATION	0.9998856015375117	WITHOUT_CLASSIFICATION	1.1439846248830213E-4	DEFECT
get meta's from <class>	WITHOUT_CLASSIFICATION	0.9999429598056846	WITHOUT_CLASSIFICATION	5.704019431545946E-5	DEFECT
DB-OBJECTNAME	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
MUTABLE	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
WHERE	WITHOUT_CLASSIFICATION	0.9999802918566811	WITHOUT_CLASSIFICATION	1.970814331885447E-5	DEFECT
CHECK	WITHOUT_CLASSIFICATION	0.9999770609890836	WITHOUT_CLASSIFICATION	2.293901091652638E-5	DEFECT
POLYMORPHISM	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
TODO:	WITHOUT_CLASSIFICATION	0.9894410227413188	WITHOUT_CLASSIFICATION	0.01055897725868117	DEFECT
ID	WITHOUT_CLASSIFICATION	0.9999771072215078	WITHOUT_CLASSIFICATION	2.2892778492219975E-5	DEFECT
VERSION / TIMESTAMP	WITHOUT_CLASSIFICATION	0.9998728616797458	WITHOUT_CLASSIFICATION	1.2713832025431916E-4	DEFECT
DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Primary key constraint	WITHOUT_CLASSIFICATION	0.9999550518803028	WITHOUT_CLASSIFICATION	4.494811969734157E-5	DEFECT
this is either a <version/> tag with no type attribute, or a <timestamp/> tag	WITHOUT_CLASSIFICATION	0.9999546841593078	WITHOUT_CLASSIFICATION	4.531584069233921E-5	DEFECT
for version properties marked as being generated, make sure they are "always" generated; aka, "insert" is invalid; this is dis-allowed by the DTD, but just to make sure...	WITHOUT_CLASSIFICATION	0.9999580555935196	WITHOUT_CLASSIFICATION	4.1944406480466145E-5	DEFECT
DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
( (Column) discrim.getColumnIterator().next() ).setType(type);	WITHOUT_CLASSIFICATION	0.9999143921871652	WITHOUT_CLASSIFICATION	8.560781283482628E-5	DEFECT
go ahead and set the lazy here, since pojo.proxy can override it.	WITHOUT_CLASSIFICATION	0.9999972970187412	WITHOUT_CLASSIFICATION	2.702981258793932E-6	DEFECT
DYNAMIC UPDATE	WITHOUT_CLASSIFICATION	0.999851455615321	WITHOUT_CLASSIFICATION	1.4854438467897576E-4	DEFECT
IMPORT	WITHOUT_CLASSIFICATION	0.9999790725448261	WITHOUT_CLASSIFICATION	2.0927455173860905E-5	DEFECT
BATCH SIZE	WITHOUT_CLASSIFICATION	0.9999768318048561	WITHOUT_CLASSIFICATION	2.316819514391296E-5	DEFECT
SELECT BEFORE UPDATE	WITHOUT_CLASSIFICATION	0.999861484527183	WITHOUT_CLASSIFICATION	1.385154728169881E-4	DEFECT
OPTIMISTIC LOCK MODE	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
PERSISTER	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
CUSTOM SQL	WITHOUT_CLASSIFICATION	0.999986187352505	WITHOUT_CLASSIFICATION	1.3812647495006053E-5	DEFECT
get meta's from <subclass>	WITHOUT_CLASSIFICATION	0.9999429598056846	WITHOUT_CLASSIFICATION	5.704019431545946E-5	DEFECT
properties	WITHOUT_CLASSIFICATION	0.999956548669983	WITHOUT_CLASSIFICATION	4.3451330017054985E-5	DEFECT
joined subclasses	WITHOUT_CLASSIFICATION	0.9998610238876239	WITHOUT_CLASSIFICATION	1.3897611237614362E-4	DEFECT
KEY	WITHOUT_CLASSIFICATION	0.9999791203443746	WITHOUT_CLASSIFICATION	2.0879655625363435E-5	DEFECT
CHECK	WITHOUT_CLASSIFICATION	0.9999770609890836	WITHOUT_CLASSIFICATION	2.293901091652638E-5	DEFECT
CUSTOM SQL	WITHOUT_CLASSIFICATION	0.999986187352505	WITHOUT_CLASSIFICATION	1.3812647495006053E-5	DEFECT
properties	WITHOUT_CLASSIFICATION	0.999956548669983	WITHOUT_CLASSIFICATION	4.3451330017054985E-5	DEFECT
KEY	WITHOUT_CLASSIFICATION	0.9999791203443746	WITHOUT_CLASSIFICATION	2.0879655625363435E-5	DEFECT
model.getKey().setType( new Type( model.getIdentifier() ) );	WITHOUT_CLASSIFICATION	0.9995836384129115	WITHOUT_CLASSIFICATION	4.1636158708837793E-4	DEFECT
TABLENAME	WITHOUT_CLASSIFICATION	0.9999767722821981	WITHOUT_CLASSIFICATION	2.3227717801980865E-5	DEFECT
join.getKey().setType( new Type( lazz.getIdentifier() ) );	WITHOUT_CLASSIFICATION	0.9995836384129115	WITHOUT_CLASSIFICATION	4.1636158708837793E-4	DEFECT
PROPERTIES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
COLUMN(S)	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
column index	WITHOUT_CLASSIFICATION	0.9998571898404076	WITHOUT_CLASSIFICATION	1.4281015959247392E-4	DEFECT
column unique-key	WITHOUT_CLASSIFICATION	0.9999161121749158	WITHOUT_CLASSIFICATION	8.388782508413558E-5	DEFECT
automatically makes a column with the default name if none is specifed by XML	WITHOUT_CLASSIFICATION	0.9999873948895593	WITHOUT_CLASSIFICATION	1.2605110440698445E-5	DEFECT
for an any	WITHOUT_CLASSIFICATION	0.9999959725165	WITHOUT_CLASSIFICATION	4.027483499992466E-6	DEFECT
insertable simply because that is the user did not specify anything; just override it	WITHOUT_CLASSIFICATION	0.9999371708219348	WITHOUT_CLASSIFICATION	6.282917806521008E-5	DEFECT
the user specifically supplied insert="true", which constitutes an illegal combo	WITHOUT_CLASSIFICATION	0.9999678706315184	WITHOUT_CLASSIFICATION	3.212936848165449E-5	DEFECT
properties generated on update can never be updateable...	WITHOUT_CLASSIFICATION	0.9991496234272143	WITHOUT_CLASSIFICATION	8.503765727858284E-4	DEFECT
updateable only because the user did not specify anything; just override it	WITHOUT_CLASSIFICATION	0.9998568923062074	WITHOUT_CLASSIFICATION	1.4310769379252382E-4	DEFECT
the user specifically supplied update="true", which constitutes an illegal combo	WITHOUT_CLASSIFICATION	0.9999678706315184	WITHOUT_CLASSIFICATION	3.212936848165449E-5	DEFECT
ROLENAME	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
FETCH STRATEGY	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
TABLE	WITHOUT_CLASSIFICATION	0.9999819150325552	WITHOUT_CLASSIFICATION	1.8084967444784438E-5	DEFECT
tableName = mappings.getNamingStrategy().propertyToTableName( className, path );	WITHOUT_CLASSIFICATION	0.9996231421762194	WITHOUT_CLASSIFICATION	3.7685782378064366E-4	DEFECT
SORT	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
CUSTOM SQL	WITHOUT_CLASSIFICATION	0.999986187352505	WITHOUT_CLASSIFICATION	1.3812647495006053E-5	DEFECT
unsorted, natural, comparator.class.name	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
ORPHAN DELETE (used for programmer error detection)	WITHOUT_CLASSIFICATION	0.9997452583395385	WITHOUT_CLASSIFICATION	2.547416604614676E-4	DEFECT
set up second pass	WITHOUT_CLASSIFICATION	0.999667261999858	WITHOUT_CLASSIFICATION	3.327380001420304E-4	DEFECT
an "embedded" component (composite ids and unique) note that this does not handle nested components	WITHOUT_CLASSIFICATION	0.9982791922593457	WITHOUT_CLASSIFICATION	0.0017208077406542918	DEFECT
a nested composite element	WITHOUT_CLASSIFICATION	0.9998637512793638	WITHOUT_CLASSIFICATION	1.3624872063615145E-4	DEFECT
for an any we will have to use reflection	WITHOUT_CLASSIFICATION	0.9998370453578718	WITHOUT_CLASSIFICATION	1.629546421282352E-4	DEFECT
NOTE SPECIAL CASE: one-to-one constrained=false cannot be proxied, so default to join and non-lazy	WITHOUT_CLASSIFICATION	0.9999927074491006	WITHOUT_CLASSIFICATION	7.292550899409878E-6	DEFECT
use old (HB 2.1) defaults if outer-join is specified	WITHOUT_CLASSIFICATION	0.9996843940287626	WITHOUT_CLASSIFICATION	3.156059712374021E-4	DEFECT
lazy = !join;	WITHOUT_CLASSIFICATION	0.9998874349490658	WITHOUT_CLASSIFICATION	1.1256505093406491E-4	DEFECT
GENERATOR	WITHOUT_CLASSIFICATION	0.9999768525353598	WITHOUT_CLASSIFICATION	2.3147464640120447E-5	DEFECT
ID UNSAVED-VALUE	WITHOUT_CLASSIFICATION	0.9998372999849904	WITHOUT_CLASSIFICATION	1.6270001500961348E-4	DEFECT
VERSION UNSAVED-VALUE	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
not necessarily a unique property reference	WITHOUT_CLASSIFICATION	0.999271955895948	WITHOUT_CLASSIFICATION	7.280441040520322E-4	DEFECT
( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() ).setNullable(false);	WITHOUT_CLASSIFICATION	0.9999143921871652	WITHOUT_CLASSIFICATION	8.560781283482628E-5	DEFECT
contained elements:	WITHOUT_CLASSIFICATION	0.9998839357415708	WITHOUT_CLASSIFICATION	1.1606425842923001E-4	DEFECT
for non-inverse one-to-many, with a not-null fk, add a backref!	WITHOUT_CLASSIFICATION	0.999746753568476	WITHOUT_CLASSIFICATION	2.5324643152410247E-4	DEFECT
Bind the where	WITHOUT_CLASSIFICATION	0.9999370848218606	WITHOUT_CLASSIFICATION	6.291517813939732E-5	DEFECT
Bind the order-by	WITHOUT_CLASSIFICATION	0.9998850332062451	WITHOUT_CLASSIFICATION	1.1496679375493641E-4	DEFECT
Bind the filters	WITHOUT_CLASSIFICATION	0.9998850332062451	WITHOUT_CLASSIFICATION	1.1496679375493641E-4	DEFECT
overriding inherited meta attribute. HBX-621 & HBX-793	WITHOUT_CLASSIFICATION	0.9999078365720211	WITHOUT_CLASSIFICATION	9.216342797883517E-5	DEFECT
first, iterate over all elements capable of defining an extends attribute collecting all found extends references if they cannot be resolved against the already processed mappings.	WITHOUT_CLASSIFICATION	0.999999030484386	WITHOUT_CLASSIFICATION	9.695156140031227E-7	DEFECT
mappings might contain either the "raw" extends name (in the case of an entity-name mapping) or a FQN (in the case of a POJO mapping).	WITHOUT_CLASSIFICATION	0.9999553027719753	WITHOUT_CLASSIFICATION	4.4697228024818844E-5	DEFECT
+ "_" + referencedColumnName not used for backward compatibility	WITHOUT_CLASSIFICATION	0.999879007349514	WITHOUT_CLASSIFICATION	1.209926504859953E-4	DEFECT
SessionFactory name:	WITHOUT_CLASSIFICATION	0.9998754955919098	WITHOUT_CLASSIFICATION	1.2450440809031157E-4	DEFECT
JDBC and connection settings:	WITHOUT_CLASSIFICATION	0.9999397016069748	WITHOUT_CLASSIFICATION	6.029839302513359E-5	DEFECT
JDBC and connection settings:	WITHOUT_CLASSIFICATION	0.9999397016069748	WITHOUT_CLASSIFICATION	6.029839302513359E-5	DEFECT
Interrogate JDBC metadata	WITHOUT_CLASSIFICATION	0.9998852351092787	WITHOUT_CLASSIFICATION	1.1476489072118011E-4	DEFECT
user supplied JDBC connections	WITHOUT_CLASSIFICATION	0.9998826713595418	WITHOUT_CLASSIFICATION	1.1732864045821905E-4	DEFECT
use dialect default properties	WITHOUT_CLASSIFICATION	0.9999694304064595	WITHOUT_CLASSIFICATION	3.05695935405678E-5	DEFECT
Transaction settings:	WITHOUT_CLASSIFICATION	0.9998942351742655	WITHOUT_CLASSIFICATION	1.0576482573463038E-4	DEFECT
SQL Generation settings:	WITHOUT_CLASSIFICATION	0.9999371403279703	WITHOUT_CLASSIFICATION	6.285967202961309E-5	DEFECT
Query parser settings:	WITHOUT_CLASSIFICATION	0.9998856938412233	WITHOUT_CLASSIFICATION	1.1430615877671562E-4	DEFECT
Second-level / query cache:	WITHOUT_CLASSIFICATION	0.9996848695815075	WITHOUT_CLASSIFICATION	3.151304184924976E-4	DEFECT
The cache provider is needed when we either have second-level cache enabled or query cache enabled. Note that useSecondLevelCache is enabled by default	WITHOUT_CLASSIFICATION	0.9999014684071623	WITHOUT_CLASSIFICATION	9.853159283771248E-5	DEFECT
SQL Exception converter:	WITHOUT_CLASSIFICATION	0.9999539808790829	WITHOUT_CLASSIFICATION	4.601912091708752E-5	DEFECT
Statistics and logging:	WITHOUT_CLASSIFICATION	0.9999256868631095	WITHOUT_CLASSIFICATION	7.43131368905055E-5	DEFECT
settings.setShowSqlEnabled(showSql);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
settings.setFormatSqlEnabled(formatSql);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
Schema export:	WITHOUT_CLASSIFICATION	0.9998554463032769	WITHOUT_CLASSIFICATION	1.4455369672307855E-4	DEFECT
String provider = properties.getProperty( Environment.BYTECODE_PROVIDER ); log.info( "Bytecode provider name : " + provider ); BytecodeProvider bytecodeProvider = buildBytecodeProvider( provider ); settings.setBytecodeProvider( bytecodeProvider );	WITHOUT_CLASSIFICATION	0.9993572397287865	WITHOUT_CLASSIFICATION	6.42760271213332E-4	DEFECT
legacy behavior, apply the bridge...	WITHOUT_CLASSIFICATION	0.9998386089636999	WITHOUT_CLASSIFICATION	1.6139103630001818E-4	DEFECT
maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the moment	WITHOUT_CLASSIFICATION	0.9994827942977127	WITHOUT_CLASSIFICATION	5.172057022872026E-4	DEFECT
if dotted and not load-collection nor return-join regular property	WITHOUT_CLASSIFICATION	0.9988565883636482	WITHOUT_CLASSIFICATION	0.0011434116363517825	DEFECT
private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907 private BytecodeProvider bytecodeProvider;	WITHOUT_CLASSIFICATION	0.9994945620867278	WITHOUT_CLASSIFICATION	5.054379132721599E-4	DEFECT
public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999122402759829	WITHOUT_CLASSIFICATION	8.775972401702847E-5	DEFECT
public ComponentTuplizerFactory getComponentTuplizerFactory() { return componentTuplizerFactory; }	WITHOUT_CLASSIFICATION	0.9999861481701108	WITHOUT_CLASSIFICATION	1.3851829889278696E-5	DEFECT
package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998588704151176	WITHOUT_CLASSIFICATION	1.4112958488235388E-4	DEFECT
void setShowSqlEnabled(boolean b) { showSql = b; } void setFormatSqlEnabled(boolean b) { formatSql = b; }	WITHOUT_CLASSIFICATION	0.999921540926528	WITHOUT_CLASSIFICATION	7.845907347196216E-5	DEFECT
public BytecodeProvider getBytecodeProvider() { return bytecodeProvider; } void setBytecodeProvider(BytecodeProvider bytecodeProvider) { this.bytecodeProvider = bytecodeProvider; }	WITHOUT_CLASSIFICATION	0.999991419013012	WITHOUT_CLASSIFICATION	8.580986987951276E-6	DEFECT
using local since the inheritedMetas at this point is not the correct map since it is always the empty map	WITHOUT_CLASSIFICATION	0.997962349080189	WITHOUT_CLASSIFICATION	0.0020376509198109715	DEFECT
private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907	WITHOUT_CLASSIFICATION	0.9994945620867278	WITHOUT_CLASSIFICATION	5.054379132721599E-4	DEFECT
protected List extendsQueue;	WITHOUT_CLASSIFICATION	0.9999104039423877	WITHOUT_CLASSIFICATION	8.95960576122891E-5	DEFECT
extendsQueue = new ArrayList();	WITHOUT_CLASSIFICATION	0.9998840042319046	WITHOUT_CLASSIFICATION	1.1599576809538423E-4	DEFECT
componentTuplizerFactory = new ComponentTuplizerFactory();	WITHOUT_CLASSIFICATION	0.9998833574495114	WITHOUT_CLASSIFICATION	1.166425504886246E-4	DEFECT
if doc is null, then for whatever reason, the cached file cannot be used...	WITHOUT_CLASSIFICATION	0.9997268935806007	WITHOUT_CLASSIFICATION	2.731064193993036E-4	DEFECT
drop them in reverse order in case db needs it done that way...	WITHOUT_CLASSIFICATION	0.9999662997531336	WITHOUT_CLASSIFICATION	3.3700246866460656E-5	DEFECT
public ComponentTuplizerFactory getComponentTuplizerFactory() { return componentTuplizerFactory; }	WITHOUT_CLASSIFICATION	0.9999861481701108	WITHOUT_CLASSIFICATION	1.3851829889278696E-5	DEFECT
This method may be called many times!!	WITHOUT_CLASSIFICATION	0.9973047089178817	WITHOUT_CLASSIFICATION	0.0026952910821182764	DEFECT
Iterator iterator = extendsQueue.iterator();	WITHOUT_CLASSIFICATION	0.999832116822329	WITHOUT_CLASSIFICATION	1.678831776709151E-4	DEFECT
Iterator iter = extendsQueue.iterator();	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
found	WITHOUT_CLASSIFICATION	0.9999883079033156	WITHOUT_CLASSIFICATION	1.169209668432647E-5	DEFECT
found	WITHOUT_CLASSIFICATION	0.9999883079033156	WITHOUT_CLASSIFICATION	1.169209668432647E-5	DEFECT
settings.setComponentTuplizerFactory( this.getComponentTuplizerFactory() );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
private final List extendsQueue;	WITHOUT_CLASSIFICATION	0.9997914029791495	WITHOUT_CLASSIFICATION	2.0859702085044535E-4	DEFECT
<String, String>	WITHOUT_CLASSIFICATION	0.9998350119684544	WITHOUT_CLASSIFICATION	1.649880315457211E-4	DEFECT
<String, String>	WITHOUT_CLASSIFICATION	0.9998350119684544	WITHOUT_CLASSIFICATION	1.649880315457211E-4	DEFECT
+ "_" + referencedColumnName not used for backward compatibility	WITHOUT_CLASSIFICATION	0.999879007349514	WITHOUT_CLASSIFICATION	1.209926504859953E-4	DEFECT
Set USE_REFLECTION_OPTIMIZER to false to fix HHH-227	WITHOUT_CLASSIFICATION	0.9981866743108455	WITHOUT_CLASSIFICATION	0.0018133256891545537	DEFECT
orphan delete not supported for EntityMode.DOM4J	WITHOUT_CLASSIFICATION	0.9986018925680681	WITHOUT_CLASSIFICATION	0.001398107431931892	DEFECT
element = XMLHelper.generateDom4jElement( persister.getNodeName() );	WITHOUT_CLASSIFICATION	0.9996314204657741	WITHOUT_CLASSIFICATION	3.685795342258168E-4	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
orphan delete not supported for EntityMode.DOM4J	WITHOUT_CLASSIFICATION	0.9986018925680681	WITHOUT_CLASSIFICATION	0.001398107431931892	DEFECT
element = XMLHelper.generateDom4jElement( persister.getNodeName() );	WITHOUT_CLASSIFICATION	0.9996314204657741	WITHOUT_CLASSIFICATION	3.685795342258168E-4	DEFECT
needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999325071196441	WITHOUT_CLASSIFICATION	6.749288035590982E-5	DEFECT
maintain correct duplication if loaded in a cartesian product	WITHOUT_CLASSIFICATION	0.9997911606421621	WITHOUT_CLASSIFICATION	2.0883935783784242E-4	DEFECT
the element has been removed from the set	WITHOUT_CLASSIFICATION	0.9999262552579318	WITHOUT_CLASSIFICATION	7.374474206825474E-5	DEFECT
the element has changed	WITHOUT_CLASSIFICATION	0.9999796746595777	WITHOUT_CLASSIFICATION	2.032534042226511E-5	DEFECT
Careful: these methods do not initialize the collection.	WITHOUT_CLASSIFICATION	0.9996669624154273	WITHOUT_CLASSIFICATION	3.3303758457275305E-4	DEFECT
needed so that we remove this collection from the second-level cache	WITHOUT_CLASSIFICATION	0.9999474620909016	WITHOUT_CLASSIFICATION	5.253790909839823E-5	DEFECT
override on some subclasses	WITHOUT_CLASSIFICATION	0.9997231011710913	WITHOUT_CLASSIFICATION	2.76898828908631E-4	DEFECT
override on some subclasses	WITHOUT_CLASSIFICATION	0.9997231011710913	WITHOUT_CLASSIFICATION	2.76898828908631E-4	DEFECT
do this bit after setting initialized to true or it will recurse	WITHOUT_CLASSIFICATION	0.9996801277124492	WITHOUT_CLASSIFICATION	3.198722875508892E-4	DEFECT
short-circuit(s) no new elements, the old list contains only Orphans no old elements, so no Orphans neither	WITHOUT_CLASSIFICATION	0.9999953306802379	WITHOUT_CLASSIFICATION	4.669319761976457E-6	DEFECT
create the collection holding the Orphans	WITHOUT_CLASSIFICATION	0.999943901693468	WITHOUT_CLASSIFICATION	5.60983065319977E-5	DEFECT
collect EntityIdentifier(s) of the current elements - add them into a HashSet for fast access	WITHOUT_CLASSIFICATION	0.999604615686396	WITHOUT_CLASSIFICATION	3.9538431360394244E-4	DEFECT
iterate over the old list	WITHOUT_CLASSIFICATION	0.9999833847801912	WITHOUT_CLASSIFICATION	1.6615219808829175E-5	DEFECT
(array==null) ? tempList.size() :	WITHOUT_CLASSIFICATION	0.9997472188138499	WITHOUT_CLASSIFICATION	2.5278118615015794E-4	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
(array==null) ? tempList.get(i) :	WITHOUT_CLASSIFICATION	0.9997472188138499	WITHOUT_CLASSIFICATION	2.5278118615015794E-4	DEFECT
write(); -- doesn't	WITHOUT_CLASSIFICATION	0.9982892920740806	WITHOUT_CLASSIFICATION	0.0017107079259194818	DEFECT
write(); -- doesn't	WITHOUT_CLASSIFICATION	0.9982892920740806	WITHOUT_CLASSIFICATION	0.0017107079259194818	DEFECT
amazingly, these two will work because AbstractCollection uses iterator() to fill the array	WITHOUT_CLASSIFICATION	0.9974530756656577	WITHOUT_CLASSIFICATION	0.0025469243343424312	DEFECT
needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999325071196441	WITHOUT_CLASSIFICATION	6.749288035590982E-5	DEFECT
finally, what it's all about...	WITHOUT_CLASSIFICATION	0.9998672538285055	WITHOUT_CLASSIFICATION	1.3274617149447508E-4	DEFECT
note that if we load this collection from a cartesian product the multiplicity would be broken ... so use an idbag instead	WITHOUT_CLASSIFICATION	0.9996569460207344	WITHOUT_CLASSIFICATION	3.430539792655372E-4	DEFECT
Anyway, here we implement <set> semantics for a <one-to-many> <bag>!	WITHOUT_CLASSIFICATION	0.9992800060116104	WITHOUT_CLASSIFICATION	7.199939883897592E-4	DEFECT
a shortcut if its location didn't change!	WITHOUT_CLASSIFICATION	0.9995694907765034	WITHOUT_CLASSIFICATION	4.3050922349674084E-4	DEFECT
search for it note that this code is incorrect for other than one-to-many	WITHOUT_CLASSIFICATION	0.9976399808232779	WITHOUT_CLASSIFICATION	0.002360019176722216	DEFECT
needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999325071196441	WITHOUT_CLASSIFICATION	6.749288035590982E-5	DEFECT
a shortcut if its location didn't change!	WITHOUT_CLASSIFICATION	0.9995694907765034	WITHOUT_CLASSIFICATION	4.3050922349674084E-4	DEFECT
search for it note that this code is incorrect for other than one-to-many	WITHOUT_CLASSIFICATION	0.9976399808232779	WITHOUT_CLASSIFICATION	0.002360019176722216	DEFECT
public boolean equals(Object other) {read();return bag.equals(other);}public int hashCode(Object other) {read();return bag.hashCode();}	WITHOUT_CLASSIFICATION	0.9998083869254109	WITHOUT_CLASSIFICATION	1.9161307458913149E-4	DEFECT
List OPERATIONS:	WITHOUT_CLASSIFICATION	0.9998561494689102	WITHOUT_CLASSIFICATION	1.438505310898757E-4	DEFECT
pad with nulls from the current last element up to the new index	WITHOUT_CLASSIFICATION	0.999928004222728	WITHOUT_CLASSIFICATION	7.199577727207319E-5	DEFECT
needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999325071196441	WITHOUT_CLASSIFICATION	6.749288035590982E-5	DEFECT
needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999325071196441	WITHOUT_CLASSIFICATION	6.749288035590982E-5	DEFECT
from Map	WITHOUT_CLASSIFICATION	0.9999753751047168	WITHOUT_CLASSIFICATION	2.462489528317389E-5	DEFECT
from SortedMap	WITHOUT_CLASSIFICATION	0.9998020989543386	WITHOUT_CLASSIFICATION	1.9790104566131232E-4	DEFECT
inject the data	WITHOUT_CLASSIFICATION	0.999874082533419	WITHOUT_CLASSIFICATION	1.2591746658101432E-4	DEFECT
cannot be instantiated	WITHOUT_CLASSIFICATION	0.9998873000165274	WITHOUT_CLASSIFICATION	1.1269998347265642E-4	DEFECT
default pool size 20	WITHOUT_CLASSIFICATION	0.999981512291244	WITHOUT_CLASSIFICATION	1.8487708756093418E-5	DEFECT
trying via forName() first to be as close to DriverManager's semantics	WITHOUT_CLASSIFICATION	0.9999647847058688	WITHOUT_CLASSIFICATION	3.521529413126984E-5	DEFECT
if debug level is enabled, then log the password, otherwise mask it	WITHOUT_CLASSIFICATION	0.9997749881602284	WITHOUT_CLASSIFICATION	2.2501183977164646E-4	DEFECT
register a cleanup synch	WITHOUT_CLASSIFICATION	0.9999396455748472	WITHOUT_CLASSIFICATION	6.035442515281806E-5	DEFECT
wrap the session in the transaction-protection proxy	WITHOUT_CLASSIFICATION	0.9997937635160696	WITHOUT_CLASSIFICATION	2.0623648393033555E-4	DEFECT
then bind it	WITHOUT_CLASSIFICATION	0.9998005816471892	WITHOUT_CLASSIFICATION	1.9941835281076583E-4	DEFECT
try to make sure we don't wrap and already wrapped session	WITHOUT_CLASSIFICATION	0.9998878936407932	WITHOUT_CLASSIFICATION	1.1210635920685168E-4	DEFECT
allow these to go through the the real session no matter what	WITHOUT_CLASSIFICATION	0.9999480188880272	WITHOUT_CLASSIFICATION	5.1981111972917316E-5	DEFECT
limit the methods available if no transaction is active	WITHOUT_CLASSIFICATION	0.9999734640103998	WITHOUT_CLASSIFICATION	2.6535989600252142E-5	DEFECT
allow these (deprecated) methods to pass through	WITHOUT_CLASSIFICATION	0.9998714882625493	WITHOUT_CLASSIFICATION	1.2851173745066742E-4	DEFECT
serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999802241432499	WITHOUT_CLASSIFICATION	1.9775856750106489E-4	DEFECT
We could register the session against the transaction even though it is not started, but we'd have no guarentee of ever getting the map entries cleaned up (aside from spawning threads).	WITHOUT_CLASSIFICATION	0.999808863734189	WITHOUT_CLASSIFICATION	1.9113626581114594E-4	DEFECT
cannot be instantiated	WITHOUT_CLASSIFICATION	0.9998873000165274	WITHOUT_CLASSIFICATION	1.1269998347265642E-4	DEFECT
private String propertyName;	WITHOUT_CLASSIFICATION	0.9998701654425173	WITHOUT_CLASSIFICATION	1.2983455748272996E-4	DEFECT
public PropertyProjection project() {return Projections.property(getPropertyName());}	WITHOUT_CLASSIFICATION	0.9999119538052543	WITHOUT_CLASSIFICATION	8.804619474572469E-5	DEFECT
String[] fk = StringHelper.qualify( "collection_", cp.getKeyColumnNames() );	WITHOUT_CLASSIFICATION	0.999518784939834	WITHOUT_CLASSIFICATION	4.812150601658536E-4	DEFECT
" collection_ where " +	WITHOUT_CLASSIFICATION	0.9999423335553551	WITHOUT_CLASSIFICATION	5.766644464482602E-5	DEFECT
unsupported	WITHOUT_CLASSIFICATION	0.9998360272346589	WITHOUT_CLASSIFICATION	1.639727653410962E-4	DEFECT
unsupported	WITHOUT_CLASSIFICATION	0.9998360272346589	WITHOUT_CLASSIFICATION	1.639727653410962E-4	DEFECT
cannot be instantiated	WITHOUT_CLASSIFICATION	0.9998873000165274	WITHOUT_CLASSIFICATION	1.1269998347265642E-4	DEFECT
the following two lines were added to ensure that this.params is not null, which can happen with two-deep nested subqueries	WITHOUT_CLASSIFICATION	0.9743471174160695	WITHOUT_CLASSIFICATION	0.025652882583930458	DEFECT
with two-deep subqueries, the same alias would get generated for both using the old method (criteriaQuery.generateSQLAlias()), so that is now used as a fallback if the main criteria alias isn't set	WITHOUT_CLASSIFICATION	0.9999963389890415	WITHOUT_CLASSIFICATION	3.6610109585225544E-6	DEFECT
implicit polymorphism not supported (would need a union)	WITHOUT_CLASSIFICATION	0.9964940547445849	WITHOUT_CLASSIFICATION	0.003505945255415159	DEFECT
pull off the last ", "	WITHOUT_CLASSIFICATION	0.9999493967643391	WITHOUT_CLASSIFICATION	5.06032356608431E-5	DEFECT
$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
we have the form: trim(trimSource) so we trim leading and trailing spaces	WITHOUT_CLASSIFICATION	0.9999618621103937	WITHOUT_CLASSIFICATION	3.8137889606342914E-5	DEFECT
we have the form: trim(from trimSource). This is functionally equivalent to trim(trimSource)	WITHOUT_CLASSIFICATION	0.9980626143067779	WITHOUT_CLASSIFICATION	0.0019373856932220655	DEFECT
NOT_SUPPORTED_SHOULD_USE_JDBC3_PreparedStatement.getGeneratedKeys_method	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
potentialTrimCharacterArgIndex = 1 assumes that a trim-specification has been specified. we handle the exception to that explicitly	WITHOUT_CLASSIFICATION	0.9999903042499376	WITHOUT_CLASSIFICATION	9.695750062308844E-6	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
Oracle did add support for ANSI CASE statements in 9i	WITHOUT_CLASSIFICATION	0.9999622443201583	WITHOUT_CLASSIFICATION	3.7755679841671714E-5	DEFECT
the standard SQL function name is current_timestamp...	WITHOUT_CLASSIFICATION	0.9999056748813681	WITHOUT_CLASSIFICATION	9.432511863195951E-5	DEFECT
Informix doesn't have a bit type	WITHOUT_CLASSIFICATION	0.9979254038470914	WITHOUT_CLASSIFICATION	0.0020745961529085657	DEFECT
or BYTE or TEXT? or MONEY	WITHOUT_CLASSIFICATION	0.9999006131668068	WITHOUT_CLASSIFICATION	9.938683319318598E-5	DEFECT
strip table-owner because Informix always returns constraint names as "<table-owner>.<constraint-name>"	WITHOUT_CLASSIFICATION	0.9999790487217073	WITHOUT_CLASSIFICATION	2.0951278292689775E-5	DEFECT
build the map of standard ANSI SQL aggregation functions ~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999171555012639	WITHOUT_CLASSIFICATION	8.28444987360313E-5	DEFECT
pre H3.2 behavior: super.getReturnType(ct, m);	WITHOUT_CLASSIFICATION	0.9994764044300112	WITHOUT_CLASSIFICATION	5.235955699888157E-4	DEFECT
finally use the sqltype if == on Hibernate types did not find a match.	WITHOUT_CLASSIFICATION	0.9995301167879153	WITHOUT_CLASSIFICATION	4.6988321208475643E-4	DEFECT
because numeric can be anything	WITHOUT_CLASSIFICATION	0.9998404729497763	WITHOUT_CLASSIFICATION	1.5952705022365346E-4	DEFECT
constructors and factory methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999181809156433	WITHOUT_CLASSIFICATION	8.181908435667144E-5	DEFECT
standard sql92 functions (can be overridden by subclasses)	WITHOUT_CLASSIFICATION	0.9998411511278563	WITHOUT_CLASSIFICATION	1.5884887214361198E-4	DEFECT
map second/minute/hour/day/month/year to ANSI extract(), override on subclasses	WITHOUT_CLASSIFICATION	0.9992672796827552	WITHOUT_CLASSIFICATION	7.327203172448353E-4	DEFECT
register hibernate types for default use in scalar sqlquery type auto detection	WITHOUT_CLASSIFICATION	0.999980372713302	WITHOUT_CLASSIFICATION	1.9627286698062423E-5	DEFECT
database type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998265173977983	WITHOUT_CLASSIFICATION	1.7348260220171872E-4	DEFECT
hibernate type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998577729207125	WITHOUT_CLASSIFICATION	1.4222707928748132E-4	DEFECT
keyword support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998766382592327	WITHOUT_CLASSIFICATION	1.233617407673967E-4	DEFECT
native identifier generatiion ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998580644642466	WITHOUT_CLASSIFICATION	1.4193553575346055E-4	DEFECT
IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998717123878218	WITHOUT_CLASSIFICATION	1.282876121782502E-4	DEFECT
GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
by default we report no support	WITHOUT_CLASSIFICATION	0.9999964692129218	WITHOUT_CLASSIFICATION	3.530787078231896E-6	DEFECT
by default we report no support for NOWAIT lock semantics	WITHOUT_CLASSIFICATION	0.9999963588264825	WITHOUT_CLASSIFICATION	3.6411735173842115E-6	DEFECT
table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999583270504487	WITHOUT_CLASSIFICATION	4.1672949551186436E-5	DEFECT
temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999730611302303	WITHOUT_CLASSIFICATION	2.6938869769713048E-5	DEFECT
callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998501716188779	WITHOUT_CLASSIFICATION	1.4982838112219144E-4	DEFECT
current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999528740852359	WITHOUT_CLASSIFICATION	4.7125914764149026E-5	DEFECT
SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998618932428833	WITHOUT_CLASSIFICATION	1.3810675711676133E-4	DEFECT
miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
identifier quoting support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999814799512861	WITHOUT_CLASSIFICATION	1.8520048713892252E-4	DEFECT
DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
grrr... for differentiation of mysql storage engines	WITHOUT_CLASSIFICATION	0.9998476462218183	WITHOUT_CLASSIFICATION	1.523537781816125E-4	DEFECT
Informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997882591986118	WITHOUT_CLASSIFICATION	2.117408013881181E-4	DEFECT
return false here, as most databases do not properly support this construct...	WITHOUT_CLASSIFICATION	0.9996924107691192	WITHOUT_CLASSIFICATION	3.075892308808519E-4	DEFECT
Mckoi has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999294488827509	WITHOUT_CLASSIFICATION	7.05511172491157E-5	DEFECT
Oracle8 and previous define only a "DATE" type which is used to represent all aspects of date/time	WITHOUT_CLASSIFICATION	0.9999921826697268	WITHOUT_CLASSIFICATION	7.817330273183387E-6	DEFECT
starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999323188485616	WITHOUT_CLASSIFICATION	6.768115143841437E-5	DEFECT
" cascade";	WITHOUT_CLASSIFICATION	0.9998203183291662	WITHOUT_CLASSIFICATION	1.796816708338746E-4	DEFECT
trim off the length/precision/scale	WITHOUT_CLASSIFICATION	0.9998773144381583	WITHOUT_CLASSIFICATION	1.22685561841658E-4	DEFECT
public boolean dropTemporaryTableAfterUse() {we have to, because postgres sets current txto rollback only after a failed create tablereturn true;}	WITHOUT_CLASSIFICATION	0.99999243277066	WITHOUT_CLASSIFICATION	7.567229340073422E-6	DEFECT
CHECK VIOLATION	WITHOUT_CLASSIFICATION	0.9998369714550851	WITHOUT_CLASSIFICATION	1.6302854491485118E-4	DEFECT
UNIQUE VIOLATION	WITHOUT_CLASSIFICATION	0.9998409078505273	WITHOUT_CLASSIFICATION	1.590921494726397E-4	DEFECT
FOREIGN KEY VIOLATION	WITHOUT_CLASSIFICATION	0.9999139340516651	WITHOUT_CLASSIFICATION	8.606594833498371E-5	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
NOT NULL VIOLATION	WITHOUT_CLASSIFICATION	0.9998819020612166	WITHOUT_CLASSIFICATION	1.1809793878336541E-4	DEFECT
ALL OTHER	WITHOUT_CLASSIFICATION	0.999976773120681	WITHOUT_CLASSIFICATION	2.32268793190506E-5	DEFECT
Register the type of the out param - PostgreSQL uses Types.OTHER	WITHOUT_CLASSIFICATION	0.9998616874846337	WITHOUT_CLASSIFICATION	1.3831251536635867E-4	DEFECT
seems to not really... public boolean supportsRowValueConstructorSyntax() { return true; }	WITHOUT_CLASSIFICATION	0.999878096763777	WITHOUT_CLASSIFICATION	1.2190323622301957E-4	DEFECT
seems to have spotty LOB suppport	WITHOUT_CLASSIFICATION	0.9990123864362532	WITHOUT_CLASSIFICATION	9.8761356374682E-4	DEFECT
HHH-2300	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
ignore (probably H2 not in the classpath)	WITHOUT_CLASSIFICATION	0.9992928098552809	WITHOUT_CLASSIFICATION	7.071901447191854E-4	DEFECT
Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998354656016037	WITHOUT_CLASSIFICATION	1.645343983963304E-4	DEFECT
Time and Date Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998541805477549	WITHOUT_CLASSIFICATION	1.4581945224519875E-4	DEFECT
System Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997996557267304	WITHOUT_CLASSIFICATION	2.003442732697026E-4	DEFECT
not null is implicit	WITHOUT_CLASSIFICATION	0.9965268161982699	WITHOUT_CLASSIFICATION	0.0034731838017302437	DEFECT
23000: Check constraint violation: {0} 23001: Unique index or primary key violation: {0}	WITHOUT_CLASSIFICATION	0.9999692786181797	WITHOUT_CLASSIFICATION	3.072138182030503E-5	DEFECT
Display the dialect version.	WITHOUT_CLASSIFICATION	0.9999717998149761	WITHOUT_CLASSIFICATION	2.8200185024004403E-5	DEFECT
The RDMS concat() function only supports 2 parameters	WITHOUT_CLASSIFICATION	0.9929987031707733	WITHOUT_CLASSIFICATION	0.007001296829226684	DEFECT
Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999381049826803	WITHOUT_CLASSIFICATION	6.189501731962134E-5	DEFECT
Original Dialect.java returns " for update";	WITHOUT_CLASSIFICATION	0.9997268086589326	WITHOUT_CLASSIFICATION	2.731913410673729E-4	DEFECT
Verify the state of this new method in Hibernate 3.0 Dialect.java	WITHOUT_CLASSIFICATION	0.9999538401489778	WITHOUT_CLASSIFICATION	4.615985102214011E-5	DEFECT
Origial Dialect.java returns true;	WITHOUT_CLASSIFICATION	0.9998212740925473	WITHOUT_CLASSIFICATION	1.7872590745268946E-4	DEFECT
The keyword used to specify a nullable column.	WITHOUT_CLASSIFICATION	0.9999585549963941	WITHOUT_CLASSIFICATION	4.144500360595893E-5	DEFECT
Sequence methods - start. The RDMS dialect needs these	WITHOUT_CLASSIFICATION	0.9985746053395171	WITHOUT_CLASSIFICATION	0.0014253946604828348	DEFECT
methods to make it possible to use the Native Id generator	WITHOUT_CLASSIFICATION	0.9992650242597099	WITHOUT_CLASSIFICATION	7.349757402901223E-4	DEFECT
The where clause was added to eliminate this statement from Brute Force Searches.	WITHOUT_CLASSIFICATION	0.9997549830401813	WITHOUT_CLASSIFICATION	2.450169598186884E-4	DEFECT
Sequence methods - end	WITHOUT_CLASSIFICATION	0.9997309312450173	WITHOUT_CLASSIFICATION	2.690687549826882E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999323188485616	WITHOUT_CLASSIFICATION	6.768115143841437E-5	DEFECT
We must return a valid RDMS/RSA command from this method to prevent RDMS/RSA from issuing ERROR 400	WITHOUT_CLASSIFICATION	0.9999234032210984	WITHOUT_CLASSIFICATION	7.659677890149102E-5	DEFECT
Used with DROP TABLE to delete all records in the table.	WITHOUT_CLASSIFICATION	0.9999560028081848	WITHOUT_CLASSIFICATION	4.3997191815198395E-5	DEFECT
RDMS supports the UNION ALL clause.	WITHOUT_CLASSIFICATION	0.9998890589225493	WITHOUT_CLASSIFICATION	1.1094107745068434E-4	DEFECT
RDMS has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999294488827509	WITHOUT_CLASSIFICATION	7.05511172491157E-5	DEFECT
Multi-param dialect functions...	WITHOUT_CLASSIFICATION	0.9998069593672305	WITHOUT_CLASSIFICATION	1.930406327693594E-4	DEFECT
function templates	WITHOUT_CLASSIFICATION	0.9997999923762046	WITHOUT_CLASSIFICATION	2.0000762379543055E-4	DEFECT
not null is implicit	WITHOUT_CLASSIFICATION	0.9965268161982699	WITHOUT_CLASSIFICATION	0.0034731838017302437	DEFECT
this assumes schema support, which is present in 1.8.0 and later...	WITHOUT_CLASSIFICATION	0.9995736548107715	WITHOUT_CLASSIFICATION	4.2634518922845524E-4	DEFECT
HSQLDB only supports READ_UNCOMMITTED transaction isolation	WITHOUT_CLASSIFICATION	0.9995137445540303	WITHOUT_CLASSIFICATION	4.8625544596973944E-4	DEFECT
Multi-param string dialect functions...	WITHOUT_CLASSIFICATION	0.9997961232022958	WITHOUT_CLASSIFICATION	2.038767977042745E-4	DEFECT
Multi-param numeric dialect functions...	WITHOUT_CLASSIFICATION	0.9998290005335221	WITHOUT_CLASSIFICATION	1.7099946647799641E-4	DEFECT
Multi-param date dialect functions...	WITHOUT_CLASSIFICATION	0.9995980435351824	WITHOUT_CLASSIFICATION	4.019564648174995E-4	DEFECT
simple nullability constraint	WITHOUT_CLASSIFICATION	0.9999506764597719	WITHOUT_CLASSIFICATION	4.932354022815356E-5	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
not final-static to avoid possible classcast exceptions if using different oracle drivers.	WITHOUT_CLASSIFICATION	0.9992911871832778	WITHOUT_CLASSIFICATION	7.088128167222112E-4	DEFECT
register the type of the out param - an Oracle specific type	WITHOUT_CLASSIFICATION	0.9999863682254955	WITHOUT_CLASSIFICATION	1.3631774504441288E-5	DEFECT
TimesTen has no BLOB/CLOB support, but these types may be suitable for some applications. The length is limited to 4 million bytes.	WITHOUT_CLASSIFICATION	0.9996843589654645	WITHOUT_CLASSIFICATION	3.156410345355577E-4	DEFECT
new methods in dialect3	WITHOUT_CLASSIFICATION	0.9999333118809031	WITHOUT_CLASSIFICATION	6.668811909701657E-5	DEFECT
public boolean supportsForUpdateNowait() {return false;}	WITHOUT_CLASSIFICATION	0.9999410847111937	WITHOUT_CLASSIFICATION	5.891528880624082E-5	DEFECT
TimesTen has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.999929572131579	WITHOUT_CLASSIFICATION	7.042786842102309E-5	DEFECT
iterate entries ordered by capacity to find first fit	WITHOUT_CLASSIFICATION	0.9998538526790616	WITHOUT_CLASSIFICATION	1.4614732093837517E-4	DEFECT
add new ordered map	WITHOUT_CLASSIFICATION	0.999176395714982	WITHOUT_CLASSIFICATION	8.236042850181389E-4	DEFECT
registerColumnType( Types.VARCHAR, 16777215, "mediumtext" );	WITHOUT_CLASSIFICATION	0.999340426485532	WITHOUT_CLASSIFICATION	6.595735144679095E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
This assumes you will want to ignore any update counts	WITHOUT_CLASSIFICATION	0.9995865983832267	WITHOUT_CLASSIFICATION	4.134016167733233E-4	DEFECT
sql server just returns automatically	WITHOUT_CLASSIFICATION	0.9999557554607874	WITHOUT_CLASSIFICATION	4.424453921252226E-5	DEFECT
return "select CURRENT_TIMESTAMP from RDB$DATABASE";	WITHOUT_CLASSIFICATION	0.9999335207964893	WITHOUT_CLASSIFICATION	6.64792035106549E-5	DEFECT
registerColumnType data types	WITHOUT_CLASSIFICATION	0.9998899354893739	WITHOUT_CLASSIFICATION	1.1006451062608674E-4	DEFECT
hibernate seems to ignore this type...	WITHOUT_CLASSIFICATION	0.9993782408744099	WITHOUT_CLASSIFICATION	6.21759125590119E-4	DEFECT
IBID for current_time and current_date	WITHOUT_CLASSIFICATION	0.9998585974794251	WITHOUT_CLASSIFICATION	1.4140252057494432E-4	DEFECT
Tell hibernate to use getBytes instead of getBinaryStream	WITHOUT_CLASSIFICATION	0.9998785516241936	WITHOUT_CLASSIFICATION	1.2144837580651464E-4	DEFECT
No batch statements	WITHOUT_CLASSIFICATION	0.9999119852024634	WITHOUT_CLASSIFICATION	8.801479753651239E-5	DEFECT
We might want a special case for 19,2. This is very common for money types and here it is converted to 18,1	WITHOUT_CLASSIFICATION	0.6689780989164781	WITHOUT_CLASSIFICATION	0.33102190108352186	DEFECT
no pointbase BIT	WITHOUT_CLASSIFICATION	0.9999651471530153	WITHOUT_CLASSIFICATION	3.48528469846926E-5	DEFECT
no pointbase TINYINT	WITHOUT_CLASSIFICATION	0.9999650662127402	WITHOUT_CLASSIFICATION	3.4933787259853884E-5	DEFECT
Pointbase has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999294488827509	WITHOUT_CLASSIFICATION	7.05511172491157E-5	DEFECT
starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999323188485616	WITHOUT_CLASSIFICATION	6.768115143841437E-5	DEFECT
The current_timestamp is more accurate, but only known to be supported in SQL Server 7.0 and later (i.e., Sybase not known to support it at all)	WITHOUT_CLASSIFICATION	0.9949019093857074	WITHOUT_CLASSIFICATION	0.005098090614292451	DEFECT
SQL Server (at least up through 2005) does not support defining cascade delete constraints which can circel back to the mutating table	WITHOUT_CLASSIFICATION	0.9999893670929322	WITHOUT_CLASSIFICATION	1.0632907067809353E-5	DEFECT
here assume SQLServer2005 using snapshot isolation, which does not have this problem	WITHOUT_CLASSIFICATION	0.9578217699941992	WITHOUT_CLASSIFICATION	0.042178230005800836	DEFECT
registerColumnType( Types.BLOB, 16777215, "mediumblob" ); registerColumnType( Types.BLOB, 65535, "blob" );	WITHOUT_CLASSIFICATION	0.9993383615774538	WITHOUT_CLASSIFICATION	6.616384225461494E-4	DEFECT
registerColumnType( Types.CLOB, 16777215, "mediumtext" ); registerColumnType( Types.CLOB, 65535, "text" );	WITHOUT_CLASSIFICATION	0.9993526786799681	WITHOUT_CLASSIFICATION	6.473213200319001E-4	DEFECT
registerColumnType( Types.VARCHAR, 16777215, "mediumtext" ); registerColumnType( Types.VARCHAR, 65535, "text" );	WITHOUT_CLASSIFICATION	0.9993550510031411	WITHOUT_CLASSIFICATION	6.449489968589318E-4	DEFECT
starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999323188485616	WITHOUT_CLASSIFICATION	6.768115143841437E-5	DEFECT
package-private	WITHOUT_CLASSIFICATION	0.999837723747907	WITHOUT_CLASSIFICATION	1.6227625209293815E-4	DEFECT
sql server just returns automatically	WITHOUT_CLASSIFICATION	0.9999557554607874	WITHOUT_CLASSIFICATION	4.424453921252226E-5	DEFECT
Sybase BIT type does not support null values	WITHOUT_CLASSIFICATION	0.9983796761756326	WITHOUT_CLASSIFICATION	0.0016203238243674934	DEFECT
This assumes you will want to ignore any update counts	WITHOUT_CLASSIFICATION	0.9995865983832267	WITHOUT_CLASSIFICATION	4.134016167733233E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
You may still have other ResultSets or update counts left to process here but you can't do it now or the ResultSet you just got will be closed	WITHOUT_CLASSIFICATION	0.9980665341021299	WITHOUT_CLASSIFICATION	0.0019334658978702002	DEFECT
not null ... (start with 1) is implicit	WITHOUT_CLASSIFICATION	0.9931539199392245	WITHOUT_CLASSIFICATION	0.006846080060775409	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
Oracle driver reports to support getGeneratedKeys(), but they only support the version taking an array of the names of the columns to be returned (via its RETURNING clause). No other driver seems to support this overloaded version.	WITHOUT_CLASSIFICATION	0.9999862810725024	WITHOUT_CLASSIFICATION	1.3718927497438153E-5	DEFECT
Multi-param string dialect functions...	WITHOUT_CLASSIFICATION	0.9997961232022958	WITHOUT_CLASSIFICATION	2.038767977042745E-4	DEFECT
Multi-param numeric dialect functions...	WITHOUT_CLASSIFICATION	0.9998290005335221	WITHOUT_CLASSIFICATION	1.7099946647799641E-4	DEFECT
Multi-param date dialect functions...	WITHOUT_CLASSIFICATION	0.9995980435351824	WITHOUT_CLASSIFICATION	4.019564648174995E-4	DEFECT
add another (inner) nested select add the main query close off the inner nested select	WITHOUT_CLASSIFICATION	0.9999198721099575	WITHOUT_CLASSIFICATION	8.012789004255835E-5	DEFECT
add the main query	WITHOUT_CLASSIFICATION	0.99961975675786	WITHOUT_CLASSIFICATION	3.802432421400228E-4	DEFECT
add the restriction to the outer select	WITHOUT_CLASSIFICATION	0.9997607008005371	WITHOUT_CLASSIFICATION	2.3929919946278768E-4	DEFECT
This assumes you will want to ignore any update counts	WITHOUT_CLASSIFICATION	0.9995865983832267	WITHOUT_CLASSIFICATION	4.134016167733233E-4	DEFECT
You may still have other ResultSets or update counts left to process here but you can't do it now or the ResultSet you just got will be closed	WITHOUT_CLASSIFICATION	0.9980665341021299	WITHOUT_CLASSIFICATION	0.0019334658978702002	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999323188485616	WITHOUT_CLASSIFICATION	6.768115143841437E-5	DEFECT
simple nullability constraint	WITHOUT_CLASSIFICATION	0.9999506764597719	WITHOUT_CLASSIFICATION	4.932354022815356E-5	DEFECT
not final-static to avoid possible classcast exceptions if using different oracle drivers.	WITHOUT_CLASSIFICATION	0.9992911871832778	WITHOUT_CLASSIFICATION	7.088128167222112E-4	DEFECT
register the type of the out param - an Oracle specific type	WITHOUT_CLASSIFICATION	0.9999863682254955	WITHOUT_CLASSIFICATION	1.3631774504441288E-5	DEFECT
features which change between 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999892993524035	WITHOUT_CLASSIFICATION	1.0700647596394694E-5	DEFECT
features which remain constant across 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999251236940506	WITHOUT_CLASSIFICATION	7.487630594942304E-5	DEFECT
binary %Stream character %Stream	WITHOUT_CLASSIFICATION	0.9998987560817331	WITHOUT_CLASSIFICATION	1.012439182670439E-4	DEFECT
getDefaultProperties().setProperty(Environment.STATEMENT_BATCH_SIZE, NO_BATCH);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
hibernate impelemnts cast in Dialect.java	WITHOUT_CLASSIFICATION	0.9997982302678279	WITHOUT_CLASSIFICATION	2.0176973217204605E-4	DEFECT
aggregate functions shouldn't be registered, right? registerFunction( "list", new StandardSQLFunction("list",Hibernate.STRING) ); stopped on $list	WITHOUT_CLASSIFICATION	0.9953618884100875	WITHOUT_CLASSIFICATION	0.004638111589912434	DEFECT
DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
below is for Cache' that don't have str in 2007.1 there is str and we register str directly	WITHOUT_CLASSIFICATION	0.9990014159840572	WITHOUT_CLASSIFICATION	9.985840159427723E-4	DEFECT
note that %string is deprecated	WITHOUT_CLASSIFICATION	0.9998114351709719	WITHOUT_CLASSIFICATION	1.8856482902800687E-4	DEFECT
%upper is deprecated	WITHOUT_CLASSIFICATION	0.9998220803104163	WITHOUT_CLASSIFICATION	1.7791968958360478E-4	DEFECT
The syntax used to add a foreign key constraint to a table.	WITHOUT_CLASSIFICATION	0.99995267172759	WITHOUT_CLASSIFICATION	4.732827241000826E-5	DEFECT
identifier-commalist	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998717123878218	WITHOUT_CLASSIFICATION	1.282876121782502E-4	DEFECT
temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999730611302303	WITHOUT_CLASSIFICATION	2.6938869769713048E-5	DEFECT
identifier-commalist	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
The syntax used to add a column to a table	WITHOUT_CLASSIFICATION	0.9999792923375275	WITHOUT_CLASSIFICATION	2.0707662472552225E-5	DEFECT
Completely optional cascading drop clause.	WITHOUT_CLASSIFICATION	0.9998987990189544	WITHOUT_CLASSIFICATION	1.0120098104558816E-4	DEFECT
lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.99992070843057	WITHOUT_CLASSIFICATION	7.929156942998533E-5	DEFECT
LIMIT support (ala TOP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
InterSystems Cache' does not current support "SELECT ... FOR UPDATE" syntax... Set your transaction mode to READ_COMMITTED before using	WITHOUT_CLASSIFICATION	0.9873902235963925	WITHOUT_CLASSIFICATION	0.01260977640360744	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
<String>	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998501716188779	WITHOUT_CLASSIFICATION	1.4982838112219144E-4	DEFECT
miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998608224410519	WITHOUT_CLASSIFICATION	1.391775589480967E-4	DEFECT
The keyword used to specify a nullable column.	WITHOUT_CLASSIFICATION	0.9999585549963941	WITHOUT_CLASSIFICATION	4.144500360595893E-5	DEFECT
Does the LIMIT clause come at the start of the SELECT statement, rather than at the end?	WITHOUT_CLASSIFICATION	0.9992209204755145	WITHOUT_CLASSIFICATION	7.790795244854194E-4	DEFECT
Does the LIMIT clause take a "maximum" row number instead of a total number of returned rows?	WITHOUT_CLASSIFICATION	0.9998806891982446	WITHOUT_CLASSIFICATION	1.1931080175552343E-4	DEFECT
The name of the SQL function that transforms a string to lowercase	WITHOUT_CLASSIFICATION	0.9998401341081311	WITHOUT_CLASSIFICATION	1.598658918689968E-4	DEFECT
Create an OuterJoinGenerator for this dialect.	WITHOUT_CLASSIFICATION	0.999912767780523	WITHOUT_CLASSIFICATION	8.72322194770927E-5	DEFECT
The keyword used to insert a row without specifying any column values	WITHOUT_CLASSIFICATION	0.9999839792504993	WITHOUT_CLASSIFICATION	1.602074950073063E-5	DEFECT
registerFunction( "trim", new StandardSQLFunction( "trim", Hibernate.STRING ) );	WITHOUT_CLASSIFICATION	0.9995836384129115	WITHOUT_CLASSIFICATION	4.1636158708837793E-4	DEFECT
skip the FROM keyword in params	WITHOUT_CLASSIFICATION	0.9999009897579401	WITHOUT_CLASSIFICATION	9.901024206003508E-5	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
potentialTrimCharacterArgIndex = 1 assumes that a trim-specification has been specified. we handle the exception to that explicitly	WITHOUT_CLASSIFICATION	0.9999903042499376	WITHOUT_CLASSIFICATION	9.695750062308844E-6	DEFECT
SQLFunction implementation	WITHOUT_CLASSIFICATION	0.9998129707620992	WITHOUT_CLASSIFICATION	1.870292379009333E-4	DEFECT
conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrap	WITHOUT_CLASSIFICATION	0.9998449728204029	WITHOUT_CLASSIFICATION	1.5502717959720293E-4	DEFECT
register the standard dialect resolver	WITHOUT_CLASSIFICATION	0.9999308527200456	WITHOUT_CLASSIFICATION	6.914727995441358E-5	DEFECT
register resolvers set via Environment property	WITHOUT_CLASSIFICATION	0.9999131605105881	WITHOUT_CLASSIFICATION	8.683948941189331E-5	DEFECT
kept for backward compatibility until after the 3.1beta5 release of HA	WITHOUT_CLASSIFICATION	0.9999273407857965	WITHOUT_CLASSIFICATION	7.265921420352403E-5	DEFECT
cache the hashcode	WITHOUT_CLASSIFICATION	0.9999330341095184	WITHOUT_CLASSIFICATION	6.69658904816836E-5	DEFECT
the CascadingAction contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998662062177918	WITHOUT_CLASSIFICATION	1.3379378220835383E-4	DEFECT
the CascadingAction implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998167002974958	WITHOUT_CLASSIFICATION	1.8329970250427193E-4	DEFECT
delete does cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9994793761026678	WITHOUT_CLASSIFICATION	5.206238973322142E-4	DEFECT
orphans should be deleted during delete	WITHOUT_CLASSIFICATION	0.9992813874376704	WITHOUT_CLASSIFICATION	7.186125623296595E-4	DEFECT
(LockMode) anything	WITHOUT_CLASSIFICATION	0.9991682847784364	WITHOUT_CLASSIFICATION	8.317152215634916E-4	DEFECT
lock doesn't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9990121743459688	WITHOUT_CLASSIFICATION	9.878256540311909E-4	DEFECT
refresh doesn't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.995624947444383	WITHOUT_CLASSIFICATION	0.004375052555617067	DEFECT
evicts don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9984290383969633	WITHOUT_CLASSIFICATION	0.0015709616030366656	DEFECT
saves / updates don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9990248576812646	WITHOUT_CLASSIFICATION	9.751423187353738E-4	DEFECT
orphans should be deleted during save/update	WITHOUT_CLASSIFICATION	0.9989671102531965	WITHOUT_CLASSIFICATION	0.001032889746803427	DEFECT
for deprecated saveOrUpdateCopy()	WITHOUT_CLASSIFICATION	0.9998485432107556	WITHOUT_CLASSIFICATION	1.5145678924441926E-4	DEFECT
persists don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9984290383969633	WITHOUT_CLASSIFICATION	0.0015709616030366656	DEFECT
a proxy cannot be transient and it breaks ForeignKeys.isTransient	WITHOUT_CLASSIFICATION	0.999635651766703	WITHOUT_CLASSIFICATION	3.6434823329702185E-4	DEFECT
replicate does cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9992516222040561	WITHOUT_CLASSIFICATION	7.483777959439143E-4	DEFECT
static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999011947623953	WITHOUT_CLASSIFICATION	9.880523760481443E-5	DEFECT
handles arrays and newly instantiated collections	WITHOUT_CLASSIFICATION	0.9998870101032189	WITHOUT_CLASSIFICATION	1.1298989678119477E-4	DEFECT
Actually the semantics of the next three are really "Bag" Note that, unlike objects, collection insertions, updates, deletions are not really remembered between flushes. We just re-use the same Lists for convenience.	WITHOUT_CLASSIFICATION	0.9975082859478919	WITHOUT_CLASSIFICATION	0.0024917140521081697	DEFECT
Add these directly to the executions queue	WITHOUT_CLASSIFICATION	0.9999593377718211	WITHOUT_CLASSIFICATION	4.066222817888574E-5	DEFECT
continue loop	WITHOUT_CLASSIFICATION	0.9998456744893377	WITHOUT_CLASSIFICATION	1.5432551066232823E-4	DEFECT
sort the updates by fk	WITHOUT_CLASSIFICATION	0.9999449376085748	WITHOUT_CLASSIFICATION	5.506239142518004E-5	DEFECT
sort the updates by pk	WITHOUT_CLASSIFICATION	0.9999449376085748	WITHOUT_CLASSIFICATION	5.506239142518004E-5	DEFECT
the mapping of entity names to their latest batch numbers.	WITHOUT_CLASSIFICATION	0.9999636237839079	WITHOUT_CLASSIFICATION	3.6376216092052006E-5	DEFECT
the map of batch numbers to EntityInsertAction lists	WITHOUT_CLASSIFICATION	0.9997801867586381	WITHOUT_CLASSIFICATION	2.1981324136178016E-4	DEFECT
optimize the hash size to eliminate a rehash.	WITHOUT_CLASSIFICATION	0.9998705998957075	WITHOUT_CLASSIFICATION	1.2940010429254696E-4	DEFECT
the list of entity names that indicate the batch number	WITHOUT_CLASSIFICATION	0.9999357609035875	WITHOUT_CLASSIFICATION	6.423909641244051E-5	DEFECT
remove the current element from insertions. It will be added back later.	WITHOUT_CLASSIFICATION	0.9961547310113446	WITHOUT_CLASSIFICATION	0.003845268988655401	DEFECT
the entity associated with the current action.	WITHOUT_CLASSIFICATION	0.9999551405157817	WITHOUT_CLASSIFICATION	4.485948421827729E-5	DEFECT
There is already an existing batch for this type of entity. Check to see if the latest batch is acceptable.	WITHOUT_CLASSIFICATION	0.9999897741866658	WITHOUT_CLASSIFICATION	1.0225813334252694E-5	DEFECT
now rebuild the insertions list. There is a batch for each entry in the name list.	WITHOUT_CLASSIFICATION	0.9999741008448665	WITHOUT_CLASSIFICATION	2.5899155133544933E-5	DEFECT
the current batch number is the latest batch for this entity type.	WITHOUT_CLASSIFICATION	0.9998804790556449	WITHOUT_CLASSIFICATION	1.1952094435518759E-4	DEFECT
loop through all the associations of the current entity and make sure that they are processed before the current batch number	WITHOUT_CLASSIFICATION	0.9999985728529849	WITHOUT_CLASSIFICATION	1.4271470151361714E-6	DEFECT
find the batch number associated with the current association, if any.	WITHOUT_CLASSIFICATION	0.9999754758404837	WITHOUT_CLASSIFICATION	2.4524159516251314E-5	DEFECT
create a new batch for this type. The batch number is the number of current batches.	WITHOUT_CLASSIFICATION	0.9999375830178724	WITHOUT_CLASSIFICATION	6.241698212760755E-5	DEFECT
loop through all the associated entities and make sure they have been processed before the latest batch associated with this entity type.	WITHOUT_CLASSIFICATION	0.9999924365692785	WITHOUT_CLASSIFICATION	7.5634307215002935E-6	DEFECT
since this entity will now be processed in the latest possible batch, we can be assured that it will come after all other associations, there's not need to continue checking.	WITHOUT_CLASSIFICATION	0.9992248386583811	WITHOUT_CLASSIFICATION	7.751613416188524E-4	DEFECT
cascade to current collection elements	WITHOUT_CLASSIFICATION	0.999952743702758	WITHOUT_CLASSIFICATION	4.7256297242105905E-5	DEFECT
not really necessary, but good for consistency...	WITHOUT_CLASSIFICATION	0.9984074758246868	WITHOUT_CLASSIFICATION	0.0015925241753131654	DEFECT
we can't cascade to non-embedded elements	WITHOUT_CLASSIFICATION	0.9994897266499143	WITHOUT_CLASSIFICATION	5.102733500857054E-4	DEFECT
a newly instantiated collection can't have orphans	WITHOUT_CLASSIFICATION	0.9989877240411039	WITHOUT_CLASSIFICATION	0.0010122759588961174	DEFECT
handle orphaned entities!!	WITHOUT_CLASSIFICATION	0.9999710787239104	WITHOUT_CLASSIFICATION	2.892127608955458E-5	DEFECT
Loaded entity instances, by EntityUniqueKey	WITHOUT_CLASSIFICATION	0.9997920806914151	WITHOUT_CLASSIFICATION	2.0791930858495055E-4	DEFECT
Identity map of EntityEntry instances, by the entity instance	WITHOUT_CLASSIFICATION	0.9998745222274166	WITHOUT_CLASSIFICATION	1.2547777258339735E-4	DEFECT
Entity proxies, by EntityKey	WITHOUT_CLASSIFICATION	0.9998998171430199	WITHOUT_CLASSIFICATION	1.0018285698014902E-4	DEFECT
Snapshots of current database state for entities that have not been loaded	WITHOUT_CLASSIFICATION	0.9999492819725534	WITHOUT_CLASSIFICATION	5.071802744664312E-5	DEFECT
Identity map of array holder ArrayHolder instances, by the array instance	WITHOUT_CLASSIFICATION	0.9999162312280176	WITHOUT_CLASSIFICATION	8.376877198229372E-5	DEFECT
Collection wrappers, by the CollectionKey key=CollectionKey, value=PersistentCollection	WITHOUT_CLASSIFICATION	0.9998628967681782	WITHOUT_CLASSIFICATION	1.3710323182185305E-4	DEFECT
Set of EntityKeys of deleted objects	WITHOUT_CLASSIFICATION	0.9992885659025984	WITHOUT_CLASSIFICATION	7.114340974015699E-4	DEFECT
properties that we have tried to load, and not found in the database	WITHOUT_CLASSIFICATION	0.998789271297276	WITHOUT_CLASSIFICATION	0.001210728702723949	DEFECT
A list of collection wrappers that were instantiating during result set processing, that we will need to initialize at the end of the query	WITHOUT_CLASSIFICATION	0.9989216571025176	WITHOUT_CLASSIFICATION	0.001078342897482426	DEFECT
A container for collections we load up when the owning entity is not yet loaded ... for now, this is purely transient!	WITHOUT_CLASSIFICATION	0.993026399244998	WITHOUT_CLASSIFICATION	0.0069736007550018795	DEFECT
Downgrade locks	WITHOUT_CLASSIFICATION	0.9982579925444163	WITHOUT_CLASSIFICATION	0.0017420074555837268	DEFECT
any earlier proxy takes precedence	WITHOUT_CLASSIFICATION	0.9999094533292431	WITHOUT_CLASSIFICATION	9.054667075690026E-5	DEFECT
unwrap the object	WITHOUT_CLASSIFICATION	0.9999483991287805	WITHOUT_CLASSIFICATION	5.160087121939377E-5	DEFECT
initialize + unwrap the object	WITHOUT_CLASSIFICATION	0.9999735513370973	WITHOUT_CLASSIFICATION	2.6448662902733413E-5	DEFECT
return the proxied object	WITHOUT_CLASSIFICATION	0.9999910357670004	WITHOUT_CLASSIFICATION	8.964232999548311E-6	DEFECT
overwrite old proxy	WITHOUT_CLASSIFICATION	0.9999431504711561	WITHOUT_CLASSIFICATION	5.684952884397344E-5	DEFECT
early exit...	WITHOUT_CLASSIFICATION	0.999836413823538	WITHOUT_CLASSIFICATION	1.6358617646191728E-4	DEFECT
or should it actually throw an exception?	WITHOUT_CLASSIFICATION	0.9969491756455843	WITHOUT_CLASSIFICATION	0.0030508243544157577	DEFECT
treat it just like a new collection	WITHOUT_CLASSIFICATION	0.9999707217166295	WITHOUT_CLASSIFICATION	2.927828337054468E-5	DEFECT
do this work only at the very highest level of the load don't let this method be called recursively	WITHOUT_CLASSIFICATION	0.8798546740148055	WITHOUT_CLASSIFICATION	0.1201453259851944	DEFECT
note that each iteration of the loop may add new elements	WITHOUT_CLASSIFICATION	0.9999707954787856	WITHOUT_CLASSIFICATION	2.920452121434455E-5	DEFECT
it might be an unwrapped collection reference! try to find a wrapper (slowish)	WITHOUT_CLASSIFICATION	0.9999453975975376	WITHOUT_CLASSIFICATION	5.460240246230572E-5	DEFECT
public boolean isNonExistant(EntityKey key) {return nonExistantEntityKeys.contains(key);}	WITHOUT_CLASSIFICATION	0.9999410847111937	WITHOUT_CLASSIFICATION	5.891528880624082E-5	DEFECT
public boolean isNonExistant(EntityUniqueKey key) {return nonExistentEntityUniqueKeys.contains(key);}	WITHOUT_CLASSIFICATION	0.9999410847111937	WITHOUT_CLASSIFICATION	5.891528880624082E-5	DEFECT
iterate all the entities currently associated with the persistence context.	WITHOUT_CLASSIFICATION	0.9997309670452915	WITHOUT_CLASSIFICATION	2.6903295470850506E-4	DEFECT
does this entity entry pertain to the entity persister in which we are interested (owner)?	WITHOUT_CLASSIFICATION	0.9998770295080862	WITHOUT_CLASSIFICATION	1.2297049191389823E-4	DEFECT
check if the managed object is the parent	WITHOUT_CLASSIFICATION	0.9999630718703205	WITHOUT_CLASSIFICATION	3.692812967944337E-5	DEFECT
otherwise, the proxy was pruned during the serialization process	WITHOUT_CLASSIFICATION	0.9999835378867074	WITHOUT_CLASSIFICATION	1.646211329261327E-5	DEFECT
adds remove as a sort-of alias for delete...	WITHOUT_CLASSIFICATION	0.9997892119507258	WITHOUT_CLASSIFICATION	2.1078804927412805E-4	DEFECT
bad cast	WITHOUT_CLASSIFICATION	0.9998564443595155	WITHOUT_CLASSIFICATION	1.4355564048446095E-4	DEFECT
return lhsPersister.getSubclassPropertyColumnNames(property);	WITHOUT_CLASSIFICATION	0.999944354291771	WITHOUT_CLASSIFICATION	5.564570822900188E-5	DEFECT
property-refs for associations defined on a component are not supported, so no need to slice	WITHOUT_CLASSIFICATION	0.9999872479438405	WITHOUT_CLASSIFICATION	1.2752056159476579E-5	DEFECT
if there is no property-ref, assume the join is to the subclass table (ie. the table of the subclass that the association belongs to)	WITHOUT_CLASSIFICATION	0.9999973679759704	WITHOUT_CLASSIFICATION	2.632024029543076E-6	DEFECT
handle a property-ref	WITHOUT_CLASSIFICATION	0.9999696895972697	WITHOUT_CLASSIFICATION	3.031040273032429E-5	DEFECT
NativeSQLQueryReturn	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9998987407217517	WITHOUT_CLASSIFICATION	1.012592782482527E-4	DEFECT
why is all others non final ?	WITHOUT_CLASSIFICATION	0.9999853233689247	WITHOUT_CLASSIFICATION	1.4676631075358818E-5	DEFECT
this.forceCacheRefresh = forceCacheRefresh;	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
HELLA IMPORTANT OPTIMIZATION!!!	WITHOUT_CLASSIFICATION	0.9997919083056696	WITHOUT_CLASSIFICATION	2.0809169433056715E-4	DEFECT
return that.type.equals(type) && EqualsHelper.equals(that.value, value);	WITHOUT_CLASSIFICATION	0.9999498913471792	WITHOUT_CLASSIFICATION	5.0108652820757855E-5	DEFECT
Must occur after resolving identifiers!	WITHOUT_CLASSIFICATION	0.9998883028565214	WITHOUT_CLASSIFICATION	1.1169714347862558E-4	DEFECT
take a snapshot	WITHOUT_CLASSIFICATION	0.9996936493655569	WITHOUT_CLASSIFICATION	3.06350634443008E-4	DEFECT
do a check	WITHOUT_CLASSIFICATION	0.9999934793094792	WITHOUT_CLASSIFICATION	6.5206905207462365E-6	DEFECT
the owning entity may have been deleted and its identifier unset due to identifier-rollback; in which case, try to look up its identifier from the persistence context	WITHOUT_CLASSIFICATION	0.9999392768155734	WITHOUT_CLASSIFICATION	6.072318442660727E-5	DEFECT
do the work	WITHOUT_CLASSIFICATION	0.9982990766276051	WITHOUT_CLASSIFICATION	0.001700923372394973	DEFECT
We've been here before	WITHOUT_CLASSIFICATION	0.999719174577181	WITHOUT_CLASSIFICATION	2.808254228190192E-4	DEFECT
it is or was referenced _somewhere_	WITHOUT_CLASSIFICATION	0.9998021531428665	WITHOUT_CLASSIFICATION	1.97846857133534E-4	DEFECT
do the work	WITHOUT_CLASSIFICATION	0.9982990766276051	WITHOUT_CLASSIFICATION	0.001700923372394973	DEFECT
if either its role changed,	WITHOUT_CLASSIFICATION	0.9999242286727414	WITHOUT_CLASSIFICATION	7.57713272585445E-5	DEFECT
or its key changed	WITHOUT_CLASSIFICATION	0.9999622371907615	WITHOUT_CLASSIFICATION	3.7762809238388785E-5	DEFECT
we will need to create new entries	WITHOUT_CLASSIFICATION	0.9998607495916803	WITHOUT_CLASSIFICATION	1.3925040831973344E-4	DEFECT
we will need to remove ye olde entries	WITHOUT_CLASSIFICATION	0.9990835403190588	WITHOUT_CLASSIFICATION	9.164596809411874E-4	DEFECT
force initialize!	WITHOUT_CLASSIFICATION	0.9998653393819069	WITHOUT_CLASSIFICATION	1.3466061809316927E-4	DEFECT
else if it's elements changed	WITHOUT_CLASSIFICATION	0.9999789135688418	WITHOUT_CLASSIFICATION	2.1086431158162695E-5	DEFECT
ATTRIBUTES MAINTAINED BETWEEN FLUSH CYCLES	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
session-start/post-flush persistent state	WITHOUT_CLASSIFICATION	0.9999063892514433	WITHOUT_CLASSIFICATION	9.361074855673927E-5	DEFECT
allow the CollectionSnapshot to be serialized	WITHOUT_CLASSIFICATION	0.999812057510982	WITHOUT_CLASSIFICATION	1.8794248901794354E-4	DEFECT
ATTRIBUTES USED ONLY DURING FLUSH CYCLE	WITHOUT_CLASSIFICATION	0.9997883749252073	WITHOUT_CLASSIFICATION	2.1162507479264095E-4	DEFECT
"current" means the reference that was found during flush()	WITHOUT_CLASSIFICATION	0.9999278885929058	WITHOUT_CLASSIFICATION	7.21114070941339E-5	DEFECT
"loaded" means the reference that is consistent with the current database state	WITHOUT_CLASSIFICATION	0.9999814767732578	WITHOUT_CLASSIFICATION	1.8523226742308677E-5	DEFECT
during flush, we navigate the object graph to collections and decide what to do with them	WITHOUT_CLASSIFICATION	0.9999725342109821	WITHOUT_CLASSIFICATION	2.7465789018007494E-5	DEFECT
if we instantiate a collection during the flush() process, we must ignore it for the rest of the flush()	WITHOUT_CLASSIFICATION	0.9999696574790724	WITHOUT_CLASSIFICATION	3.0342520927637332E-5	DEFECT
new collections that get found + wrapped during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9998154065138352	WITHOUT_CLASSIFICATION	1.8459348616474E-4	DEFECT
a newly wrapped collection is NOT dirty (or we get unnecessary version updates)	WITHOUT_CLASSIFICATION	0.9999424723979838	WITHOUT_CLASSIFICATION	5.752760201617949E-5	DEFECT
collection.clearDirty()	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
collection.clearDirty()	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
detached collections that get found + reattached during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9997096474504996	WITHOUT_CLASSIFICATION	2.903525495003235E-4	DEFECT
optimization	WITHOUT_CLASSIFICATION	0.9998672481745019	WITHOUT_CLASSIFICATION	1.3275182549812075E-4	DEFECT
optimization optimization	WITHOUT_CLASSIFICATION	0.999914931653051	WITHOUT_CLASSIFICATION	8.506834694901666E-5	DEFECT
re-snapshot	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
for convenience to save some lookups	WITHOUT_CLASSIFICATION	0.9996463340783385	WITHOUT_CLASSIFICATION	3.5366592166157423E-4	DEFECT
NOTE: this is not updated when properties are fetched lazily!	WITHOUT_CLASSIFICATION	0.9936980601282273	WITHOUT_CLASSIFICATION	0.006301939871772714	DEFECT
memory optimization	WITHOUT_CLASSIFICATION	0.9989885215292437	WITHOUT_CLASSIFICATION	0.0010114784707563526	DEFECT
use the id value of a newly instantiated instance as the unsaved-value	WITHOUT_CLASSIFICATION	0.9999661843225722	WITHOUT_CLASSIFICATION	3.381567742767207E-5	DEFECT
copied from Session:	WITHOUT_CLASSIFICATION	0.9998511135144302	WITHOUT_CLASSIFICATION	1.4888648556976038E-4	DEFECT
this should not happen since the DTD prevents it	WITHOUT_CLASSIFICATION	0.997312374593797	WITHOUT_CLASSIFICATION	0.002687625406203068	DEFECT
JoinProcessor needs to know if the where clause fragment came from a dynamic filter or not so it can put the where clause fragment in the right place in the SQL AST. 'hasFilterCondition' keeps track of that fact.	WITHOUT_CLASSIFICATION	0.9997915607958331	WITHOUT_CLASSIFICATION	2.0843920416695958E-4	DEFECT
the current join represents the join between a many-to-many association table and its "target" table. Here we need to apply any additional filters defined specifically on the many-to-many	WITHOUT_CLASSIFICATION	0.9999999187355518	WITHOUT_CLASSIFICATION	8.126444812591149E-8	DEFECT
check basic level one nullablilty	WITHOUT_CLASSIFICATION	0.9999456131041823	WITHOUT_CLASSIFICATION	5.438689581759928E-5	DEFECT
values is not null and is checkable, we'll look deeper	WITHOUT_CLASSIFICATION	0.9996263249996691	WITHOUT_CLASSIFICATION	3.73675000330902E-4	DEFECT
for non null args, check for components and elements containing components	WITHOUT_CLASSIFICATION	0.9999624282590835	WITHOUT_CLASSIFICATION	3.7571740916331146E-5	DEFECT
cache the hashcode	WITHOUT_CLASSIFICATION	0.9999330341095184	WITHOUT_CLASSIFICATION	6.69658904816836E-5	DEFECT
persistent collections may have components	WITHOUT_CLASSIFICATION	0.9992157978386079	WITHOUT_CLASSIFICATION	7.842021613921265E-4	DEFECT
check for all components values in the collection	WITHOUT_CLASSIFICATION	0.99997094657537	WITHOUT_CLASSIFICATION	2.9053424629984435E-5	DEFECT
will check current level if some of them are not null or sublevels if they exist	WITHOUT_CLASSIFICATION	0.9999056415921287	WITHOUT_CLASSIFICATION	9.435840787134967E-5	DEFECT
do the test	WITHOUT_CLASSIFICATION	0.999924024325706	WITHOUT_CLASSIFICATION	7.59756742940304E-5	DEFECT
if its an uninitialized proxy it can't be transient	WITHOUT_CLASSIFICATION	0.9996913252941872	WITHOUT_CLASSIFICATION	3.08674705812743E-4	DEFECT
unwrap it	WITHOUT_CLASSIFICATION	0.9999709136724746	WITHOUT_CLASSIFICATION	2.9086327525437082E-5	DEFECT
See if the entity is already bound to this session, if not look at the entity identifier and assume that the entity is persistent if the id is not "unsaved" (that is, we rely on foreign keys to keep database integrity)	WITHOUT_CLASSIFICATION	0.9989282591048432	WITHOUT_CLASSIFICATION	0.0010717408951567906	DEFECT
an unfetched association can only point to an entity that already exists in the db	WITHOUT_CLASSIFICATION	0.9999882650404415	WITHOUT_CLASSIFICATION	1.173495955860009E-5	DEFECT
let the interceptor inspect the instance to decide	WITHOUT_CLASSIFICATION	0.9999424849348666	WITHOUT_CLASSIFICATION	5.751506513338777E-5	DEFECT
let the persister inspect the instance to decide	WITHOUT_CLASSIFICATION	0.9999429714929619	WITHOUT_CLASSIFICATION	5.7028507038098624E-5	DEFECT
we use the assumed value, if there is one, to avoid hitting the database	WITHOUT_CLASSIFICATION	0.9999441273888795	WITHOUT_CLASSIFICATION	5.587261112043598E-5	DEFECT
hit the database, after checking the session cache for a snapshot	WITHOUT_CLASSIFICATION	0.9999032083771673	WITHOUT_CLASSIFICATION	9.679162283274221E-5	DEFECT
context-entity-identifier returns null explicitly if the entity is not associated with the persistence context; so make some deeper checks...	WITHOUT_CLASSIFICATION	0.9989796732523165	WITHOUT_CLASSIFICATION	0.0010203267476834677	DEFECT
int count = 0;	WITHOUT_CLASSIFICATION	0.9995332059316345	WITHOUT_CLASSIFICATION	4.6679406836549103E-4	DEFECT
the first key found after the given key	WITHOUT_CLASSIFICATION	0.9999953808609282	WITHOUT_CLASSIFICATION	4.619139071838418E-6	DEFECT
checkForEnd = false;	WITHOUT_CLASSIFICATION	0.9998986995360323	WITHOUT_CLASSIFICATION	1.0130046396765933E-4	DEFECT
count++;	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
end of array, start filling again from start	WITHOUT_CLASSIFICATION	0.9998916245997864	WITHOUT_CLASSIFICATION	1.0837540021351156E-4	DEFECT
we ran out of keys to try	WITHOUT_CLASSIFICATION	0.999986029025687	WITHOUT_CLASSIFICATION	1.397097431304698E-5	DEFECT
first element of array is reserved for the actual instance we are loading!	WITHOUT_CLASSIFICATION	0.9999945420120953	WITHOUT_CLASSIFICATION	5.457987904746341E-6	DEFECT
the first id found after the given id	WITHOUT_CLASSIFICATION	0.9999915250858588	WITHOUT_CLASSIFICATION	8.474914141121195E-6	DEFECT
we ran out of ids to try	WITHOUT_CLASSIFICATION	0.9999858603774123	WITHOUT_CLASSIFICATION	1.4139622587531808E-5	DEFECT
look for existing collection as part of the persistence context	WITHOUT_CLASSIFICATION	0.9999712092256029	WITHOUT_CLASSIFICATION	2.8790774397122725E-5	DEFECT
ignore this row of results! Note the early exit	WITHOUT_CLASSIFICATION	0.9998825083161325	WITHOUT_CLASSIFICATION	1.1749168386753589E-4	DEFECT
initialize this collection	WITHOUT_CLASSIFICATION	0.9998568685195411	WITHOUT_CLASSIFICATION	1.4313148045886349E-4	DEFECT
create one	WITHOUT_CLASSIFICATION	0.9999890739436954	WITHOUT_CLASSIFICATION	1.0926056304522383E-5	DEFECT
warning: can cause a recursive calls! (proxy initialization)	WITHOUT_CLASSIFICATION	0.9995123916711366	WITHOUT_CLASSIFICATION	4.8760832886348863E-4	DEFECT
there were no queued additions and the role has a cache	WITHOUT_CLASSIFICATION	0.9999866647890819	WITHOUT_CLASSIFICATION	1.333521091812767E-5	DEFECT
and this is not a forced initialization during flush	WITHOUT_CLASSIFICATION	0.9971691843423417	WITHOUT_CLASSIFICATION	0.0028308156576584203	DEFECT
some filters affecting the collection are enabled on the session, so do not do the put into the cache.	WITHOUT_CLASSIFICATION	0.9998191315921621	WITHOUT_CLASSIFICATION	1.8086840783788243E-4	DEFECT
cleanup code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997417748551298	WITHOUT_CLASSIFICATION	2.582251448701539E-4	DEFECT
loading collection xrefs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9996334474921507	WITHOUT_CLASSIFICATION	3.6655250784944026E-4	DEFECT
Collection load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998491900696997	WITHOUT_CLASSIFICATION	1.5080993030027698E-4	DEFECT
simple cache of param metadata based on query string. Ideally, the original "user-supplied query" string should be used to retreive this metadata (i.e., not the para-list-expanded query string) to avoid unnecessary cache entries. Used solely for caching param metadata for native-sql queries, see getSQLParameterMetadata() for a discussion as to why...	WITHOUT_CLASSIFICATION	0.9987593043021916	WITHOUT_CLASSIFICATION	0.0012406956978083558	DEFECT
the cache of the actual plans...	WITHOUT_CLASSIFICATION	0.9999362494866573	WITHOUT_CLASSIFICATION	6.375051334273795E-5	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.999977135424313	WITHOUT_CLASSIFICATION	2.2864575686937835E-5	DEFECT
for native-sql queries, the param metadata is determined outside any relation to a query plan, because query plan creation and/or retreival for a native-sql query depends on all of the return types having been set, which might not be the case up-front when param metadata would be most useful	WITHOUT_CLASSIFICATION	0.9930008702646894	WITHOUT_CLASSIFICATION	0.006999129735310636	DEFECT
don't care...	WITHOUT_CLASSIFICATION	0.9991494880901782	WITHOUT_CLASSIFICATION	8.505119098217599E-4	DEFECT
Recognition code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997363366130333	WITHOUT_CLASSIFICATION	2.6366338696677267E-4	DEFECT
don't care...	WITHOUT_CLASSIFICATION	0.9991494880901782	WITHOUT_CLASSIFICATION	8.505119098217599E-4	DEFECT
NOTE : firstRow is zero-based	WITHOUT_CLASSIFICATION	0.9997032930011452	WITHOUT_CLASSIFICATION	2.9670699885472814E-4	DEFECT
break the outer loop !!!	WITHOUT_CLASSIFICATION	0.999944853915709	WITHOUT_CLASSIFICATION	5.514608429090968E-5	DEFECT
named parameter	WITHOUT_CLASSIFICATION	0.9998715960400405	WITHOUT_CLASSIFICATION	1.2840395995948695E-4	DEFECT
could be either an ordinal or JPA-positional parameter	WITHOUT_CLASSIFICATION	0.9999875197943129	WITHOUT_CLASSIFICATION	1.2480205687156242E-5	DEFECT
a peek ahead showed this as an JPA-positional parameter	WITHOUT_CLASSIFICATION	0.9999190497302742	WITHOUT_CLASSIFICATION	8.09502697258111E-5	DEFECT
make sure this "name" is an integral	WITHOUT_CLASSIFICATION	0.9998478055214445	WITHOUT_CLASSIFICATION	1.521944785554923E-4	DEFECT
pre-determine and cache the hashcode	WITHOUT_CLASSIFICATION	0.9999395652751562	WITHOUT_CLASSIFICATION	6.0434724843756764E-5	DEFECT
perform the actual work	WITHOUT_CLASSIFICATION	0.998857736014926	WITHOUT_CLASSIFICATION	0.0011422639850740281	DEFECT
if everything went ok, commit the transaction and close the obtained connection handle...	WITHOUT_CLASSIFICATION	0.999988120348167	WITHOUT_CLASSIFICATION	1.1879651833163076E-5	DEFECT
at some point the processing went bad, so we need to: 1) make sure the connection handle gets released 2) try to cleanup the JTA context as much as possible	WITHOUT_CLASSIFICATION	0.9999930622607811	WITHOUT_CLASSIFICATION	6.937739218975801E-6	DEFECT
finally handle the exception	WITHOUT_CLASSIFICATION	0.9999441593741215	WITHOUT_CLASSIFICATION	5.584062587862555E-5	DEFECT
a "detached" collection that belonged to a different entity	WITHOUT_CLASSIFICATION	0.9998300719023864	WITHOUT_CLASSIFICATION	1.6992809761368113E-4	DEFECT
saveOrUpdateCopy() is deprecated!	WITHOUT_CLASSIFICATION	0.9997042213862782	WITHOUT_CLASSIFICATION	2.9577861372181606E-4	DEFECT
collectionPersister should not be null, but we don't want to throw an exception if it is null	WITHOUT_CLASSIFICATION	0.8577616176825944	WITHOUT_CLASSIFICATION	0.14223838231740565	DEFECT
otherwise a null or brand new collection this will also (inefficiently) handle arrays, which have no snapshot, so we can't do any better processArrayOrNewCollection(collection, type);	WITHOUT_CLASSIFICATION	0.9999976647557427	WITHOUT_CLASSIFICATION	2.3352442573308126E-6	DEFECT
a "detached" collection that originally belonged to the same entity	WITHOUT_CLASSIFICATION	0.9996510987948175	WITHOUT_CLASSIFICATION	3.489012051825376E-4	DEFECT
do nothing	WITHOUT_CLASSIFICATION	0.9999944764546118	WITHOUT_CLASSIFICATION	5.5235453881330244E-6	DEFECT
do nothing	WITHOUT_CLASSIFICATION	0.9999944764546118	WITHOUT_CLASSIFICATION	5.5235453881330244E-6	DEFECT
Force a substitution!	WITHOUT_CLASSIFICATION	0.9998992810890691	WITHOUT_CLASSIFICATION	1.0071891093094052E-4	DEFECT
The user requested a "greater" (i.e. more restrictive) form of pessimistic lock	WITHOUT_CLASSIFICATION	0.9997980403662805	WITHOUT_CLASSIFICATION	2.0195963371938248E-4	DEFECT
the database now holds a lock + the object is flushed from the cache, so release the soft lock	WITHOUT_CLASSIFICATION	0.999987046862568	WITHOUT_CLASSIFICATION	1.2953137432042934E-5	DEFECT
now update the object .. has to be outside the main if block above (because of collections)	WITHOUT_CLASSIFICATION	0.9999330033262868	WITHOUT_CLASSIFICATION	6.699667371331556E-5	DEFECT
Search for collections by reachability, updating their role. We don't want to touch collections reachable from a deleted object	WITHOUT_CLASSIFICATION	0.999614332342251	WITHOUT_CLASSIFICATION	3.8566765774886456E-4	DEFECT
this is a situation where the entity id is assigned by a post-insert generator and was saved outside the transaction forcing it to be delayed	WITHOUT_CLASSIFICATION	0.9999107349543878	WITHOUT_CLASSIFICATION	8.926504561212646E-5	DEFECT
NOTE: we need to do the wrap here even if its not "dirty", because collections need wrapping but changes to _them_ don't dirty the container. Also, for versioned data, we need to wrap before calling searchForDirtyCollections	WITHOUT_CLASSIFICATION	0.9522139683303837	WITHOUT_CLASSIFICATION	0.047786031669616306	DEFECT
grab its state saved at deletion	WITHOUT_CLASSIFICATION	0.9999337908687781	WITHOUT_CLASSIFICATION	6.620913122190825E-5	DEFECT
grab its current state	WITHOUT_CLASSIFICATION	0.9999837712883456	WITHOUT_CLASSIFICATION	1.622871165444361E-5	DEFECT
schedule the update note that we intentionally do _not_ pass in currentPersistentState!	WITHOUT_CLASSIFICATION	0.9999085912820925	WITHOUT_CLASSIFICATION	9.140871790743585E-5	DEFECT
substitutes into values by side-effect	WITHOUT_CLASSIFICATION	0.9996881454084963	WITHOUT_CLASSIFICATION	3.118545915036766E-4	DEFECT
give the Interceptor a chance to process property values, if the properties were modified by the Interceptor, we need to set them back to the object	WITHOUT_CLASSIFICATION	0.9999649502370498	WITHOUT_CLASSIFICATION	3.504976295023599E-5	DEFECT
compare to cached state (ignoring collections unless versioned)	WITHOUT_CLASSIFICATION	0.9997218498057812	WITHOUT_CLASSIFICATION	2.78150194218803E-4	DEFECT
if it was dirtied by a collection only	WITHOUT_CLASSIFICATION	0.9997676006835188	WITHOUT_CLASSIFICATION	2.3239931648132332E-4	DEFECT
increment the version number (if necessary)	WITHOUT_CLASSIFICATION	0.9996151876111431	WITHOUT_CLASSIFICATION	3.848123888568464E-4	DEFECT
check nullability but do not perform command execute we'll use scheduled updates for that.	WITHOUT_CLASSIFICATION	0.9998434938377077	WITHOUT_CLASSIFICATION	1.5650616229235186E-4	DEFECT
give the Interceptor a chance to modify property values	WITHOUT_CLASSIFICATION	0.9998595520754539	WITHOUT_CLASSIFICATION	1.4044792454604018E-4	DEFECT
now we might need to recalculate the dirtyProperties array	WITHOUT_CLASSIFICATION	0.9996796500989972	WITHOUT_CLASSIFICATION	3.2034990100282795E-4	DEFECT
use the current version	WITHOUT_CLASSIFICATION	0.9999466139839507	WITHOUT_CLASSIFICATION	5.3386016049314947E-5	DEFECT
Interceptor returned null, so do the dirtycheck ourself, if possible	WITHOUT_CLASSIFICATION	0.9997931278100338	WITHOUT_CLASSIFICATION	2.0687218996608803E-4	DEFECT
object loaded by update()	WITHOUT_CLASSIFICATION	0.9999789193659976	WITHOUT_CLASSIFICATION	2.1080634002430336E-5	DEFECT
dirty check against the usual snapshot of the entity	WITHOUT_CLASSIFICATION	0.999961721051528	WITHOUT_CLASSIFICATION	3.8278948471921474E-5	DEFECT
dirty check against the database snapshot, if possible/necessary	WITHOUT_CLASSIFICATION	0.9999578076178007	WITHOUT_CLASSIFICATION	4.219238219921653E-5	DEFECT
the Interceptor handled the dirty checking	WITHOUT_CLASSIFICATION	0.9999657940557289	WITHOUT_CLASSIFICATION	3.4205944271113634E-5	DEFECT
even process null collections	WITHOUT_CLASSIFICATION	0.9999489155656922	WITHOUT_CLASSIFICATION	5.108443430783334E-5	DEFECT
get the id from the object	WITHOUT_CLASSIFICATION	0.9999819749213932	WITHOUT_CLASSIFICATION	1.802507860684675E-5	DEFECT
always do an INSERT, and let it fail by constraint violation	WITHOUT_CLASSIFICATION	0.9998007900137404	WITHOUT_CLASSIFICATION	1.992099862594701E-4	DEFECT
what is the version on the database?	WITHOUT_CLASSIFICATION	0.9990005177808104	WITHOUT_CLASSIFICATION	9.994822191895735E-4	DEFECT
/ HHH-2378	WITHOUT_CLASSIFICATION	0.9999819863298791	WITHOUT_CLASSIFICATION	1.801367012079905E-5	DEFECT
will result in a SQL UPDATE:	WITHOUT_CLASSIFICATION	0.999554305077536	WITHOUT_CLASSIFICATION	4.45694922463942E-4	DEFECT
else do nothing (don't even reassociate object!)	WITHOUT_CLASSIFICATION	0.9999457314766792	WITHOUT_CLASSIFICATION	5.4268523320816094E-5	DEFECT
no existing row - do an insert	WITHOUT_CLASSIFICATION	0.9999935553472605	WITHOUT_CLASSIFICATION	6.444652739466586E-6	DEFECT
refresh() does not pass an entityName	WITHOUT_CLASSIFICATION	0.9977393604103204	WITHOUT_CLASSIFICATION	0.0022606395896795596	DEFECT
do not return a proxy! (this option indicates we are initializing a proxy)	WITHOUT_CLASSIFICATION	0.9998619317954276	WITHOUT_CLASSIFICATION	1.3806820457240622E-4	DEFECT
return a proxy if appropriate	WITHOUT_CLASSIFICATION	0.9999812435639962	WITHOUT_CLASSIFICATION	1.8756436003828146E-5	DEFECT
return existing object or initialized proxy (unless deleted)	WITHOUT_CLASSIFICATION	0.9999883076678612	WITHOUT_CLASSIFICATION	1.1692332138851693E-5	DEFECT
return new uninitialized proxy	WITHOUT_CLASSIFICATION	0.9999852400177918	WITHOUT_CLASSIFICATION	1.4759982208131721E-5	DEFECT
this object was already loaded	WITHOUT_CLASSIFICATION	0.9999920532595583	WITHOUT_CLASSIFICATION	7.946740441618614E-6	DEFECT
Entity was found in second-level cache...	WITHOUT_CLASSIFICATION	0.9999529238211777	WITHOUT_CLASSIFICATION	4.707617882228632E-5	DEFECT
make it circular-reference safe	WITHOUT_CLASSIFICATION	0.9977773511440896	WITHOUT_CLASSIFICATION	0.002222648855910432	DEFECT
intializes result by side-effect	WITHOUT_CLASSIFICATION	0.9995607886995728	WITHOUT_CLASSIFICATION	4.392113004272275E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pre-flushing section ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998016295617723	WITHOUT_CLASSIFICATION	1.983704382276171E-4	DEFECT
some statistics	WITHOUT_CLASSIFICATION	0.9996748283974811	WITHOUT_CLASSIFICATION	3.2517160251889347E-4	DEFECT
safe from concurrent modification because of how entryList() is implemented on IdentityMap	WITHOUT_CLASSIFICATION	0.9786736987647637	WITHOUT_CLASSIFICATION	0.02132630123523636	DEFECT
Initialize dirty flags for arrays + collections with composite elements and reset reached, doupdate, etc.	WITHOUT_CLASSIFICATION	0.9994358388296508	WITHOUT_CLASSIFICATION	5.641611703492498E-4	DEFECT
Among other things, updateReachables() will recursively load all collections that are moving roles. This might cause entities to be loaded.	WITHOUT_CLASSIFICATION	0.9882685114734587	WITHOUT_CLASSIFICATION	0.01173148852654115	DEFECT
So this needs to be safe from concurrent modification problems. It is safe because of how IdentityMap implements entrySet()	WITHOUT_CLASSIFICATION	0.9775702653076913	WITHOUT_CLASSIFICATION	0.022429734692308627	DEFECT
Update the status of the object and if necessary, schedule an update	WITHOUT_CLASSIFICATION	0.9999945068644981	WITHOUT_CLASSIFICATION	5.493135501992907E-6	DEFECT
Schedule updates to collections:	WITHOUT_CLASSIFICATION	0.9997338447727595	WITHOUT_CLASSIFICATION	2.661552272404229E-4	DEFECT
we need to lock the collection caches before executing entity inserts/updates in order to account for bidi associations	WITHOUT_CLASSIFICATION	0.9998714333075809	WITHOUT_CLASSIFICATION	1.2856669241910788E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Post-flushing section ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998016295617723	WITHOUT_CLASSIFICATION	1.983704382276171E-4	DEFECT
the database has changed now, so the subselect results need to be invalidated	WITHOUT_CLASSIFICATION	0.9999499908502517	WITHOUT_CLASSIFICATION	5.000914974840258E-5	DEFECT
if the collection is dereferenced, remove from the session cache iter.remove(); does not work, since the entrySet is not backed by the set	WITHOUT_CLASSIFICATION	0.9990322484413943	WITHOUT_CLASSIFICATION	9.677515586056336E-4	DEFECT
otherwise recreate the mapping between the collection and its key	WITHOUT_CLASSIFICATION	0.9999804842521711	WITHOUT_CLASSIFICATION	1.9515747828865485E-5	DEFECT
get a snapshot	WITHOUT_CLASSIFICATION	0.9999233293888363	WITHOUT_CLASSIFICATION	7.667061116367218E-5	DEFECT
package-private	WITHOUT_CLASSIFICATION	0.999837723747907	WITHOUT_CLASSIFICATION	1.6227625209293815E-4	DEFECT
package-private	WITHOUT_CLASSIFICATION	0.999837723747907	WITHOUT_CLASSIFICATION	1.6227625209293815E-4	DEFECT
key is an entity involved with the operation performed by the listener; value is a flag indicating if the listener explicitly operates on the entity	WITHOUT_CLASSIFICATION	0.9999950738497027	WITHOUT_CLASSIFICATION	4.926150297374626E-6	DEFECT
EARLY EXIT!!!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
ie. the entity came in from update()	WITHOUT_CLASSIFICATION	0.9997891897971753	WITHOUT_CLASSIFICATION	2.1081020282459598E-4	DEFECT
before any callbacks, etc, so subdeletions see that this deletion happened first	WITHOUT_CLASSIFICATION	0.9999834779915361	WITHOUT_CLASSIFICATION	1.6522008463832735E-5	DEFECT
Ensures that containing deletions happen before sub-deletions	WITHOUT_CLASSIFICATION	0.9998267712555601	WITHOUT_CLASSIFICATION	1.7322874443984849E-4	DEFECT
TypeFactory.deepCopy( currentState, propTypes, persister.getPropertyUpdateability(), deletedState, session );	WITHOUT_CLASSIFICATION	0.9996014073657967	WITHOUT_CLASSIFICATION	3.985926342033011E-4	DEFECT
cascade-delete to collections BEFORE the collection owner is deleted	WITHOUT_CLASSIFICATION	0.9994219156404431	WITHOUT_CLASSIFICATION	5.780843595568999E-4	DEFECT
cascade-delete to many-to-one AFTER the parent was deleted	WITHOUT_CLASSIFICATION	0.9998880035150406	WITHOUT_CLASSIFICATION	1.1199648495939885E-4	DEFECT
if it is an initialized proxy, let cascade handle it later on	WITHOUT_CLASSIFICATION	0.9999755483436304	WITHOUT_CLASSIFICATION	2.4451656369504514E-5	DEFECT
assign the requested id to the proxy, before reassociating the proxy	WITHOUT_CLASSIFICATION	0.9997645788093884	WITHOUT_CLASSIFICATION	2.3542119061148827E-4	DEFECT
an uninitialized proxy, noop, don't even need to return an id, since it is never a save()	WITHOUT_CLASSIFICATION	0.9992360370361764	WITHOUT_CLASSIFICATION	7.639629638236825E-4	DEFECT
initialize properties of the event:	WITHOUT_CLASSIFICATION	0.9997656687591586	WITHOUT_CLASSIFICATION	2.343312408414177E-4	DEFECT
return the id in the event object	WITHOUT_CLASSIFICATION	0.9999767794457419	WITHOUT_CLASSIFICATION	2.3220554258074032E-5	DEFECT
TRANSIENT or DELETED	WITHOUT_CLASSIFICATION	0.9998449049721887	WITHOUT_CLASSIFICATION	1.5509502781133673E-4	DEFECT
use the id assigned to the instance	WITHOUT_CLASSIFICATION	0.9999107656142245	WITHOUT_CLASSIFICATION	8.923438577544243E-5	DEFECT
assume this is a newly instantiated transient object which should be saved rather than updated	WITHOUT_CLASSIFICATION	0.9958906267263555	WITHOUT_CLASSIFICATION	0.004109373273644394	DEFECT
this is a transient object with existing persistent state not loaded by the session	WITHOUT_CLASSIFICATION	0.9998991423336443	WITHOUT_CLASSIFICATION	1.0085766635578899E-4	DEFECT
a collection loaded in the current session can not possibly be the collection belonging to the entity passed to update()	WITHOUT_CLASSIFICATION	0.9999342362056706	WITHOUT_CLASSIFICATION	6.576379432941342E-5	DEFECT
cachedState,	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
assume true, since we don't really know, and it doesn't matter	WITHOUT_CLASSIFICATION	0.9431559461116962	WITHOUT_CLASSIFICATION	0.056844053888303867	DEFECT
a "detached" collection!	WITHOUT_CLASSIFICATION	0.999889091360344	WITHOUT_CLASSIFICATION	1.1090863965608459E-4	DEFECT
if the collection belonged to a different entity, clean up the existing state of the collection	WITHOUT_CLASSIFICATION	0.9999268737062345	WITHOUT_CLASSIFICATION	7.312629376559519E-5	DEFECT
log.debug( "calling onLoad()" );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
note: performExecutions() clears all collectionXxxxtion collections (the collection actions) in the session	WITHOUT_CLASSIFICATION	0.9999546911321876	WITHOUT_CLASSIFICATION	4.530886781230258E-5	DEFECT
if no array holder we found an unwrappered array (this can't occur, because we now always call wrap() before getting to here) return (ah==null) ? true : searchForDirtyCollections(ah, type);	WITHOUT_CLASSIFICATION	0.9999956882372748	WITHOUT_CLASSIFICATION	4.311762725248888E-6	DEFECT
if not wrappered yet, its dirty (this can't occur, because we now always call wrap() before getting to here) return ( ! (obj instanceof PersistentCollection) ) ? true : searchForDirtyCollections( (PersistentCollection) obj, type );	WITHOUT_CLASSIFICATION	0.9987414756749413	WITHOUT_CLASSIFICATION	0.001258524325058742	DEFECT
we need to check even if it was not initialized, because of delayed adds!	WITHOUT_CLASSIFICATION	0.9999485447957436	WITHOUT_CLASSIFICATION	5.145520425655281E-5	DEFECT
NOTE: EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998969133110821	WITHOUT_CLASSIFICATION	1.0308668891793757E-4	DEFECT
find any entities that are still transient after retry	WITHOUT_CLASSIFICATION	0.9999647003215831	WITHOUT_CLASSIFICATION	3.5299678416962746E-5	DEFECT
EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Check the persistence context for an entry relating to this entity to be merged...	WITHOUT_CLASSIFICATION	0.9998949359528723	WITHOUT_CLASSIFICATION	1.0506404712769265E-4	DEFECT
we have specialized case of a detached entity from the perspective of the merge operation. Specifically, we have an incoming entity instance which has a corresponding entry in the current persistence context, but registered under a different entity instance	WITHOUT_CLASSIFICATION	0.9999944690527593	WITHOUT_CLASSIFICATION	5.5309472406243845E-6	DEFECT
DELETED	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
before cascade!	WITHOUT_CLASSIFICATION	0.999678256777358	WITHOUT_CLASSIFICATION	3.2174322264199467E-4	DEFECT
cascade first, so that all unsaved objects get their copy created before we actually copy cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);	WITHOUT_CLASSIFICATION	0.9999679956406717	WITHOUT_CLASSIFICATION	3.200435932825709E-5	DEFECT
this bit is only really absolutely necessary for handling requestedId, but is also good if we merge multiple object graphs, since it helps ensure uniqueness	WITHOUT_CLASSIFICATION	0.9999114291754521	WITHOUT_CLASSIFICATION	8.857082454790343E-5	DEFECT
continue...; we'll find out if it ends up not getting saved later	WITHOUT_CLASSIFICATION	0.9996289000482371	WITHOUT_CLASSIFICATION	3.7109995176295903E-4	DEFECT
cascade first, so that all unsaved objects get their copy created before we actually copy	WITHOUT_CLASSIFICATION	0.9999679956406717	WITHOUT_CLASSIFICATION	3.200435932825709E-5	DEFECT
check that entity id = requestedId	WITHOUT_CLASSIFICATION	0.9999406757049552	WITHOUT_CLASSIFICATION	5.932429504489593E-5	DEFECT
before cascade!	WITHOUT_CLASSIFICATION	0.999678256777358	WITHOUT_CLASSIFICATION	3.2174322264199467E-4	DEFECT
we got here because we assumed that an instance with an assigned id was detached, when it was really persistent	WITHOUT_CLASSIFICATION	0.9999647989020088	WITHOUT_CLASSIFICATION	3.520109799115462E-5	DEFECT
cascade first, so that all unsaved objects get their copy created before we actually copy	WITHOUT_CLASSIFICATION	0.9999679956406717	WITHOUT_CLASSIFICATION	3.200435932825709E-5	DEFECT
copyValues works by reflection, so explicitly mark the entity instance dirty	WITHOUT_CLASSIFICATION	0.9997093075450341	WITHOUT_CLASSIFICATION	2.906924549659729E-4	DEFECT
EARLY EXIT	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
source.getBatcher().executeBatch(); found another way to ensure that all batched joined inserts have been executed	WITHOUT_CLASSIFICATION	0.999980461729475	WITHOUT_CLASSIFICATION	1.9538270525086427E-5	DEFECT
substitutes into values by side-effect	WITHOUT_CLASSIFICATION	0.9996881454084963	WITHOUT_CLASSIFICATION	3.118545915036766E-4	DEFECT
now done in EntityIdentityInsertAction persister.setIdentifier( entity, id, source.getEntityMode() );	WITHOUT_CLASSIFICATION	0.9999272774598925	WITHOUT_CLASSIFICATION	7.272254010750097E-5	DEFECT
source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );	WITHOUT_CLASSIFICATION	0.9995836384129115	WITHOUT_CLASSIFICATION	4.1636158708837793E-4	DEFECT
keep the existing version number in the case of replicate!	WITHOUT_CLASSIFICATION	0.9998132085677006	WITHOUT_CLASSIFICATION	1.8679143229936154E-4	DEFECT
cascade-save to many-to-one BEFORE the parent is saved	WITHOUT_CLASSIFICATION	0.9997243830518255	WITHOUT_CLASSIFICATION	2.756169481744683E-4	DEFECT
pass this as an argument only to avoid double looking	WITHOUT_CLASSIFICATION	0.9998568399373156	WITHOUT_CLASSIFICATION	1.431600626844113E-4	DEFECT
the object is persistent	WITHOUT_CLASSIFICATION	0.9999510383935319	WITHOUT_CLASSIFICATION	4.8961606468147546E-5	DEFECT
the entity is associated with the session, so check its status	WITHOUT_CLASSIFICATION	0.9999841491148044	WITHOUT_CLASSIFICATION	1.585088519565289E-5	DEFECT
do nothing for persistent instances	WITHOUT_CLASSIFICATION	0.9999695886195019	WITHOUT_CLASSIFICATION	3.0411380498094327E-5	DEFECT
ie. e.status==DELETED	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
the object is transient or detached	WITHOUT_CLASSIFICATION	0.9999171198824025	WITHOUT_CLASSIFICATION	8.288011759749429E-5	DEFECT
NOTE EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998772999201709	WITHOUT_CLASSIFICATION	1.2270007982914232E-4	DEFECT
Private constructor - stops checkstyle from complaining.	WITHOUT_CLASSIFICATION	0.9998530271622054	WITHOUT_CLASSIFICATION	1.4697283779464314E-4	DEFECT
First, try to find a matching constructor accepting a ViolatedConstraintNameExtracter param...	WITHOUT_CLASSIFICATION	0.9999401192937	WITHOUT_CLASSIFICATION	5.988070630001501E-5	DEFECT
eat it and try next	WITHOUT_CLASSIFICATION	0.9997630153295073	WITHOUT_CLASSIFICATION	2.369846704926115E-4	DEFECT
Otherwise, try to use the no-arg constructor	WITHOUT_CLASSIFICATION	0.9999768156176962	WITHOUT_CLASSIFICATION	2.3184382303767826E-5	DEFECT
oracle sql-state code for deadlock	WITHOUT_CLASSIFICATION	0.9998127407700984	WITHOUT_CLASSIFICATION	1.87259229901681E-4	DEFECT
CollectionPropertyMapping processes everything except 'index'.	WITHOUT_CLASSIFICATION	0.9999052817760132	WITHOUT_CLASSIFICATION	9.471822398671371E-5	DEFECT
remove initial ", "	WITHOUT_CLASSIFICATION	0.9998390868977874	WITHOUT_CLASSIFICATION	1.6091310221253834E-4	DEFECT
remove initial " and "	WITHOUT_CLASSIFICATION	0.9999251798614879	WITHOUT_CLASSIFICATION	7.482013851210765E-5	DEFECT
beforeClassTokens.add("new"); DEFINITELY DON'T HAVE THIS!!	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
notAfterClassTokens.add(",");	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
just especially for the trivial collection filter	WITHOUT_CLASSIFICATION	0.9999818231467342	WITHOUT_CLASSIFICATION	1.817685326573475E-5	DEFECT
update last non-whitespace token, if necessary	WITHOUT_CLASSIFICATION	0.9999343028960204	WITHOUT_CLASSIFICATION	6.569710397963736E-5	DEFECT
select-range is terminated by declaration of "from"	WITHOUT_CLASSIFICATION	0.9997867175837811	WITHOUT_CLASSIFICATION	2.132824162188918E-4	DEFECT
scan for next non-whitespace token	WITHOUT_CLASSIFICATION	0.9991020393062858	WITHOUT_CLASSIFICATION	8.979606937142404E-4	DEFECT
Note this!!	WITHOUT_CLASSIFICATION	0.9998557687369181	WITHOUT_CLASSIFICATION	1.442312630818731E-4	DEFECT
Error message constants.	WITHOUT_CLASSIFICATION	0.9998878301291141	WITHOUT_CLASSIFICATION	1.1216987088600279E-4	DEFECT
handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997227898861412	WITHOUT_CLASSIFICATION	2.772101138588166E-4	DEFECT
semantic action handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9995743958352703	WITHOUT_CLASSIFICATION	4.25604164729697E-4	DEFECT
Handle collection-fiter compilation. IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!	WITHOUT_CLASSIFICATION	0.9975938425531758	WITHOUT_CLASSIFICATION	0.002406157446824181	DEFECT
Show the modified AST.	WITHOUT_CLASSIFICATION	0.9999610753301772	WITHOUT_CLASSIFICATION	3.8924669822789616E-5	DEFECT
Create a parameter specification for the collection filter...	WITHOUT_CLASSIFICATION	0.9999370684276406	WITHOUT_CLASSIFICATION	6.293157235932259E-5	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
Get the names of the columns used to link between the collection owner and the collection elements.	WITHOUT_CLASSIFICATION	0.9999926561083688	WITHOUT_CLASSIFICATION	7.343891631140059E-6	DEFECT
The path AST should be a DotNode, and it should have been evaluated already.	WITHOUT_CLASSIFICATION	0.9996404339186515	WITHOUT_CLASSIFICATION	3.5956608134848526E-4	DEFECT
Tell the dot node about the join type.	WITHOUT_CLASSIFICATION	0.9998745167954257	WITHOUT_CLASSIFICATION	1.254832045743968E-4	DEFECT
Re-arrange the tree so that the collection function is the root and the lhs is the path.	WITHOUT_CLASSIFICATION	0.9998920210062432	WITHOUT_CLASSIFICATION	1.0797899375677416E-4	DEFECT
Don't forget to resolve the argument! Resolve the collection function now.	WITHOUT_CLASSIFICATION	0.9995409070906587	WITHOUT_CLASSIFICATION	4.590929093412172E-4	DEFECT
Resolve everything up to this dot, but don't resolve the placeholders yet.	WITHOUT_CLASSIFICATION	0.998738120964405	WITHOUT_CLASSIFICATION	0.0012618790355950155	DEFECT
Should mean that no such property was found	WITHOUT_CLASSIFICATION	0.9999968295936114	WITHOUT_CLASSIFICATION	3.170406388627599E-6	DEFECT
Was there an explicit select expression?	WITHOUT_CLASSIFICATION	0.9999288332338191	WITHOUT_CLASSIFICATION	7.116676618089834E-5	DEFECT
Attach any mapping-defined "ORDER BY" fragments	WITHOUT_CLASSIFICATION	0.9998824101920801	WITHOUT_CLASSIFICATION	1.1758980791991864E-4	DEFECT
Use the explicitly declared select expression; determine the return types indicated by each select token	WITHOUT_CLASSIFICATION	0.9999888207956096	WITHOUT_CLASSIFICATION	1.1179204390399465E-5	DEFECT
After that, process the JOINs. Invoke a delegate to do the work, as this is farily complex.	WITHOUT_CLASSIFICATION	0.9998549337628538	WITHOUT_CLASSIFICATION	1.4506623714609438E-4	DEFECT
Make #@%$^#^&# sure no alias is applied to the table name	WITHOUT_CLASSIFICATION	0.9999975848786905	WITHOUT_CLASSIFICATION	2.4151213095293194E-6	DEFECT
We need to generate ids as part of this bulk insert. Note that this is only supported for sequence-style generators and post-insert-style generators; basically, only in-db generators	WITHOUT_CLASSIFICATION	0.9961022532358439	WITHOUT_CLASSIFICATION	0.00389774676415608	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
We need to seed the version value as part of this bulk insert	WITHOUT_CLASSIFICATION	0.9996980210160346	WITHOUT_CLASSIFICATION	3.019789839655309E-4	DEFECT
we need to wrtap the param in a cast()	WITHOUT_CLASSIFICATION	0.9998818942325657	WITHOUT_CLASSIFICATION	1.1810576743438155E-4	DEFECT
This is called when it's time to fully resolve a path expression.	WITHOUT_CLASSIFICATION	0.9992637550600658	WITHOUT_CLASSIFICATION	7.362449399342618E-4	DEFECT
Generate implicit joins, only if necessary.	WITHOUT_CLASSIFICATION	0.9988300147225281	WITHOUT_CLASSIFICATION	0.0011699852774718585	DEFECT
Notify the FROM element that it is being referenced by the select.	WITHOUT_CLASSIFICATION	0.9997622707191677	WITHOUT_CLASSIFICATION	2.377292808324256E-4	DEFECT
Turn off includeSubclasses on all FromElements.	WITHOUT_CLASSIFICATION	0.9998224371638845	WITHOUT_CLASSIFICATION	1.7756283611549098E-4	DEFECT
create the node initially with the param name so that it shows appropriately in the "original text" attribute	WITHOUT_CLASSIFICATION	0.9999860539860982	WITHOUT_CLASSIFICATION	1.3946013901798929E-5	DEFECT
Use the delegate, resolve identifiers as FROM element aliases.	WITHOUT_CLASSIFICATION	0.9999603800158007	WITHOUT_CLASSIFICATION	3.961998419928875E-5	DEFECT
select clauses for insert statements should alwasy be treated as shallow	WITHOUT_CLASSIFICATION	0.9997536301234483	WITHOUT_CLASSIFICATION	2.46369876551754E-4	DEFECT
no need to even collect this information if the persister is considered multi-table	WITHOUT_CLASSIFICATION	0.9995183898174571	WITHOUT_CLASSIFICATION	4.816101825429341E-4	DEFECT
Make sure that the persister is versioned	WITHOUT_CLASSIFICATION	0.9999524894869589	WITHOUT_CLASSIFICATION	4.7510513041141536E-5	DEFECT
handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997227898861412	WITHOUT_CLASSIFICATION	2.772101138588166E-4	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
--Commented out by Inspection (12/11/04 10:56 AM): int getWarningCount();	WITHOUT_CLASSIFICATION	0.9996419628494455	WITHOUT_CLASSIFICATION	3.5803715055441156E-4	DEFECT
Alias references and identifiers use the same node class.	WITHOUT_CLASSIFICATION	0.9999376432049543	WITHOUT_CLASSIFICATION	6.235679504581664E-5	DEFECT
switch	WITHOUT_CLASSIFICATION	0.9999777522314723	WITHOUT_CLASSIFICATION	2.2247768527580302E-5	DEFECT
make a new one	WITHOUT_CLASSIFICATION	0.9997432478349856	WITHOUT_CLASSIFICATION	2.5675216501434524E-4	DEFECT
just do the regular thing if you can't find the ctor Your AST must have default ctor to use this.	WITHOUT_CLASSIFICATION	0.999995736477778	WITHOUT_CLASSIFICATION	4.263522222066941E-6	DEFECT
Initialize SQL nodes here.	WITHOUT_CLASSIFICATION	0.9990668921552984	WITHOUT_CLASSIFICATION	9.331078447016278E-4	DEFECT
semantic action processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9994255983671785	WITHOUT_CLASSIFICATION	5.744016328214333E-4	DEFECT
if template is null we just write the function out as it appears in the hql statement	WITHOUT_CLASSIFICATION	0.99998290954467	WITHOUT_CLASSIFICATION	1.7090455330072692E-5	DEFECT
this function has a template -> redirect output and catch the arguments	WITHOUT_CLASSIFICATION	0.9999239478881782	WITHOUT_CLASSIFICATION	7.605211182180279E-5	DEFECT
--- Inner classes (moved here from sql-gen.g) ---	WITHOUT_CLASSIFICATION	0.9997239779760027	WITHOUT_CLASSIFICATION	2.7602202399737744E-4	DEFECT
check two "adjecent" nodes at the top of the from-clause tree	WITHOUT_CLASSIFICATION	0.9995875777708406	WITHOUT_CLASSIFICATION	4.1242222915940035E-4	DEFECT
/	WITHOUT_CLASSIFICATION	0.9999819863298791	WITHOUT_CLASSIFICATION	1.801367012079905E-5	DEFECT
these are just two unrelated table references	WITHOUT_CLASSIFICATION	0.9999935563606729	WITHOUT_CLASSIFICATION	6.443639327091426E-6	DEFECT
again, both should be FromElements	WITHOUT_CLASSIFICATION	0.9996832615154376	WITHOUT_CLASSIFICATION	3.167384845623572E-4	DEFECT
NOTE : firstRow is zero-based	WITHOUT_CLASSIFICATION	0.9997032930011452	WITHOUT_CLASSIFICATION	2.9670699885472814E-4	DEFECT
right represents a joins originating from left; or both right and left reprersent joins originating from the same FromElement	WITHOUT_CLASSIFICATION	0.9997648826474682	WITHOUT_CLASSIFICATION	2.3511735253184222E-4	DEFECT
check a set of parent/child nodes in the from-clause tree to determine if a comma is required between them	WITHOUT_CLASSIFICATION	0.9992540934173718	WITHOUT_CLASSIFICATION	7.459065826282505E-4	DEFECT
right represents a joins originating from left...	WITHOUT_CLASSIFICATION	0.9997154426654165	WITHOUT_CLASSIFICATION	2.8455733458359424E-4	DEFECT
all clear	WITHOUT_CLASSIFICATION	0.9999914076309356	WITHOUT_CLASSIFICATION	8.592369064336948E-6	DEFECT
Ignore the token class name parameter, and use a specific token class.	WITHOUT_CLASSIFICATION	0.9999621429031988	WITHOUT_CLASSIFICATION	3.785709680106357E-5	DEFECT
overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999352973873487	WITHOUT_CLASSIFICATION	6.470261265134222E-5	DEFECT
overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999352973873487	WITHOUT_CLASSIFICATION	6.470261265134222E-5	DEFECT
remember that ordinal parameters numbers are 1-based!!!	WITHOUT_CLASSIFICATION	0.9999583157029328	WITHOUT_CLASSIFICATION	4.1684297067212954E-5	DEFECT
don't care about other param types here, just those explicitly user-defined...	WITHOUT_CLASSIFICATION	0.9999451628740748	WITHOUT_CLASSIFICATION	5.483712592537162E-5	DEFECT
If the query is already compiled, skip the compilation.	WITHOUT_CLASSIFICATION	0.9995340191314214	WITHOUT_CLASSIFICATION	4.6598086857870213E-4	DEFECT
Remember the parameters for the compilation.	WITHOUT_CLASSIFICATION	0.9998974167906199	WITHOUT_CLASSIFICATION	1.025832093800967E-4	DEFECT
PHASE 1 : Parse the HQL into an AST.	WITHOUT_CLASSIFICATION	0.9998471331635017	WITHOUT_CLASSIFICATION	1.5286683649824275E-4	DEFECT
PHASE 2 : Analyze the HQL AST, and produce an SQL AST.	WITHOUT_CLASSIFICATION	0.9998971505204381	WITHOUT_CLASSIFICATION	1.0284947956178413E-4	DEFECT
PHASE 3 : Generate the SQL.	WITHOUT_CLASSIFICATION	0.9999145748471231	WITHOUT_CLASSIFICATION	8.542515287690691E-5	DEFECT
we do not actually propogate ANTLRExceptions as a cause, so log it here for diagnostic purposes	WITHOUT_CLASSIFICATION	0.9962772467724607	WITHOUT_CLASSIFICATION	0.0037227532275393043	DEFECT
we do not actually propogate ANTLRExceptions as a cause, so log it here for diagnostic purposes	WITHOUT_CLASSIFICATION	0.9962772467724607	WITHOUT_CLASSIFICATION	0.0037227532275393043	DEFECT
only needed during compilation phase...	WITHOUT_CLASSIFICATION	0.9993729938471507	WITHOUT_CLASSIFICATION	6.27006152849341E-4	DEFECT
Transform the tree.	WITHOUT_CLASSIFICATION	0.999885227963826	WITHOUT_CLASSIFICATION	1.1477203617407442E-4	DEFECT
Parse the query string into an HQL AST.	WITHOUT_CLASSIFICATION	0.9995835981732436	WITHOUT_CLASSIFICATION	4.164018267564215E-4	DEFECT
Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9998866412548657	WITHOUT_CLASSIFICATION	1.1335874513435885E-4	DEFECT
Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9998866412548657	WITHOUT_CLASSIFICATION	1.1335874513435885E-4	DEFECT
Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9998866412548657	WITHOUT_CLASSIFICATION	1.1335874513435885E-4	DEFECT
NOTE : ( max - 1 ) because first is zero-based while max is not...	WITHOUT_CLASSIFICATION	0.9999563202770736	WITHOUT_CLASSIFICATION	4.367972292642747E-5	DEFECT
-- Package local methods for the QueryLoader delegate --	WITHOUT_CLASSIFICATION	0.9998685339115159	WITHOUT_CLASSIFICATION	1.3146608848404694E-4	DEFECT
If there are no collection fetches, then no further checks are needed	WITHOUT_CLASSIFICATION	0.9999840156274203	WITHOUT_CLASSIFICATION	1.598437257967391E-5	DEFECT
A shallow query is ok (although technically there should be no fetching here...)	WITHOUT_CLASSIFICATION	0.9994731825379191	WITHOUT_CLASSIFICATION	5.268174620810041E-4	DEFECT
should be the first, but just to be safe...	WITHOUT_CLASSIFICATION	0.9998327972643996	WITHOUT_CLASSIFICATION	1.6720273560042346E-4	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
Impl Note: allows multiple collection fetches as long as the entire fecthed graph still "points back" to a single root entity for return	WITHOUT_CLASSIFICATION	0.9999804255181832	WITHOUT_CLASSIFICATION	1.9574481816827903E-5	DEFECT
Otherwise, we have a non-scalar select with defined collection fetch(es). Make sure that there is only a single root entity in the return (no tuples)	WITHOUT_CLASSIFICATION	0.9999910773753027	WITHOUT_CLASSIFICATION	8.922624697316752E-6	DEFECT
This is not strictly true. We actually just need to make sure that it is ordered by root-entity PK and that that order-by comes before any non-root-entity ordering...	WITHOUT_CLASSIFICATION	0.9519094657385653	WITHOUT_CLASSIFICATION	0.048090534261434704	DEFECT
paramTranslations = new ParameterTranslationsImpl( collectedParameterSpecifications );	WITHOUT_CLASSIFICATION	0.9996360915633454	WITHOUT_CLASSIFICATION	3.6390843665459657E-4	DEFECT
we are already processing a dot-structure	WITHOUT_CLASSIFICATION	0.999973010514757	WITHOUT_CLASSIFICATION	2.6989485243027124E-5	DEFECT
igndore it...	WITHOUT_CLASSIFICATION	0.9998240031216183	WITHOUT_CLASSIFICATION	1.7599687838159138E-4	DEFECT
we are now at a new tree level	WITHOUT_CLASSIFICATION	0.9999402713087422	WITHOUT_CLASSIFICATION	5.972869125770834E-5	DEFECT
[jsd] The fix for HHH-558...	WITHOUT_CLASSIFICATION	0.9993914920510798	WITHOUT_CLASSIFICATION	6.085079489201938E-4	DEFECT
If the token can tell us if it could be an identifier...	WITHOUT_CLASSIFICATION	0.9999809889849032	WITHOUT_CLASSIFICATION	1.9011015096822343E-5	DEFECT
... and the expected token type was an identifier, then:	WITHOUT_CLASSIFICATION	0.9999858672919915	WITHOUT_CLASSIFICATION	1.4132708008504248E-5	DEFECT
Use the token as an identifier.	WITHOUT_CLASSIFICATION	0.9999731737999898	WITHOUT_CLASSIFICATION	2.68262000102084E-5	DEFECT
Add the token to the AST.	WITHOUT_CLASSIFICATION	0.9999597105876183	WITHOUT_CLASSIFICATION	4.0289412381768266E-5	DEFECT
(NOT (EQ a b) ) => (NE a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
(NOT (NE a b) ) => (EQ a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
(NOT (LT a b) ) => (GE a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
(NOT (GE a b) ) => (LT a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
(NOT (LE a b) ) => (GT a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
(NOT (LIKE a b) ) => (NOT_LIKE a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
(NOT (NOT_LIKE a b) ) => (LIKE a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
(NOT (IS_NOT_NULL a b) ) => (IS_NULL a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
(NOT (BETWEEN a b) ) => (NOT_BETWEEN a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
Initialize the error handling delegate.	WITHOUT_CLASSIFICATION	0.9998812290881026	WITHOUT_CLASSIFICATION	1.1877091189731369E-4	DEFECT
overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999352973873487	WITHOUT_CLASSIFICATION	6.470261265134222E-5	DEFECT
if if Otherwise, handle the error normally.	WITHOUT_CLASSIFICATION	0.999950970595568	WITHOUT_CLASSIFICATION	4.902940443197235E-5	DEFECT
(NOT (NOT_BETWEEN a b) ) => (BETWEEN a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
This can never happen because this rule will always eliminate the child NOT.case NOT:return x.getFirstChild(); (NOT (NOT x) ) => (x)	WITHOUT_CLASSIFICATION	0.9986934973578969	WITHOUT_CLASSIFICATION	0.0013065026421030619	DEFECT
Just add a 'not' parent.	WITHOUT_CLASSIFICATION	0.9998823494903986	WITHOUT_CLASSIFICATION	1.1765050960138526E-4	DEFECT
(EQ NULL b) => (IS_NULL b)	WITHOUT_CLASSIFICATION	0.9999173574153758	WITHOUT_CLASSIFICATION	8.264258462419604E-5	DEFECT
(EQ a NULL) => (IS_NULL a)	WITHOUT_CLASSIFICATION	0.9999069024526485	WITHOUT_CLASSIFICATION	9.30975473515222E-5	DEFECT
NOTE: Because we're using ASTUtil.createParent(), the tree must be created from the bottom up. IS EMPTY x => (EXISTS (QUERY (SELECT_FROM (FROM x) ) ) )	WITHOUT_CLASSIFICATION	0.9999621148474672	WITHOUT_CLASSIFICATION	3.788515253285813E-5	DEFECT
Add NOT if it's negated.	WITHOUT_CLASSIFICATION	0.9999664010707747	WITHOUT_CLASSIFICATION	3.3598929225233176E-5	DEFECT
Create nodes that track line and column number.	WITHOUT_CLASSIFICATION	0.9998043259131044	WITHOUT_CLASSIFICATION	1.9567408689554803E-4	DEFECT
Case 1: Multi token keywords GROUP BY and ORDER BY The next token ( LT(2) ) should be 'by'... otherwise, this is just an ident.	WITHOUT_CLASSIFICATION	0.999814492200061	WITHOUT_CLASSIFICATION	1.8550779993909103E-4	DEFECT
Case 2: The current token is after FROM and before '.'.	WITHOUT_CLASSIFICATION	0.9998899870370468	WITHOUT_CLASSIFICATION	1.1001296295312536E-4	DEFECT
This handles HHH-354, where there is a strange property name in a where clause. If the lookahead contains a DOT then something that isn't an IDENT...	WITHOUT_CLASSIFICATION	0.9992287350511099	WITHOUT_CLASSIFICATION	7.712649488901646E-4	DEFECT
See if the second lookahed token can be an identifier.	WITHOUT_CLASSIFICATION	0.9999563400569909	WITHOUT_CLASSIFICATION	4.3659943009199736E-5	DEFECT
Set it!	WITHOUT_CLASSIFICATION	0.9999767728906597	WITHOUT_CLASSIFICATION	2.3227109340318737E-5	DEFECT
ignore	WITHOUT_CLASSIFICATION	0.9999855898485884	WITHOUT_CLASSIFICATION	1.4410151411497693E-5	DEFECT
strip the " where "	WITHOUT_CLASSIFICATION	0.9999306619135246	WITHOUT_CLASSIFICATION	6.933808647533666E-5	DEFECT
Don't really know all the codes required to adequately decipher returned jdbc exceptions here. simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail	WITHOUT_CLASSIFICATION	0.8867144101934695	WITHOUT_CLASSIFICATION	0.11328558980653042	DEFECT
at the very least cleanup the data :)	WITHOUT_CLASSIFICATION	0.9989088380919787	WITHOUT_CLASSIFICATION	0.001091161908021333	DEFECT
First, save off the pertinent ids, as the return value	WITHOUT_CLASSIFICATION	0.9999878014702259	WITHOUT_CLASSIFICATION	1.2198529774164613E-5	DEFECT
jdbc params are 1-based	WITHOUT_CLASSIFICATION	0.9999537154387111	WITHOUT_CLASSIFICATION	4.628456128887252E-5	DEFECT
jdbc params are 1-based	WITHOUT_CLASSIFICATION	0.9999537154387111	WITHOUT_CLASSIFICATION	4.628456128887252E-5	DEFECT
Start performing the updates	WITHOUT_CLASSIFICATION	0.9999392317640491	WITHOUT_CLASSIFICATION	6.076823595097547E-5	DEFECT
First, save off the pertinent ids, saving the number of pertinent ids for return	WITHOUT_CLASSIFICATION	0.9999766228524677	WITHOUT_CLASSIFICATION	2.33771475323486E-5	DEFECT
Start performing the deletes	WITHOUT_CLASSIFICATION	0.9999301093881077	WITHOUT_CLASSIFICATION	6.989061189243322E-5	DEFECT
otherwise, everything ok.	WITHOUT_CLASSIFICATION	0.9999206325456137	WITHOUT_CLASSIFICATION	7.936745438633962E-5	DEFECT
visit width-first, then depth	WITHOUT_CLASSIFICATION	0.9997804862493306	WITHOUT_CLASSIFICATION	2.1951375066941116E-4	DEFECT
if the types report logical equivalence, return true...	WITHOUT_CLASSIFICATION	0.9999629201408194	WITHOUT_CLASSIFICATION	3.70798591805596E-5	DEFECT
otherwise, perform a "deep equivalence" check...	WITHOUT_CLASSIFICATION	0.9997726458571878	WITHOUT_CLASSIFICATION	2.2735414281218214E-4	DEFECT
If there is no WHERE node, make one.	WITHOUT_CLASSIFICATION	0.999694644215156	WITHOUT_CLASSIFICATION	3.053557848440681E-4	DEFECT
inject the WHERE after the parent	WITHOUT_CLASSIFICATION	0.9999007774302695	WITHOUT_CLASSIFICATION	9.92225697305976E-5	DEFECT
Never include subclasses for implied from elements.	WITHOUT_CLASSIFICATION	0.9999409218867907	WITHOUT_CLASSIFICATION	5.9078113209221504E-5	DEFECT
Moved here from SelectClause [jsd]	WITHOUT_CLASSIFICATION	0.9988817050321175	WITHOUT_CLASSIFICATION	0.001118294967882474	DEFECT
/	WITHOUT_CLASSIFICATION	0.9999819863298791	WITHOUT_CLASSIFICATION	1.801367012079905E-5	DEFECT
Use the table fromElement and the property name to get the array of column names.	WITHOUT_CLASSIFICATION	0.9999902508069936	WITHOUT_CLASSIFICATION	9.749193006552964E-6	DEFECT
Set the attributes of the property reference expression.	WITHOUT_CLASSIFICATION	0.9999084897583337	WITHOUT_CLASSIFICATION	9.151024166624681E-5	DEFECT
If the uresolved property path isn't set yet, just use the property name.	WITHOUT_CLASSIFICATION	0.9999664742462119	WITHOUT_CLASSIFICATION	3.352575378806529E-5	DEFECT
The 'from element' that the property is in.	WITHOUT_CLASSIFICATION	0.9994072590858364	WITHOUT_CLASSIFICATION	5.927409141636383E-4	DEFECT
Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999731483853671	WITHOUT_CLASSIFICATION	2.6851614632829588E-5	DEFECT
Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999731483853671	WITHOUT_CLASSIFICATION	2.6851614632829588E-5	DEFECT
If this dot has already been resolved, stop now.	WITHOUT_CLASSIFICATION	0.9997546106700514	WITHOUT_CLASSIFICATION	2.4538932994847977E-4	DEFECT
If there is no data type for this node, and we're at the end of the path (top most dot node), then this might be a Java constant.	WITHOUT_CLASSIFICATION	0.9964515713408736	WITHOUT_CLASSIFICATION	0.0035484286591264424	DEFECT
The property is a collection...	WITHOUT_CLASSIFICATION	0.9993404001893488	WITHOUT_CLASSIFICATION	6.595998106511866E-4	DEFECT
The property is a component...	WITHOUT_CLASSIFICATION	0.9996710271335488	WITHOUT_CLASSIFICATION	3.289728664511073E-4	DEFECT
The property is another class..	WITHOUT_CLASSIFICATION	0.9996973601821925	WITHOUT_CLASSIFICATION	3.0263981780753464E-4	DEFECT
Otherwise, this is a primitive type.	WITHOUT_CLASSIFICATION	0.9997230954595602	WITHOUT_CLASSIFICATION	2.7690454043980637E-4	DEFECT
foo.bars.size (also handles deprecated stuff like foo.bars.maxelement for backwardness)	WITHOUT_CLASSIFICATION	0.9999313280424271	WITHOUT_CLASSIFICATION	6.867195757284524E-5	DEFECT
This 'dot' expression now refers to the resulting from element.	WITHOUT_CLASSIFICATION	0.9990934167909159	WITHOUT_CLASSIFICATION	9.06583209084006E-4	DEFECT
Always add the collection's query spaces.	WITHOUT_CLASSIFICATION	0.9991373091615476	WITHOUT_CLASSIFICATION	8.62690838452463E-4	DEFECT
in non-select queries, the only time we should need to join is if we are in a subquery from clause	WITHOUT_CLASSIFICATION	0.9998182277213641	WITHOUT_CLASSIFICATION	1.817722786359596E-4	DEFECT
this is the regression style determination which matches the logic of the classic translator	WITHOUT_CLASSIFICATION	0.9999530673781788	WITHOUT_CLASSIFICATION	4.693262182114688E-5	DEFECT
This 'dot' expression now refers to the resulting from element.	WITHOUT_CLASSIFICATION	0.9990934167909159	WITHOUT_CLASSIFICATION	9.06583209084006E-4	DEFECT
even though we might find a pre-existing element by join path, we may not be able to reuse it...	WITHOUT_CLASSIFICATION	0.9955143261687779	WITHOUT_CLASSIFICATION	0.004485673831222071	DEFECT
NOTE : addDuplicateAlias() already performs nullness checks on the alias.	WITHOUT_CLASSIFICATION	0.9998516586897505	WITHOUT_CLASSIFICATION	1.4834131024944663E-4	DEFECT
if the from-clauses are the same, we can be a little more aggressive in terms of what we reuse	WITHOUT_CLASSIFICATION	0.9999776533501842	WITHOUT_CLASSIFICATION	2.2346649815780946E-5	DEFECT
again, null != null here	WITHOUT_CLASSIFICATION	0.9996747163063081	WITHOUT_CLASSIFICATION	3.252836936918566E-4	DEFECT
If this is an implied join in a from element, then use the impled join type which is part of the tree parser's state (set by the gramamar actions).	WITHOUT_CLASSIFICATION	0.9998046007027148	WITHOUT_CLASSIFICATION	1.9539929728517474E-4	DEFECT
otherwise (subquery case) dont reuse the fromElement if we are processing the from-clause of the subquery	WITHOUT_CLASSIFICATION	0.9999748862351585	WITHOUT_CLASSIFICATION	2.5113764841539862E-5	DEFECT
we know only the lhs-hand type, so use that	WITHOUT_CLASSIFICATION	0.9998343787380488	WITHOUT_CLASSIFICATION	1.6562126195115764E-4	DEFECT
the referenced node text is the special 'id'	WITHOUT_CLASSIFICATION	0.9998840793269309	WITHOUT_CLASSIFICATION	1.1592067306913465E-4	DEFECT
only the identifier property field name can be a reference to the associated entity's PK...	WITHOUT_CLASSIFICATION	0.9998921968783012	WITHOUT_CLASSIFICATION	1.0780312169884585E-4	DEFECT
special shortcut for id properties, skip the join! this must only occur at the _end_ of a path expression	WITHOUT_CLASSIFICATION	0.9998472473410009	WITHOUT_CLASSIFICATION	1.527526589990777E-4	DEFECT
Append the new property name onto the unresolved path.	WITHOUT_CLASSIFICATION	0.9999174060353558	WITHOUT_CLASSIFICATION	8.259396464426379E-5	DEFECT
If the lhs is a collection, use CollectionPropertyMapping	WITHOUT_CLASSIFICATION	0.999704122648773	WITHOUT_CLASSIFICATION	2.958773512270415E-4	DEFECT
Tell the destination fromElement to 'includeSubclasses'.	WITHOUT_CLASSIFICATION	0.99986346812451	WITHOUT_CLASSIFICATION	1.3653187549001592E-4	DEFECT
Use theta style (for regression) Move the node up, after the origin node.	WITHOUT_CLASSIFICATION	0.9999404676679472	WITHOUT_CLASSIFICATION	5.9532332052763885E-5	DEFECT
Don't resolve the node again.	WITHOUT_CLASSIFICATION	0.9999445333872791	WITHOUT_CLASSIFICATION	5.546661272089717E-5	DEFECT
for expected parameter type injection, we expect that the lhs represents some form of property ref and that the children of the in-list represent one-or-more params.	WITHOUT_CLASSIFICATION	0.9999816034792357	WITHOUT_CLASSIFICATION	1.839652076428866E-5	DEFECT
we need to strip off the embedded parens so that sql-gen does not double these up	WITHOUT_CLASSIFICATION	0.9998630104544753	WITHOUT_CLASSIFICATION	1.369895455246725E-4	DEFECT
we have something like : "? [op] rhs"	WITHOUT_CLASSIFICATION	0.9996096177405384	WITHOUT_CLASSIFICATION	3.903822594616906E-4	DEFECT
we have something like : "lhs [op] ?"	WITHOUT_CLASSIFICATION	0.9996096177405384	WITHOUT_CLASSIFICATION	3.903822594616906E-4	DEFECT
we know only the rhs-hand type, so use that	WITHOUT_CLASSIFICATION	0.9998343787380488	WITHOUT_CLASSIFICATION	1.6562126195115764E-4	DEFECT
handle the (assumed) valid cases: #1 - the only valid datetime addition synatx is one or the other is a datetime (but not both)	WITHOUT_CLASSIFICATION	0.998735143450496	WITHOUT_CLASSIFICATION	0.0012648565495040197	DEFECT
one or the other needs to be a datetime for us to get into this method in the first place...	WITHOUT_CLASSIFICATION	0.9997311191591304	WITHOUT_CLASSIFICATION	2.6888084086967227E-4	DEFECT
#3 - note that this is also true of "datetime - :param"...	WITHOUT_CLASSIFICATION	0.9995834603028295	WITHOUT_CLASSIFICATION	4.1653969717048785E-4	DEFECT
#2	WITHOUT_CLASSIFICATION	0.9999768386348995	WITHOUT_CLASSIFICATION	2.316136510049562E-5	DEFECT
Generate the inner join -- The elements need to be joined to the collection they are in.	WITHOUT_CLASSIFICATION	0.9999635466543352	WITHOUT_CLASSIFICATION	3.645334566476523E-5	DEFECT
nothing to do	WITHOUT_CLASSIFICATION	0.9999417257014112	WITHOUT_CLASSIFICATION	5.827429858879218E-5	DEFECT
The 'from element' that represents the elements of the collection.	WITHOUT_CLASSIFICATION	0.9998967893921222	WITHOUT_CLASSIFICATION	1.0321060787778763E-4	DEFECT
Add the condition to the join sequence that qualifies the indexed element.	WITHOUT_CLASSIFICATION	0.9980189192017397	WITHOUT_CLASSIFICATION	0.0019810807982603798	DEFECT
Sometimes use the element table alias, sometimes use the... umm... collection table alias (many to many)	WITHOUT_CLASSIFICATION	0.9999799430869583	WITHOUT_CLASSIFICATION	2.0056913041705795E-5	DEFECT
Now, set the text for this node. It should be the element columns.	WITHOUT_CLASSIFICATION	0.9998557710050374	WITHOUT_CLASSIFICATION	1.4422899496259998E-4	DEFECT
Get the function return value type, based on the type of the first argument.	WITHOUT_CLASSIFICATION	0.9999806450210952	WITHOUT_CLASSIFICATION	1.9354978904820286E-5	DEFECT
This will call initialize(tok)!	WITHOUT_CLASSIFICATION	0.9986017999335903	WITHOUT_CLASSIFICATION	0.0013982000664097007	DEFECT
mutation depends on the types of nodes invloved...	WITHOUT_CLASSIFICATION	0.9993632315049334	WITHOUT_CLASSIFICATION	6.367684950665705E-4	DEFECT
"pass along" our initial embedded parameter node(s) to the first generated sql fragment so that it can be handled later for parameter binding...	WITHOUT_CLASSIFICATION	0.9999995597313971	WITHOUT_CLASSIFICATION	4.4026860283835363E-7	DEFECT
logic operators by definition resolve to booleans	WITHOUT_CLASSIFICATION	0.999890640340814	WITHOUT_CLASSIFICATION	1.093596591860362E-4	DEFECT
Generated select expressions are already resolved, nothing to do.	WITHOUT_CLASSIFICATION	0.9999803715515516	WITHOUT_CLASSIFICATION	1.962844844839265E-5	DEFECT
The path may be a reference to an alias defined in the parent query.	WITHOUT_CLASSIFICATION	0.9999869130857605	WITHOUT_CLASSIFICATION	1.3086914239503472E-5	DEFECT
The HQL class alias refers to the class name.	WITHOUT_CLASSIFICATION	0.9997120849972754	WITHOUT_CLASSIFICATION	2.879150027245622E-4	DEFECT
Associate the table alias with the element.	WITHOUT_CLASSIFICATION	0.9999678884888584	WITHOUT_CLASSIFICATION	3.211151114156729E-5	DEFECT
try the parent FromClause...	WITHOUT_CLASSIFICATION	0.9999783479107727	WITHOUT_CLASSIFICATION	2.1652089227249367E-5	DEFECT
Add the new node to the map so that we don't create it twice.	WITHOUT_CLASSIFICATION	0.9999120096751887	WITHOUT_CLASSIFICATION	8.7990324811366E-5	DEFECT
Make sure that all from elements registered with this FROM clause are actually in the AST.	WITHOUT_CLASSIFICATION	0.9999828023674991	WITHOUT_CLASSIFICATION	1.719763250093152E-5	DEFECT
Invoke setScalarColumnText on each constructor argument.	WITHOUT_CLASSIFICATION	0.9999005186981876	WITHOUT_CLASSIFICATION	9.948130181239249E-5	DEFECT
Collect the select expressions, skip the first child because it is the class name.	WITHOUT_CLASSIFICATION	0.9999789678181484	WITHOUT_CLASSIFICATION	2.1032181851562042E-5	DEFECT
return an empty Type array	WITHOUT_CLASSIFICATION	0.9999972738100801	WITHOUT_CLASSIFICATION	2.726189919853504E-6	DEFECT
Constructors are always considered scalar results.	WITHOUT_CLASSIFICATION	0.9998349370603714	WITHOUT_CLASSIFICATION	1.650629396285689E-4	DEFECT
this is the exception returned by ReflectHelper.getConstructor() if it cannot locate an appropriate constructor	WITHOUT_CLASSIFICATION	0.9997560097706467	WITHOUT_CLASSIFICATION	2.439902293534005E-4	DEFECT
if there is no order by, make one	WITHOUT_CLASSIFICATION	0.9998983238546709	WITHOUT_CLASSIFICATION	1.0167614532902618E-4	DEFECT
Find the WHERE; if there is no WHERE, find the FROM...	WITHOUT_CLASSIFICATION	0.9999766622720463	WITHOUT_CLASSIFICATION	2.3337727953738427E-5	DEFECT
Now, inject the newly built ORDER BY into the tree	WITHOUT_CLASSIFICATION	0.9989243330857215	WITHOUT_CLASSIFICATION	0.001075666914278416	DEFECT
ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
logic operators by definition resolve to boolean.	WITHOUT_CLASSIFICATION	0.999890640340814	WITHOUT_CLASSIFICATION	1.093596591860362E-4	DEFECT
Render the identifier select fragment using the table alias.	WITHOUT_CLASSIFICATION	0.9999570401815576	WITHOUT_CLASSIFICATION	4.295981844243169E-5	DEFECT
Class names in the FROM clause result in a JoinSequence (the old FromParser does this).	WITHOUT_CLASSIFICATION	0.9998550363984834	WITHOUT_CLASSIFICATION	1.4496360151660285E-4	DEFECT
For many-to-many joins, use the tablename from the queryable collection for the default text.	WITHOUT_CLASSIFICATION	0.9999847023169119	WITHOUT_CLASSIFICATION	1.5297683088039518E-5	DEFECT
Otherwise, use the property mapping.	WITHOUT_CLASSIFICATION	0.9998042990002552	WITHOUT_CLASSIFICATION	1.9570099974472793E-4	DEFECT
should be safe to only ever expect EntityPersister references here	WITHOUT_CLASSIFICATION	0.9941171925612241	WITHOUT_CLASSIFICATION	0.005882807438775954	DEFECT
If the property is a special collection property name, return a CollectionPropertyMapping.	WITHOUT_CLASSIFICATION	0.9998126200264048	WITHOUT_CLASSIFICATION	1.8737997359517244E-4	DEFECT
Collection of components.	WITHOUT_CLASSIFICATION	0.9999132673964041	WITHOUT_CLASSIFICATION	8.67326035958979E-5	DEFECT
make sure the lhs is "assignable"...	WITHOUT_CLASSIFICATION	0.9998720982890315	WITHOUT_CLASSIFICATION	1.2790171096857563E-4	DEFECT
false indicates to not generate parens around the assignment	WITHOUT_CLASSIFICATION	0.9921289499922634	WITHOUT_CLASSIFICATION	0.007871050007736517	DEFECT
Register the FromElement with the FROM clause, now that we have the names and aliases.	WITHOUT_CLASSIFICATION	0.9999657206214753	WITHOUT_CLASSIFICATION	3.427937852466953E-5	DEFECT
currently allowed...	WITHOUT_CLASSIFICATION	0.9992370138180743	WITHOUT_CLASSIFICATION	7.629861819257543E-4	DEFECT
HHH-276 : implied joins in a subselect where clause - The destination needs to be added to the destination's from clause. Not sure if this is will fix everything, but it works.	WITHOUT_CLASSIFICATION	0.7887392814360308	WITHOUT_CLASSIFICATION	0.2112607185639693	DEFECT
return classAlias == null ? className : classAlias;	WITHOUT_CLASSIFICATION	0.9999578376352405	WITHOUT_CLASSIFICATION	4.216236475947664E-5	DEFECT
This is an explicit FROM element.	WITHOUT_CLASSIFICATION	0.9995307503194549	WITHOUT_CLASSIFICATION	4.6924968054500114E-4	DEFECT
ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
Fetch can't be used with scroll() or iterate().	WITHOUT_CLASSIFICATION	0.9998242411593671	WITHOUT_CLASSIFICATION	1.757588406328304E-4	DEFECT
If it's not implied or it is implied and it's a many to many join where the target wasn't found.	WITHOUT_CLASSIFICATION	0.9969672484069064	WITHOUT_CLASSIFICATION	0.003032751593093624	DEFECT
Since this is an explicit FROM element, it can't be implied in the FROM clause.	WITHOUT_CLASSIFICATION	0.9995103003955661	WITHOUT_CLASSIFICATION	4.896996044338523E-4	DEFECT
Do nothing, eplicit from elements are always in the projection list.	WITHOUT_CLASSIFICATION	0.9999783126275356	WITHOUT_CLASSIFICATION	2.168737246444805E-5	DEFECT
propertyName refers to something like collection.size...	WITHOUT_CLASSIFICATION	0.9998436953228718	WITHOUT_CLASSIFICATION	1.5630467712820094E-4	DEFECT
property name is a sub-path of a component...	WITHOUT_CLASSIFICATION	0.9997180336524062	WITHOUT_CLASSIFICATION	2.819663475938063E-4	DEFECT
Always add the collection's query spaces.	WITHOUT_CLASSIFICATION	0.9991373091615476	WITHOUT_CLASSIFICATION	8.62690838452463E-4	DEFECT
nothing to do; even if the operand is a parameter, no way we could infer an appropriate expected type here	WITHOUT_CLASSIFICATION	0.9999974376760148	WITHOUT_CLASSIFICATION	2.5623239852767317E-6	DEFECT
logic operators by definition resolve to booleans	WITHOUT_CLASSIFICATION	0.999890640340814	WITHOUT_CLASSIFICATION	1.093596591860362E-4	DEFECT
DotNode uses null here...	WITHOUT_CLASSIFICATION	0.9975545753094456	WITHOUT_CLASSIFICATION	0.0024454246905544724	DEFECT
We represent a from-clause alias	WITHOUT_CLASSIFICATION	0.9996580335048678	WITHOUT_CLASSIFICATION	3.419664951321422E-4	DEFECT
we are the LHS of the DOT representing a naked comp-prop-ref	WITHOUT_CLASSIFICATION	0.999953657073153	WITHOUT_CLASSIFICATION	4.6342926846946303E-5	DEFECT
we are the RHS of the DOT representing a naked comp-prop-ref	WITHOUT_CLASSIFICATION	0.9999535738840312	WITHOUT_CLASSIFICATION	4.642611596896596E-5	DEFECT
we represent a naked (simple) prop-ref	WITHOUT_CLASSIFICATION	0.9998872406292176	WITHOUT_CLASSIFICATION	1.1275937078240396E-4	DEFECT
EARLY EXIT!!! return so the resolve call explicitly coming from DotNode can resolve this...	WITHOUT_CLASSIFICATION	0.9999992512864301	WITHOUT_CLASSIFICATION	7.487135699299709E-7	DEFECT
assume this ident's text does not refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.9976671943112987	WITHOUT_CLASSIFICATION	0.0023328056887014256	DEFECT
just ignore it for now, it'll get resolved later...	WITHOUT_CLASSIFICATION	0.9999832742486653	WITHOUT_CLASSIFICATION	1.672575133470457E-5	DEFECT
This is not actually a constant, but a reference to FROM element.	WITHOUT_CLASSIFICATION	0.9740627352239846	WITHOUT_CLASSIFICATION	0.025937264776015392	DEFECT
check to see if our "propPath" actually represents a property on the persister	WITHOUT_CLASSIFICATION	0.9998366660037246	WITHOUT_CLASSIFICATION	1.633339962754368E-4	DEFECT
these pieces are needed for usage in select clause	WITHOUT_CLASSIFICATION	0.9999876022304658	WITHOUT_CLASSIFICATION	1.2397769534292903E-5	DEFECT
used to set the type of the parent dot node	WITHOUT_CLASSIFICATION	0.9999676303387705	WITHOUT_CLASSIFICATION	3.23696612295041E-5	DEFECT
assume we do not refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.9994286932760411	WITHOUT_CLASSIFICATION	5.71306723958815E-4	DEFECT
assume we do not refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.9994286932760411	WITHOUT_CLASSIFICATION	5.71306723958815E-4	DEFECT
naked property-refs cannot be used with an aliased from element	WITHOUT_CLASSIFICATION	0.9999883017277589	WITHOUT_CLASSIFICATION	1.1698272241066837E-5	DEFECT
this piece is needed for usage in select clause	WITHOUT_CLASSIFICATION	0.9998862837993491	WITHOUT_CLASSIFICATION	1.1371620065102819E-4	DEFECT
do not over-write the column text, as that has already been "rendered" during resolve	WITHOUT_CLASSIFICATION	0.9999777448520759	WITHOUT_CLASSIFICATION	2.225514792418019E-5	DEFECT
for some reason the antlr.CommonAST initialization routines force this method to get called twice. The first time with an empty string	WITHOUT_CLASSIFICATION	0.9999977603766258	WITHOUT_CLASSIFICATION	2.2396233742386824E-6	DEFECT
Look up class name using the first identifier in the path.	WITHOUT_CLASSIFICATION	0.9998806052747099	WITHOUT_CLASSIFICATION	1.1939472529013951E-4	DEFECT
Add to the query spaces.	WITHOUT_CLASSIFICATION	0.999804177580419	WITHOUT_CLASSIFICATION	1.9582241958103255E-4	DEFECT
If the from element isn't in the same clause, create a new from element.	WITHOUT_CLASSIFICATION	0.9992580548403988	WITHOUT_CLASSIFICATION	7.419451596011832E-4	DEFECT
This is the root level node. Generate an explicit from clause at the root.	WITHOUT_CLASSIFICATION	0.9996894266407889	WITHOUT_CLASSIFICATION	3.10573359211192E-4	DEFECT
Correlated subqueries create 'special' implied from nodes because correlated subselects can't use an ANSI-style join	WITHOUT_CLASSIFICATION	0.9999494360217609	WITHOUT_CLASSIFICATION	5.056397823906731E-5	DEFECT
super-duper-classic-parser-regression-testing-mojo-magic...	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
A collection of entities...	WITHOUT_CLASSIFICATION	0.9999182267707514	WITHOUT_CLASSIFICATION	8.177322924856996E-5	DEFECT
A collection of components...	WITHOUT_CLASSIFICATION	0.9999182267707514	WITHOUT_CLASSIFICATION	8.177322924856996E-5	DEFECT
A collection of scalar elements...	WITHOUT_CLASSIFICATION	0.9998360016275818	WITHOUT_CLASSIFICATION	1.6399837241819762E-4	DEFECT
according to both the ANSI-SQL and EJB3 specs, trim can either take exactly one parameter or a variable number of parameters between 1 and 4. from the SQL spec: <trim function> ::= TRIM <left paren> <trim operands> <right paren> <trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> <trim specification> ::= LEADING | TRAILING | BOTH If only <trim specification> is omitted, BOTH is assumed; if <trim character> is omitted, space is assumed	WITHOUT_CLASSIFICATION	0.9999916541797541	WITHOUT_CLASSIFICATION	8.345820245910772E-6	DEFECT
Don't include sub-classes for implied collection joins or subquery joins.	WITHOUT_CLASSIFICATION	0.9999243443542805	WITHOUT_CLASSIFICATION	7.565564571949375E-5	DEFECT
Treat explict from elements in sub-queries properly.	WITHOUT_CLASSIFICATION	0.9995329883289453	WITHOUT_CLASSIFICATION	4.670116710547602E-4	DEFECT
( implied && DotNode.useThetaStyleImplicitJoins ) ) {	WITHOUT_CLASSIFICATION	0.9999476275075163	WITHOUT_CLASSIFICATION	5.2372492483675313E-5	DEFECT
the "root from-element" in correlated subqueries do need this piece	WITHOUT_CLASSIFICATION	0.9998310832014716	WITHOUT_CLASSIFICATION	1.6891679852828955E-4	DEFECT
Create the FROM element for the target (the elements of the collection).	WITHOUT_CLASSIFICATION	0.9999899061853608	WITHOUT_CLASSIFICATION	1.0093814639117258E-5	DEFECT
If the join is implied, then don't include sub-classes on the element.	WITHOUT_CLASSIFICATION	0.9984719717566365	WITHOUT_CLASSIFICATION	0.001528028243363486	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
The associated entity is implied, but it must be included in the FROM. The collection alias is the role.	WITHOUT_CLASSIFICATION	0.9997727868545673	WITHOUT_CLASSIFICATION	2.2721314543271484E-4	DEFECT
Tag this node as a JOIN. Don't include subclasses in the join. This is a clollection join.	WITHOUT_CLASSIFICATION	0.9990227873485118	WITHOUT_CLASSIFICATION	9.7721265148833E-4	DEFECT
Get the class name of the associated entity.	WITHOUT_CLASSIFICATION	0.9997779460011871	WITHOUT_CLASSIFICATION	2.2205399881289177E-4	DEFECT
origin, path, implied, columns, classAlias,	WITHOUT_CLASSIFICATION	0.9999024283698404	WITHOUT_CLASSIFICATION	9.757163015948684E-5	DEFECT
implied	WITHOUT_CLASSIFICATION	0.9999770016730923	WITHOUT_CLASSIFICATION	2.299832690768783E-5	DEFECT
For implied many-to-many, just add the end join.	WITHOUT_CLASSIFICATION	0.9999719899281467	WITHOUT_CLASSIFICATION	2.8010071853284523E-5	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999790867331787	WITHOUT_CLASSIFICATION	2.0913266821301831E-4	DEFECT
the standard SQL function name is current_timestamp...	WITHOUT_CLASSIFICATION	0.9999056748813681	WITHOUT_CLASSIFICATION	9.432511863195951E-5	DEFECT
This causes the factory to instantiate the desired class.	WITHOUT_CLASSIFICATION	0.998060472353183	WITHOUT_CLASSIFICATION	0.0019395276468170345	DEFECT
private Type[] sqlResultTypes;	WITHOUT_CLASSIFICATION	0.9998325255438357	WITHOUT_CLASSIFICATION	1.6747445616424502E-4	DEFECT
Frontbase has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999164131165932	WITHOUT_CLASSIFICATION	8.35868834068295E-5	DEFECT
The types represented in the SQL result set. @return The types represented in the SQL result set.	WITHOUT_CLASSIFICATION	0.9997577699638439	WITHOUT_CLASSIFICATION	2.4223003615607414E-4	DEFECT
public Type[] getSqlResultTypes() {return sqlResultTypes;}	WITHOUT_CLASSIFICATION	0.9999119538052543	WITHOUT_CLASSIFICATION	8.804619474572469E-5	DEFECT
First, collect all of the select expressions. NOTE: This must be done before invoking setScalarColumnText() because setScalarColumnText() changes the AST!!!	WITHOUT_CLASSIFICATION	0.9999826522479067	WITHOUT_CLASSIFICATION	1.7347752093289487E-5	DEFECT
First allow the actual type to control the return value. (the actual underlying sqltype could actually be different)	WITHOUT_CLASSIFICATION	0.9999861183442839	WITHOUT_CLASSIFICATION	1.3881655716093844E-5	DEFECT
sqlResultTypeList.addAll( constructorArgumentTypeList );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
If the data type is not an association type, it could not have been in the FROM clause.	WITHOUT_CLASSIFICATION	0.99994666671789	WITHOUT_CLASSIFICATION	5.3333282109939886E-5	DEFECT
sqlResultTypeList.add( type );	WITHOUT_CLASSIFICATION	0.9996181476636962	WITHOUT_CLASSIFICATION	3.8185233630379136E-4	DEFECT
Always add the type to the return type list.	WITHOUT_CLASSIFICATION	0.9999373068037987	WITHOUT_CLASSIFICATION	6.26931962013715E-5	DEFECT
add the fetched entities	WITHOUT_CLASSIFICATION	0.9998868326105558	WITHOUT_CLASSIFICATION	1.1316738944418462E-4	DEFECT
Get ready to start adding nodes.	WITHOUT_CLASSIFICATION	0.9997563712927705	WITHOUT_CLASSIFICATION	2.4362870722942858E-4	DEFECT
function support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998293093874956	WITHOUT_CLASSIFICATION	1.7069061250435846E-4	DEFECT
If there are any scalars (non-entities) selected, render the select column aliases.	WITHOUT_CLASSIFICATION	0.9999668549363849	WITHOUT_CLASSIFICATION	3.314506361503433E-5	DEFECT
sqlResultTypeList,	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
ArrayList sqlResultTypeList,	WITHOUT_CLASSIFICATION	0.9999081050594274	WITHOUT_CLASSIFICATION	9.189494057263476E-5	DEFECT
sqlResultTypes = ( Type[] ) sqlResultTypeList.toArray( new Type[sqlResultTypeList.size()] );	WITHOUT_CLASSIFICATION	0.9998663124503815	WITHOUT_CLASSIFICATION	1.336875496184591E-4	DEFECT
lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.99992070843057	WITHOUT_CLASSIFICATION	7.929156942998533E-5	DEFECT
TODO:	WITHOUT_CLASSIFICATION	0.9894410227413188	WITHOUT_CLASSIFICATION	0.01055897725868117	DEFECT
Add the type to the list of returned sqlResultTypes.	WITHOUT_CLASSIFICATION	0.9999258888215503	WITHOUT_CLASSIFICATION	7.411117844966825E-5	DEFECT
Generate an 2d array of column names, the first dimension is parallel with the return types array. The second dimension is the list of column names for each type.	WITHOUT_CLASSIFICATION	0.9999997330245631	WITHOUT_CLASSIFICATION	2.669754368318242E-7	DEFECT
Generate the select expression.	WITHOUT_CLASSIFICATION	0.9997739801269898	WITHOUT_CLASSIFICATION	2.2601987301013482E-4	DEFECT
union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998965897809976	WITHOUT_CLASSIFICATION	1.0341021900240866E-4	DEFECT
Skip 'DISTINCT' and 'ALL', so we return the first expression node.	WITHOUT_CLASSIFICATION	0.9999991558497059	WITHOUT_CLASSIFICATION	8.441502941573371E-7	DEFECT
Create SQL_TOKEN nodes for the columns.	WITHOUT_CLASSIFICATION	0.9998599177221561	WITHOUT_CLASSIFICATION	1.4008227784396426E-4	DEFECT
Generate the property select tokens.	WITHOUT_CLASSIFICATION	0.9997762924593762	WITHOUT_CLASSIFICATION	2.2370754062385606E-4	DEFECT
Get the function name node.	WITHOUT_CLASSIFICATION	0.9999580395765565	WITHOUT_CLASSIFICATION	4.19604234433681E-5	DEFECT
Method expressions in a SELECT should always be considered scalar.	WITHOUT_CLASSIFICATION	0.9987064667759528	WITHOUT_CLASSIFICATION	0.0012935332240472245	DEFECT
If this is 'elements' then create a new FROM element.	WITHOUT_CLASSIFICATION	0.9995426004632104	WITHOUT_CLASSIFICATION	4.573995367896695E-4	DEFECT
Not elements(x)	WITHOUT_CLASSIFICATION	0.9995226937318898	WITHOUT_CLASSIFICATION	4.7730626811020395E-4	DEFECT
Dialect function	WITHOUT_CLASSIFICATION	0.9997979893378528	WITHOUT_CLASSIFICATION	2.0201066214724792E-4	DEFECT
Collection 'property function'	WITHOUT_CLASSIFICATION	0.9999051816228778	WITHOUT_CLASSIFICATION	9.481837712218027E-5	DEFECT
If the constant is an IDENT, figure out what it means...	WITHOUT_CLASSIFICATION	0.9998790519671401	WITHOUT_CLASSIFICATION	1.2094803285980716E-4	DEFECT
IDENT is a class alias in the FROM.	WITHOUT_CLASSIFICATION	0.9991119496159361	WITHOUT_CLASSIFICATION	8.880503840639758E-4	DEFECT
Resolve to an identity column.	WITHOUT_CLASSIFICATION	0.9999616238201858	WITHOUT_CLASSIFICATION	3.8376179814044385E-5	DEFECT
Otherwise, it's a literal.	WITHOUT_CLASSIFICATION	0.9999014934032141	WITHOUT_CLASSIFICATION	9.850659678597774E-5	DEFECT
the name of an entity class	WITHOUT_CLASSIFICATION	0.9999451146589542	WITHOUT_CLASSIFICATION	5.488534104585251E-5	DEFECT
the class discriminator value	WITHOUT_CLASSIFICATION	0.9997484450905222	WITHOUT_CLASSIFICATION	2.5155490947778954E-4	DEFECT
Chop off the rest of the tree.	WITHOUT_CLASSIFICATION	0.9999615860208712	WITHOUT_CLASSIFICATION	3.8413979128812885E-5	DEFECT
Add a space before the display text.	WITHOUT_CLASSIFICATION	0.9999623851309718	WITHOUT_CLASSIFICATION	3.761486902817032E-5	DEFECT
Find or create the WHERE clause	WITHOUT_CLASSIFICATION	0.9999738216101037	WITHOUT_CLASSIFICATION	2.617838989632775E-5	DEFECT
child == parent.getFirstChild()	WITHOUT_CLASSIFICATION	0.9998693560462564	WITHOUT_CLASSIFICATION	1.306439537436963E-4	DEFECT
Find or create the WHERE clause	WITHOUT_CLASSIFICATION	0.9999738216101037	WITHOUT_CLASSIFICATION	2.617838989632775E-5	DEFECT
Filter conditions need to be inserted before the HQL where condition and the theta join node. This is because org.hibernate.loader.Loader binds the filter parameters first, then it binds all the HQL query parameters, see org.hibernate.loader.Loader.processFilterParameters().	WITHOUT_CLASSIFICATION	0.9936767092994082	WITHOUT_CLASSIFICATION	0.006323290700591725	DEFECT
Put the FILTERS node before the HQL condition and theta joins	WITHOUT_CLASSIFICATION	0.992825841623018	WITHOUT_CLASSIFICATION	0.007174158376982046	DEFECT
add the current fragment to the FILTERS node	WITHOUT_CLASSIFICATION	0.9998916840899038	WITHOUT_CLASSIFICATION	1.083159100962764E-4	DEFECT
Create a new THETA_JOINS node as a parent of all filters	WITHOUT_CLASSIFICATION	0.9999648995762428	WITHOUT_CLASSIFICATION	3.5100423757290155E-5	DEFECT
Put the THETA_JOINS node before the HQL condition, after the filters.	WITHOUT_CLASSIFICATION	0.9996095326824235	WITHOUT_CLASSIFICATION	3.904673175765677E-4	DEFECT
add the current fragment to the THETA_JOINS node	WITHOUT_CLASSIFICATION	0.9998916840899038	WITHOUT_CLASSIFICATION	1.083159100962764E-4	DEFECT
First, try to get the persister using the given name directly.	WITHOUT_CLASSIFICATION	0.9999951374591578	WITHOUT_CLASSIFICATION	4.86254084225029E-6	DEFECT
unable to locate it using this name	WITHOUT_CLASSIFICATION	0.9995541820331072	WITHOUT_CLASSIFICATION	4.458179668927153E-4	DEFECT
If that didn't work, try using the 'import' name.	WITHOUT_CLASSIFICATION	0.9999617540542608	WITHOUT_CLASSIFICATION	3.824594573924555E-5	DEFECT
Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)	WITHOUT_CLASSIFICATION	0.9999066973909937	WITHOUT_CLASSIFICATION	9.330260900622416E-5	DEFECT
locate the registered function by the given name	WITHOUT_CLASSIFICATION	0.9999748341416417	WITHOUT_CLASSIFICATION	2.5165858358312735E-5	DEFECT
determine the type of the first argument...	WITHOUT_CLASSIFICATION	0.9999508651067985	WITHOUT_CLASSIFICATION	4.9134893201545707E-5	DEFECT
Use the DOT node to emit the first column name. Create the column names, folled by the column aliases.	WITHOUT_CLASSIFICATION	0.999990929348103	WITHOUT_CLASSIFICATION	9.07065189698147E-6	DEFECT
Note: this simply constructs a "raw" SQL_TOKEN representing the where fragment and injects this into the tree. This "works"; however it is probably not the best long-term solution. At some point we probably want to apply an additional grammar to properly tokenize this where fragment into constituent parts focused on the operators embedded within the fragment.	WITHOUT_CLASSIFICATION	0.9982939109332738	WITHOUT_CLASSIFICATION	0.0017060890667262882	DEFECT
Append the text of the current node.	WITHOUT_CLASSIFICATION	0.9999813506657916	WITHOUT_CLASSIFICATION	1.8649334208369682E-5	DEFECT
If the node has a first child, recurse into the first child.	WITHOUT_CLASSIFICATION	0.999770632992892	WITHOUT_CLASSIFICATION	2.2936700710809543E-4	DEFECT
If there is a second child (RHS), recurse into that child.	WITHOUT_CLASSIFICATION	0.9979241102946397	WITHOUT_CLASSIFICATION	0.002075889705360206	DEFECT
Iterate through the alias,JoinSequence pairs and generate SQL token nodes.	WITHOUT_CLASSIFICATION	0.9998868439056037	WITHOUT_CLASSIFICATION	1.1315609439627363E-4	DEFECT
If the from element represents a JOIN_FRAGMENT and it is a theta-style join, convert its type from JOIN_FRAGMENT to FROM_FRAGMENT	WITHOUT_CLASSIFICATION	0.9997537929107367	WITHOUT_CLASSIFICATION	2.462070892631568E-4	DEFECT
this is used during SqlGenerator processing	WITHOUT_CLASSIFICATION	0.9998444488153888	WITHOUT_CLASSIFICATION	1.555511846112085E-4	DEFECT
If there is a FROM fragment and the FROM element is an explicit, then add the from part.	WITHOUT_CLASSIFICATION	0.9998485613448475	WITHOUT_CLASSIFICATION	1.5143865515265356E-4	DEFECT
&& StringHelper.isNotEmpty( frag )	WITHOUT_CLASSIFICATION	0.9998259277479427	WITHOUT_CLASSIFICATION	1.7407225205723988E-4	DEFECT
The FROM fragment will probably begin with ', '. Remove this if it is present.	WITHOUT_CLASSIFICATION	0.998019181447454	WITHOUT_CLASSIFICATION	0.0019808185525460255	DEFECT
This uses a PathExpressionParser but notice that compound paths are not valid, only bare names and simple paths:	WITHOUT_CLASSIFICATION	0.998513053646776	WITHOUT_CLASSIFICATION	0.0014869463532239998	DEFECT
SELECT p FROM p IN CLASS eg.Person ORDER BY p.Name, p.Address, p	WITHOUT_CLASSIFICATION	0.9998374522800683	WITHOUT_CLASSIFICATION	1.6254771993164693E-4	DEFECT
The reason for this is SQL doesn't let you sort by an expression you are not returning in the result set.	WITHOUT_CLASSIFICATION	0.9979492353950008	WITHOUT_CLASSIFICATION	0.0020507646049991416	DEFECT
named query parameter	WITHOUT_CLASSIFICATION	0.9996839438310434	WITHOUT_CLASSIFICATION	3.1605616895660603E-4	DEFECT
default mode	WITHOUT_CLASSIFICATION	0.9999043335477938	WITHOUT_CLASSIFICATION	9.566645220615874E-5	DEFECT
QueryJoinFragment join = q.createJoinFragment(useThetaStyleJoin);	WITHOUT_CLASSIFICATION	0.9998460381844819	WITHOUT_CLASSIFICATION	1.539618155179942E-4	DEFECT
reset the dotcount (but not the path) after reset!	WITHOUT_CLASSIFICATION	0.9989695217140914	WITHOUT_CLASSIFICATION	0.0010304782859085818	DEFECT
after reset!	WITHOUT_CLASSIFICATION	0.9998804655786826	WITHOUT_CLASSIFICATION	1.1953442131739899E-4	DEFECT
we don't need to worry about any condition in the ON clause here (toFromFragmentString), since anything in the ON condition is already applied to the whole query	WITHOUT_CLASSIFICATION	0.6619971817425787	WITHOUT_CLASSIFICATION	0.33800281825742134	DEFECT
bit_length feels a bit broken to me. We have to cast to char in order to pass when a numeric value is supplied. But of course the answers given will be wildly different for these two datatypes. 1234.5678 will be 9 bytes as a char string but will be 8 or 16 bytes as a true numeric. Jay Nance 2006-09-22	WITHOUT_CLASSIFICATION	0.9891531247425587	WITHOUT_CLASSIFICATION	0.010846875257441324	DEFECT
dotcount>=2	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Do the corresponding RHS	WITHOUT_CLASSIFICATION	0.9999791699628247	WITHOUT_CLASSIFICATION	2.083003717530493E-5	DEFECT
if its "id"	WITHOUT_CLASSIFICATION	0.9998338579957056	WITHOUT_CLASSIFICATION	1.66142004294461E-4	DEFECT
or its the id property name	WITHOUT_CLASSIFICATION	0.9999331726254539	WITHOUT_CLASSIFICATION	6.682737454606794E-5	DEFECT
join = q.createJoinFragment(useThetaStyleJoin);	WITHOUT_CLASSIFICATION	0.9998460381844819	WITHOUT_CLASSIFICATION	1.539618155179942E-4	DEFECT
important!!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
String[] keyCols = collPersister.getKeyColumnNames();	WITHOUT_CLASSIFICATION	0.9998457451868941	WITHOUT_CLASSIFICATION	1.5425481310596623E-4	DEFECT
an association	WITHOUT_CLASSIFICATION	0.9999791642460599	WITHOUT_CLASSIFICATION	2.083575394009812E-5	DEFECT
allow index() function:	WITHOUT_CLASSIFICATION	0.999932118824348	WITHOUT_CLASSIFICATION	6.788117565206765E-5	DEFECT
here assume SQLServer2005 using snapshot isolation, which does not have this problem	WITHOUT_CLASSIFICATION	0.9578217699941992	WITHOUT_CLASSIFICATION	0.042178230005800836	DEFECT
The reason for this is SQL doesn't let you sort by an expression you are not returning in the result set.	WITHOUT_CLASSIFICATION	0.9979492353950008	WITHOUT_CLASSIFICATION	0.0020507646049991416	DEFECT
many-to-many	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
collections of values	WITHOUT_CLASSIFICATION	0.9999346179590418	WITHOUT_CLASSIFICATION	6.53820409582518E-5	DEFECT
opening paren in new Foo ( ... )	WITHOUT_CLASSIFICATION	0.9998722051163313	WITHOUT_CLASSIFICATION	1.2779488366876463E-4	DEFECT
if we are inside a new Result(), but not inside a nested function	WITHOUT_CLASSIFICATION	0.9993011489380162	WITHOUT_CLASSIFICATION	6.988510619837094E-4	DEFECT
special case	WITHOUT_CLASSIFICATION	0.9998073319780418	WITHOUT_CLASSIFICATION	1.926680219580985E-4	DEFECT
the name of an SQL function	WITHOUT_CLASSIFICATION	0.9999887014718827	WITHOUT_CLASSIFICATION	1.1298528117378714E-5	DEFECT
null child could occur for no from clause in a filter	WITHOUT_CLASSIFICATION	0.9999938485778399	WITHOUT_CLASSIFICATION	6.151422160038404E-6	DEFECT
this is basically a copy/paste of OrderByParser ... might be worth refactoring	WITHOUT_CLASSIFICATION	0.9940609347564583	WITHOUT_CLASSIFICATION	0.005939065243541639	DEFECT
SELECT p FROM p IN CLASS eg.Person GROUP BY p.Name, p.Address, p	WITHOUT_CLASSIFICATION	0.9998351910482437	WITHOUT_CLASSIFICATION	1.6480895175625786E-4	DEFECT
return aliases not supported in classic translator!	WITHOUT_CLASSIFICATION	0.999346313884718	WITHOUT_CLASSIFICATION	6.536861152819877E-4	DEFECT
register collection role	WITHOUT_CLASSIFICATION	0.9999608079327621	WITHOUT_CLASSIFICATION	3.919206723793903E-5	DEFECT
The keyword used to specify an identity column, if identity column key generation is supported.	WITHOUT_CLASSIFICATION	0.9999935006931395	WITHOUT_CLASSIFICATION	6.4993068605040054E-6	DEFECT
.getElementPropertyMapping();	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
crossJoins.add(name);	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
ie no select clause in HQL	WITHOUT_CLASSIFICATION	0.9999835402346092	WITHOUT_CLASSIFICATION	1.6459765390815664E-5	DEFECT
initialize the Set of queried identifier spaces (ie. tables)	WITHOUT_CLASSIFICATION	0.9998618207363141	WITHOUT_CLASSIFICATION	1.3817926368592742E-4	DEFECT
ie. no select clause	WITHOUT_CLASSIFICATION	0.9999779938987955	WITHOUT_CLASSIFICATION	2.2006101204493617E-5	DEFECT
there _was_ a select clause	WITHOUT_CLASSIFICATION	0.9999198677326292	WITHOUT_CLASSIFICATION	8.013226737085468E-5	DEFECT
return the concrete type, or the underlying type if a concrete type was not specified	WITHOUT_CLASSIFICATION	0.999939086417433	WITHOUT_CLASSIFICATION	6.0913582567009076E-5	DEFECT
many-to-many	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
q.addCollection(collectionName, collectionRole);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
classic parser does not support bulk manipulation statements	WITHOUT_CLASSIFICATION	0.9975406623135212	WITHOUT_CLASSIFICATION	0.002459337686478722	DEFECT
can't cache this stuff either (per-invocation)	WITHOUT_CLASSIFICATION	0.9996438006770093	WITHOUT_CLASSIFICATION	3.5619932299077423E-4	DEFECT
unfortunately this stuff can't be cached because it is per-invocation, not constant for the QueryTranslator instance	WITHOUT_CLASSIFICATION	0.9989382839662476	WITHOUT_CLASSIFICATION	0.001061716033752347	DEFECT
This is the legacy behaviour for HQL queries...	WITHOUT_CLASSIFICATION	0.9984301001151539	WITHOUT_CLASSIFICATION	0.0015698998848460873	DEFECT
not known!	WITHOUT_CLASSIFICATION	0.9998541806878211	WITHOUT_CLASSIFICATION	1.4581931217892778E-4	DEFECT
not known!	WITHOUT_CLASSIFICATION	0.9998541806878211	WITHOUT_CLASSIFICATION	1.4581931217892778E-4	DEFECT
we have the form: trim(trimSource) so we trim leading and trailing spaces EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9999618621103937	WITHOUT_CLASSIFICATION	3.8137889606342914E-5	DEFECT
not known!	WITHOUT_CLASSIFICATION	0.9998541806878211	WITHOUT_CLASSIFICATION	1.4581931217892778E-4	DEFECT
not known!	WITHOUT_CLASSIFICATION	0.9998541806878211	WITHOUT_CLASSIFICATION	1.4581931217892778E-4	DEFECT
Need this, since join condition can appear inside parens!	WITHOUT_CLASSIFICATION	0.9982735374564057	WITHOUT_CLASSIFICATION	0.001726462543594336	DEFECT
tokens that close a sub expression tokens that open a sub expression tokens that would indicate a sub expression is a boolean expression	WITHOUT_CLASSIFICATION	0.9998079500205638	WITHOUT_CLASSIFICATION	1.9204997943626494E-4	DEFECT
expressionTerminators.add(","); deliberately excluded	WITHOUT_CLASSIFICATION	0.9998266468801177	WITHOUT_CLASSIFICATION	1.7335311988236668E-4	DEFECT
expressionOpeners.add(","); deliberately excluded	WITHOUT_CLASSIFICATION	0.9998266468801177	WITHOUT_CLASSIFICATION	1.7335311988236668E-4	DEFECT
we have the form: trim(from trimSource). This is functionally equivalent to trim(trimSource) EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9980626143067779	WITHOUT_CLASSIFICATION	0.0019373856932220655	DEFECT
otherwise, a trim-specification and/or a trim-character have been specified; we need to decide which options are present and "do the right thing" should leading trim-characters be trimmed? should trailing trim-characters be trimmed? the trim-character (what is to be trimmed off?) the trim-source (from where should it be trimmed?)	WITHOUT_CLASSIFICATION	0.9999859396133859	WITHOUT_CLASSIFICATION	1.406038661402464E-5	DEFECT
Inside a BETWEEN ... AND ... expression	WITHOUT_CLASSIFICATION	0.9997833945904844	WITHOUT_CLASSIFICATION	2.1660540951554756E-4	DEFECT
were an odd or even number of NOTs encountered the join string built up by compound paths inside this expression a flag indicating if the subexpression is known to be boolean	WITHOUT_CLASSIFICATION	0.9998617117084659	WITHOUT_CLASSIFICATION	1.382882915341493E-4	DEFECT
ie. a many-to-many	WITHOUT_CLASSIFICATION	0.9998269260937367	WITHOUT_CLASSIFICATION	1.730739062633163E-4	DEFECT
Cope with [,]	WITHOUT_CLASSIFICATION	0.9998596874836998	WITHOUT_CLASSIFICATION	1.4031251630018302E-4	DEFECT
Cope with a continued path expression (ie. ].baz)	WITHOUT_CLASSIFICATION	0.9999218271672471	WITHOUT_CLASSIFICATION	7.817283275295153E-5	DEFECT
NOTE: early return	WITHOUT_CLASSIFICATION	0.9999732283876541	WITHOUT_CLASSIFICATION	2.677161234581969E-5	DEFECT
Cope with a subselect	WITHOUT_CLASSIFICATION	0.999905768074014	WITHOUT_CLASSIFICATION	9.423192598602165E-5	DEFECT
Cope with special cases of AND, NOT, ()	WITHOUT_CLASSIFICATION	0.9998989939341777	WITHOUT_CLASSIFICATION	1.0100606582229777E-4	DEFECT
Close extra brackets we opened	WITHOUT_CLASSIFICATION	0.9999201723664577	WITHOUT_CLASSIFICATION	7.982763354229163E-5	DEFECT
take note when this is a boolean expression	WITHOUT_CLASSIFICATION	0.9993067277398409	WITHOUT_CLASSIFICATION	6.932722601591299E-4	DEFECT
assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.999977135424313	WITHOUT_CLASSIFICATION	2.2864575686937835E-5	DEFECT
process a token, mapping OO path expressions to SQL expressions	WITHOUT_CLASSIFICATION	0.9999532645390685	WITHOUT_CLASSIFICATION	4.673546093149505E-5	DEFECT
Open any extra brackets we might need.	WITHOUT_CLASSIFICATION	0.9996010043200434	WITHOUT_CLASSIFICATION	3.9899567995650237E-4	DEFECT
Cope with special cases of AND, NOT, )	WITHOUT_CLASSIFICATION	0.9998504069524983	WITHOUT_CLASSIFICATION	1.495930475017222E-4	DEFECT
the next one up must also be	WITHOUT_CLASSIFICATION	0.9998063479128105	WITHOUT_CLASSIFICATION	1.9365208718946265E-4	DEFECT
Add any joins	WITHOUT_CLASSIFICATION	0.999958998854856	WITHOUT_CLASSIFICATION	4.100114514406434E-5	DEFECT
assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.999977135424313	WITHOUT_CLASSIFICATION	2.2864575686937835E-5	DEFECT
named query parameter	WITHOUT_CLASSIFICATION	0.9996839438310434	WITHOUT_CLASSIFICATION	3.1605616895660603E-4	DEFECT
path expression	WITHOUT_CLASSIFICATION	0.999924435367335	WITHOUT_CLASSIFICATION	7.556463266493251E-5	DEFECT
saves / updates don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9990248576812646	WITHOUT_CLASSIFICATION	9.751423187353738E-4	DEFECT
persists don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9984290383969633	WITHOUT_CLASSIFICATION	0.0015709616030366656	DEFECT
anything else	WITHOUT_CLASSIFICATION	0.9993428725106891	WITHOUT_CLASSIFICATION	6.57127489310865E-4	DEFECT
the path expression continues after a ]	WITHOUT_CLASSIFICATION	0.9999515967329797	WITHOUT_CLASSIFICATION	4.84032670201506E-5	DEFECT
careful with this!	WITHOUT_CLASSIFICATION	0.9998574567654934	WITHOUT_CLASSIFICATION	1.4254323450656816E-4	DEFECT
the path expression ends at the ]	WITHOUT_CLASSIFICATION	0.9999379771140015	WITHOUT_CLASSIFICATION	6.202288599855929E-5	DEFECT
"finish off" the join	WITHOUT_CLASSIFICATION	0.9999358687585242	WITHOUT_CLASSIFICATION	6.413124147571568E-5	DEFECT
NOTICE: no " or . since they are part of (compound) identifiers	WITHOUT_CLASSIFICATION	0.9999982281633895	WITHOUT_CLASSIFICATION	1.7718366105993196E-6	DEFECT
cannot instantiate	WITHOUT_CLASSIFICATION	0.9998678120053691	WITHOUT_CLASSIFICATION	1.321879946308466E-4	DEFECT
start by looking for HQL keywords...	WITHOUT_CLASSIFICATION	0.9998455017620447	WITHOUT_CLASSIFICATION	1.544982379554417E-4	DEFECT
inner joins can be abbreviated to 'join'	WITHOUT_CLASSIFICATION	0.9998318816829925	WITHOUT_CLASSIFICATION	1.6811831700740064E-4	DEFECT
'outer' is optional and is ignored	WITHOUT_CLASSIFICATION	0.9998643383935946	WITHOUT_CLASSIFICATION	1.3566160640545626E-4	DEFECT
now anything that is not a HQL keyword	WITHOUT_CLASSIFICATION	0.9927646660208733	WITHOUT_CLASSIFICATION	0.00723533397912661	DEFECT
process the "old" HQL style where aliases appear _first_ ie. using the IN or IN CLASS constructions	WITHOUT_CLASSIFICATION	0.9999551568006917	WITHOUT_CLASSIFICATION	4.484319930823917E-5	DEFECT
treat it as a classname	WITHOUT_CLASSIFICATION	0.9999189386213835	WITHOUT_CLASSIFICATION	8.106137861649731E-5	DEFECT
treat it as a path expression	WITHOUT_CLASSIFICATION	0.9999628569475351	WITHOUT_CLASSIFICATION	3.714305246502265E-5	DEFECT
starts with the name of a mapped class (new style)	WITHOUT_CLASSIFICATION	0.9997196685897057	WITHOUT_CLASSIFICATION	2.803314102943135E-4	DEFECT
starts with a path expression (new style)	WITHOUT_CLASSIFICATION	0.999919495593018	WITHOUT_CLASSIFICATION	8.050440698198464E-5	DEFECT
allow ODMG OQL style: from Person p, p.cars c	WITHOUT_CLASSIFICATION	0.9999124843290692	WITHOUT_CLASSIFICATION	8.751567093081736E-5	DEFECT
handle quoted strings	WITHOUT_CLASSIFICATION	0.9998693621790467	WITHOUT_CLASSIFICATION	1.3063782095327532E-4	DEFECT
Object insertions, updates, and deletions have list semantics because they must happen in the right order so as to respect referential integrity	WITHOUT_CLASSIFICATION	0.9999990095935174	WITHOUT_CLASSIFICATION	9.904064825575602E-7	DEFECT
"finish off" the join	WITHOUT_CLASSIFICATION	0.9999358687585242	WITHOUT_CLASSIFICATION	6.413124147571568E-5	DEFECT
ignore whitespace	WITHOUT_CLASSIFICATION	0.9999107789234866	WITHOUT_CLASSIFICATION	8.922107651347479E-5	DEFECT
do replacements	WITHOUT_CLASSIFICATION	0.999880636023513	WITHOUT_CLASSIFICATION	1.1936397648695003E-4	DEFECT
handle HQL2 collection syntax	WITHOUT_CLASSIFICATION	0.9999817120697283	WITHOUT_CLASSIFICATION	1.8287930271685015E-5	DEFECT
uuid.hex is deprecated	WITHOUT_CLASSIFICATION	0.9998859859032637	WITHOUT_CLASSIFICATION	1.140140967363012E-4	DEFECT
AbstractSelectingDelegate impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
hilo params	WITHOUT_CLASSIFICATION	0.9998390587774295	WITHOUT_CLASSIFICATION	1.6094122257045518E-4	DEFECT
sql = query;	WITHOUT_CLASSIFICATION	0.9998784412594578	WITHOUT_CLASSIFICATION	1.2155874054215363E-4	DEFECT
performance opt	WITHOUT_CLASSIFICATION	0.9997499569599763	WITHOUT_CLASSIFICATION	2.5004304002374146E-4	DEFECT
sql = update;	WITHOUT_CLASSIFICATION	0.9998781346483252	WITHOUT_CLASSIFICATION	1.218653516746984E-4	DEFECT
hilo config	WITHOUT_CLASSIFICATION	0.9998358965700813	WITHOUT_CLASSIFICATION	1.6410342991862305E-4	DEFECT
so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999821315713795	WITHOUT_CLASSIFICATION	1.7868428620599234E-5	DEFECT
don't allow comments on these insert statements as comments totally blow up the Oracle getGeneratedKeys "support" :(	WITHOUT_CLASSIFICATION	0.9999230266534971	WITHOUT_CLASSIFICATION	7.697334650285521E-5	DEFECT
abort the save (the object is already saved by a circular cascade)	WITHOUT_CLASSIFICATION	0.9999777922708338	WITHOUT_CLASSIFICATION	2.2207729166179692E-5	DEFECT
throw new IdentifierGenerationException("save associated object first, or disable cascade for inverse association");	WITHOUT_CLASSIFICATION	0.999763838598572	WITHOUT_CLASSIFICATION	2.3616140142796263E-4	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
do nothing to avoid a lazy property initialization	WITHOUT_CLASSIFICATION	0.9999680147338312	WITHOUT_CLASSIFICATION	3.198526616878501E-5	DEFECT
keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9998715546253691	WITHOUT_CLASSIFICATION	1.2844537463096824E-4	DEFECT
so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999821315713795	WITHOUT_CLASSIFICATION	1.7868428620599234E-5	DEFECT
do nothing until we hit the rsult set containing the generated id	WITHOUT_CLASSIFICATION	0.9999891057182334	WITHOUT_CLASSIFICATION	1.0894281766634706E-5	DEFECT
COLUMN and TABLE should be renamed but it would break the public API	WITHOUT_CLASSIFICATION	0.998396357891217	WITHOUT_CLASSIFICATION	0.001603642108783107	DEFECT
Loaded entity instances, by EntityKey	WITHOUT_CLASSIFICATION	0.9997920806914151	WITHOUT_CLASSIFICATION	2.0791930858495055E-4	DEFECT
if the given name is un-qualified we may neen to qualify it	WITHOUT_CLASSIFICATION	0.9999191003005612	WITHOUT_CLASSIFICATION	8.089969943886154E-5	DEFECT
the default...	WITHOUT_CLASSIFICATION	0.9998805998335429	WITHOUT_CLASSIFICATION	1.194001664570495E-4	DEFECT
unfortunately not really safe to normalize this to 1 as an initial value like we do the others because we would not be able to control this if we are using a sequence...	WITHOUT_CLASSIFICATION	0.9998910502079433	WITHOUT_CLASSIFICATION	1.0894979205663614E-4	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
Identity map of CollectionEntry instances, by the collection wrapper	WITHOUT_CLASSIFICATION	0.9998771208836975	WITHOUT_CLASSIFICATION	1.228791163024517E-4	DEFECT
general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998086198215139	WITHOUT_CLASSIFICATION	1.9138017848610873E-4	DEFECT
table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998247746353438	WITHOUT_CLASSIFICATION	1.7522536465617412E-4	DEFECT
Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999624947618377	WITHOUT_CLASSIFICATION	3.750523816229403E-4	DEFECT
IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999624947618377	WITHOUT_CLASSIFICATION	3.750523816229403E-4	DEFECT
PersistentIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999624947618377	WITHOUT_CLASSIFICATION	3.750523816229403E-4	DEFECT
prepare and execute the insert	WITHOUT_CLASSIFICATION	0.9999574046621811	WITHOUT_CLASSIFICATION	4.259533781895372E-5	DEFECT
prepare and execute the insert	WITHOUT_CLASSIFICATION	0.9999574046621811	WITHOUT_CLASSIFICATION	4.259533781895372E-5	DEFECT
fetch the generated id in a separate query	WITHOUT_CLASSIFICATION	0.9997499013772365	WITHOUT_CLASSIFICATION	2.5009862276344376E-4	DEFECT
we just hit the last position	WITHOUT_CLASSIFICATION	0.9999960762614678	WITHOUT_CLASSIFICATION	3.923738532174363E-6	DEFECT
scroll ahead	WITHOUT_CLASSIFICATION	0.9995778204831566	WITHOUT_CLASSIFICATION	4.221795168433948E-4	DEFECT
scroll backward	WITHOUT_CLASSIFICATION	0.9996682544842382	WITHOUT_CLASSIFICATION	3.31745515761861E-4	DEFECT
we have not yet hit the last result...	WITHOUT_CLASSIFICATION	0.9975410157576936	WITHOUT_CLASSIFICATION	0.002458984242306438	DEFECT
Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997915321170872	WITHOUT_CLASSIFICATION	2.0846788291275123E-4	DEFECT
State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998111106450662	WITHOUT_CLASSIFICATION	1.8888935493370672E-4	DEFECT
Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
do this when all the properties are updateable since there is a certain likelihood that the information will already be snapshot-cached.	WITHOUT_CLASSIFICATION	0.999062459691379	WITHOUT_CLASSIFICATION	9.375403086209511E-4	DEFECT
Inner classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999469457575212	WITHOUT_CLASSIFICATION	5.305424247883288E-5	DEFECT
Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997915321170872	WITHOUT_CLASSIFICATION	2.0846788291275123E-4	DEFECT
State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998111106450662	WITHOUT_CLASSIFICATION	1.8888935493370672E-4	DEFECT
Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
Caches	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
Generators:	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
cache region is defined by the root-class in the hierarchy...	WITHOUT_CLASSIFICATION	0.9999665883154708	WITHOUT_CLASSIFICATION	3.341168452915734E-5	DEFECT
check if the detached object being merged is the parent	WITHOUT_CLASSIFICATION	0.9999570693310639	WITHOUT_CLASSIFICATION	4.293066893615139E-5	DEFECT
after all persisters and named queries are registered	WITHOUT_CLASSIFICATION	0.9999866066265604	WITHOUT_CLASSIFICATION	1.3393373439689903E-5	DEFECT
if we get here, it is possible that we have a proxy 'in the way' of the merge map resolution... NOTE: decided to put this here rather than in the above loop as I was nervous about the performance of the loop-in-loop especially considering this is far more likely the 'edge case'	WITHOUT_CLASSIFICATION	0.9978275113076915	WITHOUT_CLASSIFICATION	0.0021724886923083545	DEFECT
JNDI + Serialization:	WITHOUT_CLASSIFICATION	0.9999031508430903	WITHOUT_CLASSIFICATION	9.684915690969878E-5	DEFECT
checking for named queries	WITHOUT_CLASSIFICATION	0.9999086709660654	WITHOUT_CLASSIFICATION	9.132903393466773E-5	DEFECT
stats	WITHOUT_CLASSIFICATION	0.9999773207224089	WITHOUT_CLASSIFICATION	2.267927759109269E-5	DEFECT
EntityNotFoundDelegate	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
Check named HQL queries	WITHOUT_CLASSIFICATION	0.9999652671704634	WITHOUT_CLASSIFICATION	3.473282953667472E-5	DEFECT
this will throw an error if there's something wrong.	WITHOUT_CLASSIFICATION	0.9992801440221796	WITHOUT_CLASSIFICATION	7.19855977820378E-4	DEFECT
prevents this session from adding things to cache	WITHOUT_CLASSIFICATION	0.995960693984298	WITHOUT_CLASSIFICATION	0.004039306015702042	DEFECT
from javax.naming.Referenceable	WITHOUT_CLASSIFICATION	0.9997456718325246	WITHOUT_CLASSIFICATION	2.5432816747547745E-4	DEFECT
look for the instance by uuid	WITHOUT_CLASSIFICATION	0.9999731394556336	WITHOUT_CLASSIFICATION	2.686054436647244E-5	DEFECT
for a dynamic-class	WITHOUT_CLASSIFICATION	0.9998357928588244	WITHOUT_CLASSIFICATION	1.6420714117564464E-4	DEFECT
test this entity to see if we must query it	WITHOUT_CLASSIFICATION	0.9994558803646898	WITHOUT_CLASSIFICATION	5.441196353101062E-4	DEFECT
NOTE EARLY EXIT	WITHOUT_CLASSIFICATION	0.9998772999201709	WITHOUT_CLASSIFICATION	1.2270007982914232E-4	DEFECT
for backward-compatability	WITHOUT_CLASSIFICATION	0.9998995958473759	WITHOUT_CLASSIFICATION	1.0040415262408876E-4	DEFECT
ignore this error for now	WITHOUT_CLASSIFICATION	0.9998554279817714	WITHOUT_CLASSIFICATION	1.445720182285959E-4	DEFECT
to stop the class from being unloaded	WITHOUT_CLASSIFICATION	0.9989869113379447	WITHOUT_CLASSIFICATION	0.0010130886620552482	DEFECT
in case we were deserialized in a different JVM, look for an instance with the same name (alternatively we could do an actual JNDI lookup here....)	WITHOUT_CLASSIFICATION	0.9999974332688131	WITHOUT_CLASSIFICATION	2.5667311868828025E-6	DEFECT
must add to JNDI _after_ adding to HashMaps, because some JNDI servers use serialization	WITHOUT_CLASSIFICATION	0.9998825813824244	WITHOUT_CLASSIFICATION	1.174186175756287E-4	DEFECT
Make sure this is a defined parameter and check the incoming value type	WITHOUT_CLASSIFICATION	0.9999949598563852	WITHOUT_CLASSIFICATION	5.040143614836415E-6	DEFECT
for each of the defined parameters, make sure its value has been set	WITHOUT_CLASSIFICATION	0.9999976744424448	WITHOUT_CLASSIFICATION	2.3255575552432514E-6	DEFECT
we never need to apply locks to the SQL	WITHOUT_CLASSIFICATION	0.9975282800008619	WITHOUT_CLASSIFICATION	0.0024717199991381505	DEFECT
inserts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997881486659724	WITHOUT_CLASSIFICATION	2.118513340276553E-4	DEFECT
deletes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997937590150028	WITHOUT_CLASSIFICATION	2.0624098499715345E-4	DEFECT
during deserialization, we need to reconnect all proxies and collections to this session, as well as the EntityEntry and CollectionEntry instances; these associations are transient because serialization is used for different things.	WITHOUT_CLASSIFICATION	0.9999996870448297	WITHOUT_CLASSIFICATION	3.129551703181548E-7	DEFECT
updates ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998206751441058	WITHOUT_CLASSIFICATION	1.7932485589427746E-4	DEFECT
loading ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9994902696131739	WITHOUT_CLASSIFICATION	5.09730386826187E-4	DEFECT
final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9998987407217517	WITHOUT_CLASSIFICATION	1.012592782482527E-4	DEFECT
final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9998987407217517	WITHOUT_CLASSIFICATION	1.012592782482527E-4	DEFECT
first, try to load it from the temp PC associated to this SS	WITHOUT_CLASSIFICATION	0.9998382582928452	WITHOUT_CLASSIFICATION	1.6174170715476435E-4	DEFECT
if the metadata allowed proxy creation and caller did not request forceful eager loading, generate a proxy	WITHOUT_CLASSIFICATION	0.997356950110474	WITHOUT_CLASSIFICATION	0.0026430498895259552	DEFECT
otherwise immediately materialize it	WITHOUT_CLASSIFICATION	0.9998546446187022	WITHOUT_CLASSIFICATION	1.4535538129775043E-4	DEFECT
/	WITHOUT_CLASSIFICATION	0.9999819863298791	WITHOUT_CLASSIFICATION	1.801367012079905E-5	DEFECT
no auto-flushing to support in stateless session	WITHOUT_CLASSIFICATION	0.999968887563251	WITHOUT_CLASSIFICATION	3.1112436749097564E-5	DEFECT
after setting values to object, entityMode	WITHOUT_CLASSIFICATION	0.9999433747862303	WITHOUT_CLASSIFICATION	5.6625213769648556E-5	DEFECT
for EJB3	WITHOUT_CLASSIFICATION	0.9999779540348315	WITHOUT_CLASSIFICATION	2.2045965168489337E-5	DEFECT
just ignore	WITHOUT_CLASSIFICATION	0.9999805396274584	WITHOUT_CLASSIFICATION	1.9460372541658933E-5	DEFECT
do a check	WITHOUT_CLASSIFICATION	0.9999934793094792	WITHOUT_CLASSIFICATION	6.5206905207462365E-6	DEFECT
saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999837111881657	WITHOUT_CLASSIFICATION	1.628881183429273E-4	DEFECT
lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998346179741068	WITHOUT_CLASSIFICATION	1.6538202589312366E-4	DEFECT
saveOrUpdateCopy() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998351231309481	WITHOUT_CLASSIFICATION	1.6487686905175303E-4	DEFECT
load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
do not auto-flush while outside a transaction	WITHOUT_CLASSIFICATION	0.9983052957341405	WITHOUT_CLASSIFICATION	0.0016947042658595202	DEFECT
this is an internal error of some sort...	WITHOUT_CLASSIFICATION	0.9997071770647786	WITHOUT_CLASSIFICATION	2.9282293522132257E-4	DEFECT
stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9997433737678693	WITHOUT_CLASSIFICATION	2.5662623213077243E-4	DEFECT
only collections belonging to deleted entities are allowed to be dereferenced in the case of orphan delete	WITHOUT_CLASSIFICATION	0.9989960697085412	WITHOUT_CLASSIFICATION	0.0010039302914588912	DEFECT
if it was previously unreferenced, we need to flush in order to get its state into the database in order to execute query	WITHOUT_CLASSIFICATION	0.9999273307515076	WITHOUT_CLASSIFICATION	7.266924849239558E-5	DEFECT
not for internal use:	WITHOUT_CLASSIFICATION	0.9996552808676594	WITHOUT_CLASSIFICATION	3.4471913234056993E-4	DEFECT
otherwise, we only need to flush if there are in-memory changes to the queried tables	WITHOUT_CLASSIFICATION	0.9998849481076515	WITHOUT_CLASSIFICATION	1.1505189234845895E-4	DEFECT
might need to run a different filter entirely after the flush because the collection role may have changed	WITHOUT_CLASSIFICATION	0.9998862072552901	WITHOUT_CLASSIFICATION	1.1379274470981324E-4	DEFECT
stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9997433737678693	WITHOUT_CLASSIFICATION	2.5662623213077243E-4	DEFECT
stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9997433737678693	WITHOUT_CLASSIFICATION	2.5662623213077243E-4	DEFECT
if it is initialized, see if the underlying instance is contained, since we need to account for the fact that it might have been evicted	WITHOUT_CLASSIFICATION	0.9999640018433547	WITHOUT_CLASSIFICATION	3.5998156645336517E-5	DEFECT
basically just an adapted copy of find(CriteriaImpl)	WITHOUT_CLASSIFICATION	0.9999700207633644	WITHOUT_CLASSIFICATION	2.9979236635532443E-5	DEFECT
it is possible for this method to be called during flush processing, so make certain that we do not accidently initialize an uninitialized proxy	WITHOUT_CLASSIFICATION	0.9997941137709877	WITHOUT_CLASSIFICATION	2.058862290121676E-4	DEFECT
nothing to do in a stateful session	WITHOUT_CLASSIFICATION	0.9999441168922316	WITHOUT_CLASSIFICATION	5.588310776836366E-5	DEFECT
ignore	WITHOUT_CLASSIFICATION	0.9999855898485884	WITHOUT_CLASSIFICATION	1.4410151411497693E-5	DEFECT
ignore this error for now	WITHOUT_CLASSIFICATION	0.9998554279817714	WITHOUT_CLASSIFICATION	1.445720182285959E-4	DEFECT
we need to writeObject() on this since interceptor is user defined	WITHOUT_CLASSIFICATION	0.9998010867864124	WITHOUT_CLASSIFICATION	1.9891321358746303E-4	DEFECT
the old-time stand-by...	WITHOUT_CLASSIFICATION	0.999923359657214	WITHOUT_CLASSIFICATION	7.664034278597461E-5	DEFECT
parameter bind values...	WITHOUT_CLASSIFICATION	0.9999204394813636	WITHOUT_CLASSIFICATION	7.956051863651911E-5	DEFECT
Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998378495254996	WITHOUT_CLASSIFICATION	1.6215047450029256E-4	DEFECT
prepend value and type list with null for any positions before the wanted position.	WITHOUT_CLASSIFICATION	0.999858545103433	WITHOUT_CLASSIFICATION	1.4145489656711586E-4	DEFECT
Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998368541496835	WITHOUT_CLASSIFICATION	1.6314585031640579E-4	DEFECT
we have a CGLIB enhanced entity	WITHOUT_CLASSIFICATION	0.9997337005976424	WITHOUT_CLASSIFICATION	2.662994023575352E-4	DEFECT
we have a CGLIB enhanced entity	WITHOUT_CLASSIFICATION	0.9997337005976424	WITHOUT_CLASSIFICATION	2.662994023575352E-4	DEFECT
we have a Javassist enhanced entity	WITHOUT_CLASSIFICATION	0.9997337005976424	WITHOUT_CLASSIFICATION	2.662994023575352E-4	DEFECT
we have a Javassist enhanced entity	WITHOUT_CLASSIFICATION	0.9997337005976424	WITHOUT_CLASSIFICATION	2.662994023575352E-4	DEFECT
FieldInterceptor impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
subclass accesses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998468196080388	WITHOUT_CLASSIFICATION	1.5318039196116293E-4	DEFECT
let's assume that there is only one lazy fetch group, for now!	WITHOUT_CLASSIFICATION	0.9995987595806956	WITHOUT_CLASSIFICATION	4.0124041930435087E-4	DEFECT
FieldHandler impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999717389485816	WITHOUT_CLASSIFICATION	2.8261051418398297E-4	DEFECT
should not need to grow beyond the size of the total number of columns in the rs	WITHOUT_CLASSIFICATION	0.9943466243367335	WITHOUT_CLASSIFICATION	0.005653375663266431	DEFECT
should probably no-op commit/rollback here, at least in JTA scenarios	WITHOUT_CLASSIFICATION	0.9998589369065523	WITHOUT_CLASSIFICATION	1.4106309344774875E-4	DEFECT
Base Expectation impls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998066357474309	WITHOUT_CLASSIFICATION	1.9336425256900752E-4	DEFECT
Various Expectation instances ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998651169940858	WITHOUT_CLASSIFICATION	1.3488300591420988E-4	DEFECT
explicitly perform no checking...	WITHOUT_CLASSIFICATION	0.999958066064292	WITHOUT_CLASSIFICATION	4.1933935707952425E-5	DEFECT
used from testsuite	WITHOUT_CLASSIFICATION	0.9999563846710633	WITHOUT_CLASSIFICATION	4.361532893665817E-5	DEFECT
assume we are in an auto-commit state	WITHOUT_CLASSIFICATION	0.99999105848401	WITHOUT_CLASSIFICATION	8.94151599005724E-6	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
register synch; stats.connect()	WITHOUT_CLASSIFICATION	0.9998872853409465	WITHOUT_CLASSIFICATION	1.1271465905343577E-4	DEFECT
noncritical, swallow and let the other propagate!	WITHOUT_CLASSIFICATION	0.9999577842765115	WITHOUT_CLASSIFICATION	4.221572348853803E-5	DEFECT
calls executeBatch()	WITHOUT_CLASSIFICATION	0.999706268714145	WITHOUT_CLASSIFICATION	2.937312858550004E-4	DEFECT
no big deal	WITHOUT_CLASSIFICATION	0.9999640585874718	WITHOUT_CLASSIFICATION	3.5941412528194446E-5	DEFECT
no big deal	WITHOUT_CLASSIFICATION	0.9999640585874718	WITHOUT_CLASSIFICATION	3.5941412528194446E-5	DEFECT
no big deal	WITHOUT_CLASSIFICATION	0.9999640585874718	WITHOUT_CLASSIFICATION	3.5941412528194446E-5	DEFECT
sybase driver (jConnect) throwing NPE here in certain cases, but we'll just handle the general "unexpected" case	WITHOUT_CLASSIFICATION	0.9999550541240834	WITHOUT_CLASSIFICATION	4.4945875916550647E-5	DEFECT
see explanation above...	WITHOUT_CLASSIFICATION	0.9999542086303649	WITHOUT_CLASSIFICATION	4.579136963506277E-5	DEFECT
If we are in the process of releasing, no sense checking for aggressive-release possibility.	WITHOUT_CLASSIFICATION	0.999992141747049	WITHOUT_CLASSIFICATION	7.858252951035172E-6	DEFECT
EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
ResultSet impl ("overridden") ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997292336564905	WITHOUT_CLASSIFICATION	2.707663435095239E-4	DEFECT
ResultSet impl (delegated) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997292336564905	WITHOUT_CLASSIFICATION	2.707663435095239E-4	DEFECT
refer to comment in StatefulPersistenceContext.addCollection()	WITHOUT_CLASSIFICATION	0.9994129477520088	WITHOUT_CLASSIFICATION	5.870522479910611E-4	DEFECT
ConnectionManager.Callback implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999624947618377	WITHOUT_CLASSIFICATION	3.750523816229403E-4	DEFECT
Note : success = false, because we don't know the outcome of the transaction	WITHOUT_CLASSIFICATION	0.9994553120137879	WITHOUT_CLASSIFICATION	5.446879862120929E-4	DEFECT
we already have a callback registered; either a local (org.hibernate.Transaction) transaction has accepted callback responsibilities, or we have previously registered a transaction synch.	WITHOUT_CLASSIFICATION	0.9999462077518905	WITHOUT_CLASSIFICATION	5.379224810949441E-5	DEFECT
the configured transaction-factory says it only supports local callback mode, so no sense attempting to register a JTA Synchronization	WITHOUT_CLASSIFICATION	0.9999952849640537	WITHOUT_CLASSIFICATION	4.715035946273477E-6	DEFECT
transactions marked for rollback-only cause some TM impls to throw exceptions	WITHOUT_CLASSIFICATION	0.9935035629052603	WITHOUT_CLASSIFICATION	0.006496437094739614	DEFECT
serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999802241432499	WITHOUT_CLASSIFICATION	1.9775856750106489E-4	DEFECT
postInitialize() will be called after initialization	WITHOUT_CLASSIFICATION	0.9996556610384527	WITHOUT_CLASSIFICATION	3.443389615472753E-4	DEFECT
cannot handle single quotes	WITHOUT_CLASSIFICATION	0.9999662160128671	WITHOUT_CLASSIFICATION	3.3783987133024076E-5	DEFECT
todo : for 4.0 private static final Logger log = LoggerFactory.getLogger( SQLStatementLogger.class ); this is the legacy logging 'category'...	WITHOUT_CLASSIFICATION	0.996525028831653	WITHOUT_CLASSIFICATION	0.003474971168347023	DEFECT
note that for sequential scrolling, we make the assumption that the first persister element is the "root entity"	WITHOUT_CLASSIFICATION	0.9999328324026147	WITHOUT_CLASSIFICATION	6.716759738535721E-5	DEFECT
don't even bother trying to read further	WITHOUT_CLASSIFICATION	0.9993631574941166	WITHOUT_CLASSIFICATION	6.368425058832711E-4	DEFECT
don't even bother trying to read any further	WITHOUT_CLASSIFICATION	0.9996463543244084	WITHOUT_CLASSIFICATION	3.536456755915491E-4	DEFECT
position cursor to the last row	WITHOUT_CLASSIFICATION	0.9999218903620141	WITHOUT_CLASSIFICATION	7.810963798602055E-5	DEFECT
sequentially read the result set in reverse until we recognize a change in the key value. At that point, we are pointed at the last physical sequential row for the logical row in which we are interested in processing	WITHOUT_CLASSIFICATION	0.9999995290337784	WITHOUT_CLASSIFICATION	4.709662215233901E-7	DEFECT
Read backwards until we read past the first physical sequential row with the key we are interested in loading	WITHOUT_CLASSIFICATION	0.9999958923445337	WITHOUT_CLASSIFICATION	4.1076554663728305E-6	DEFECT
Finally, read ahead one row to position result set cursor at the first physical row we are interested in loading	WITHOUT_CLASSIFICATION	0.9999927058047823	WITHOUT_CLASSIFICATION	7.294195217722901E-6	DEFECT
now get an existing proxy for each row element (if there is one)	WITHOUT_CLASSIFICATION	0.9999915401237341	WITHOUT_CLASSIFICATION	8.459876265936207E-6	DEFECT
force the proxy to resolve itself	WITHOUT_CLASSIFICATION	0.9999376615085502	WITHOUT_CLASSIFICATION	6.233849144973834E-5	DEFECT
this is equivalent to the old behavior...	WITHOUT_CLASSIFICATION	0.9996009139019278	WITHOUT_CLASSIFICATION	3.990860980721869E-4	DEFECT
if null, owner will be retrieved from session	WITHOUT_CLASSIFICATION	0.9966510321450988	WITHOUT_CLASSIFICATION	0.0033489678549012214	DEFECT
final String queryString,	WITHOUT_CLASSIFICATION	0.9999415061904114	WITHOUT_CLASSIFICATION	5.849380958867266E-5	DEFECT
if it was a reference to self, don't need to nullify unless we are using native id generation, in which case we definitely need to nullify	WITHOUT_CLASSIFICATION	0.9999069179903962	WITHOUT_CLASSIFICATION	9.308200960377466E-5	DEFECT
end of array, start filling again from start	WITHOUT_CLASSIFICATION	0.9998916245997864	WITHOUT_CLASSIFICATION	1.0837540021351156E-4	DEFECT
in an effort to avoid concurrent-modification-exceptions (from potential recursive calls back through here as a result of the eventual call to PersistentCollection#endRead), we scan the internal loadingCollections map for matches and store those matches in a temp collection. the temp collection is then used to "drive" the #endRead processing.	WITHOUT_CLASSIFICATION	0.999993609826453	WITHOUT_CLASSIFICATION	6.390173547009048E-6	DEFECT
we can reuse it for each row	WITHOUT_CLASSIFICATION	0.99997830926977	WITHOUT_CLASSIFICATION	2.1690730229918465E-5	DEFECT
can't reuse in this case	WITHOUT_CLASSIFICATION	0.9988379456732901	WITHOUT_CLASSIFICATION	0.0011620543267098146	DEFECT
First we need to suspend any current JTA transaction and obtain a JDBC connection	WITHOUT_CLASSIFICATION	0.9999864272303478	WITHOUT_CLASSIFICATION	1.3572769652205264E-5	DEFECT
getResultList(results);	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
if we only returned one entity, query by key is more efficient	WITHOUT_CLASSIFICATION	0.9986644070353987	WITHOUT_CLASSIFICATION	0.0013355929646013725	DEFECT
a collection loaded in the current session can not possibly be the collection belonging to the entity passed to update()	WITHOUT_CLASSIFICATION	0.9999342362056706	WITHOUT_CLASSIFICATION	6.576379432941342E-5	DEFECT
handle empty collection	WITHOUT_CLASSIFICATION	0.9999926989003481	WITHOUT_CLASSIFICATION	7.301099651815287E-6	DEFECT
else no collection element, but also no owner	WITHOUT_CLASSIFICATION	0.9999759411977505	WITHOUT_CLASSIFICATION	2.4058802249586792E-5	DEFECT
handle empty collections	WITHOUT_CLASSIFICATION	0.9999899162649031	WITHOUT_CLASSIFICATION	1.0083735096898979E-5	DEFECT
else this is not a collection initializer (and empty collections will be detected by looking for the owner's identifier in the result set)	WITHOUT_CLASSIFICATION	0.9956140086823515	WITHOUT_CLASSIFICATION	0.0043859913176485694	DEFECT
validate() instances of Validatable	WITHOUT_CLASSIFICATION	0.9998686391510859	WITHOUT_CLASSIFICATION	1.3136084891409661E-4	DEFECT
if we know there is exactly 1 row, we can skip. it would be great if we could _always_ skip this; it is a problem for <key-many-to-one>	WITHOUT_CLASSIFICATION	0.9996207174992555	WITHOUT_CLASSIFICATION	3.7928250074447013E-4	DEFECT
remove all collections for the entity from the session-level cache	WITHOUT_CLASSIFICATION	0.9998574469206395	WITHOUT_CLASSIFICATION	1.4255307936044708E-4	DEFECT
null version means the object is in the process of being loaded somewhere else in the ResultSet	WITHOUT_CLASSIFICATION	0.9999796223157725	WITHOUT_CLASSIFICATION	2.0377684227473398E-5	DEFECT
problematic for <key-many-to-one>!	WITHOUT_CLASSIFICATION	0.9994518588972297	WITHOUT_CLASSIFICATION	5.481411027703003E-4	DEFECT
use the id passed in	WITHOUT_CLASSIFICATION	0.9999109621606808	WITHOUT_CLASSIFICATION	8.903783931921075E-5	DEFECT
do nothing	WITHOUT_CLASSIFICATION	0.9999944764546118	WITHOUT_CLASSIFICATION	5.5235453881330244E-6	DEFECT
prefer re-generation of identity!	WITHOUT_CLASSIFICATION	0.9997933096502292	WITHOUT_CLASSIFICATION	2.066903497707961E-4	DEFECT
no point doing this if NONE was requested	WITHOUT_CLASSIFICATION	0.9999915640204325	WITHOUT_CLASSIFICATION	8.435979567504547E-6	DEFECT
If the object is already loaded, return the loaded one	WITHOUT_CLASSIFICATION	0.9999901015475587	WITHOUT_CLASSIFICATION	9.898452441204541E-6	DEFECT
its already loaded so don't need to hydrate it	WITHOUT_CLASSIFICATION	0.9999171149711928	WITHOUT_CLASSIFICATION	8.28850288072382E-5	DEFECT
cascade the refresh prior to refreshing this entity	WITHOUT_CLASSIFICATION	0.9992274907789473	WITHOUT_CLASSIFICATION	7.725092210526904E-4	DEFECT
the load() which takes an entity does not pass an entityName	WITHOUT_CLASSIFICATION	0.9989241338547793	WITHOUT_CLASSIFICATION	0.0010758661452207872	DEFECT
we only check the version when _upgrading_ lock modes	WITHOUT_CLASSIFICATION	0.9997564773340251	WITHOUT_CLASSIFICATION	2.4352266597499559E-4	DEFECT
look for a proxy	WITHOUT_CLASSIFICATION	0.9999038833591445	WITHOUT_CLASSIFICATION	9.611664085560319E-5	DEFECT
we need to upgrade the lock mode to the mode requested	WITHOUT_CLASSIFICATION	0.9998099305423453	WITHOUT_CLASSIFICATION	1.9006945765453508E-4	DEFECT
its the given optional object	WITHOUT_CLASSIFICATION	0.9999884160879894	WITHOUT_CLASSIFICATION	1.1583912010569396E-5	DEFECT
instantiate a new instance	WITHOUT_CLASSIFICATION	0.9999643666401881	WITHOUT_CLASSIFICATION	3.563335981198993E-5	DEFECT
need to hydrate it.	WITHOUT_CLASSIFICATION	0.9997917413789686	WITHOUT_CLASSIFICATION	2.0825862103134862E-4	DEFECT
return a newly loaded object	WITHOUT_CLASSIFICATION	0.9999946463660806	WITHOUT_CLASSIFICATION	5.353633919401516E-6	DEFECT
will be ignored, using the existing Entry instead	WITHOUT_CLASSIFICATION	0.9998497510360368	WITHOUT_CLASSIFICATION	1.502489639632655E-4	DEFECT
key is an entity involved with the operation performed by the listener; value can be either a copy of the entity or the entity itself	WITHOUT_CLASSIFICATION	0.9999909682904194	WITHOUT_CLASSIFICATION	9.031709580552774E-6	DEFECT
materialize associations (and initialize the object) later	WITHOUT_CLASSIFICATION	0.9999236778279166	WITHOUT_CLASSIFICATION	7.632217208344677E-5	DEFECT
Get the persister for the _subclass_	WITHOUT_CLASSIFICATION	0.9998935817969703	WITHOUT_CLASSIFICATION	1.0641820302970237E-4	DEFECT
ok in normal Hibernate usage to delete a detached entity; JPA however forbids it, thus this is a hook for HEM to affect this behavior	WITHOUT_CLASSIFICATION	0.9999208250088898	WITHOUT_CLASSIFICATION	7.917499111023247E-5	DEFECT
the entry will be removed after the flush, and will no longer override the stale snapshot This is now handled by removeEntity() in EntityDeleteAction persistenceContext.removeDatabaseSnapshot(key);	WITHOUT_CLASSIFICATION	0.9994721452263705	WITHOUT_CLASSIFICATION	5.278547736294856E-4	DEFECT
addInitializedCollection(collection, persister, id);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
|| oj.getJoinable().consumesCollectionAlias()	WITHOUT_CLASSIFICATION	0.9998117767885086	WITHOUT_CLASSIFICATION	1.8822321149133413E-4	DEFECT
here we do not bother with the discriminator.	WITHOUT_CLASSIFICATION	0.9983568311380335	WITHOUT_CLASSIFICATION	0.0016431688619665615	DEFECT
Code to handle subclasses of topClass	WITHOUT_CLASSIFICATION	0.9999331933811058	WITHOUT_CLASSIFICATION	6.680661889423078E-5	DEFECT
woops we got an instance of another class hierarchy branch	WITHOUT_CLASSIFICATION	0.9999100845196557	WITHOUT_CLASSIFICATION	8.991548034428665E-5	DEFECT
we can go straight to the first required row	WITHOUT_CLASSIFICATION	0.9999739178569133	WITHOUT_CLASSIFICATION	2.6082143086778122E-5	DEFECT
we need to step through the rows one row at a time (slow)	WITHOUT_CLASSIFICATION	0.9999824820181127	WITHOUT_CLASSIFICATION	1.7517981887290887E-5	DEFECT
synchronized to avoid multi-thread access issues; defined as method synch to avoid potential deadlock issues due to nature of code.	WITHOUT_CLASSIFICATION	0.9999907633625147	WITHOUT_CLASSIFICATION	9.236637485342245E-6	DEFECT
Allows various loaders (ok mainly the QueryLoader :) to check whether scrolling of their result set should be allowed. By default it is allowed.	WITHOUT_CLASSIFICATION	0.9999689577405438	WITHOUT_CLASSIFICATION	3.1042259456191475E-5	DEFECT
before adding to collection!	WITHOUT_CLASSIFICATION	0.999705077675336	WITHOUT_CLASSIFICATION	2.949223246640369E-4	DEFECT
if the current depth is 0, the root thing being loaded is the many-to-many collection itself. Here, it is alright to use an inner join...	WITHOUT_CLASSIFICATION	0.9999876851505378	WITHOUT_CLASSIFICATION	1.2314849462241704E-5	DEFECT
operations which cascade as far as the collection also cascade to collection elements	WITHOUT_CLASSIFICATION	0.9999943396352026	WITHOUT_CLASSIFICATION	5.660364797395469E-6	DEFECT
simple, because we can't have a one-to-one or a collection (or even a property-ref) in a composite-element:	WITHOUT_CLASSIFICATION	0.9998259047247067	WITHOUT_CLASSIFICATION	1.7409527529319428E-4	DEFECT
a composite key	WITHOUT_CLASSIFICATION	0.9999305172221966	WITHOUT_CLASSIFICATION	6.948277780330593E-5	DEFECT
if no batch, use "foo = ? and bar = ?"	WITHOUT_CLASSIFICATION	0.999944835930005	WITHOUT_CLASSIFICATION	5.516406999510499E-5	DEFECT
it must be a collection fetch	WITHOUT_CLASSIFICATION	0.9999344708621882	WITHOUT_CLASSIFICATION	6.552913781179797E-5	DEFECT
needed later for many-to-many/filter application	WITHOUT_CLASSIFICATION	0.999935330251887	WITHOUT_CLASSIFICATION	6.466974811298791E-5	DEFECT
&& etype.isReferenceToPrimaryKey()	WITHOUT_CLASSIFICATION	0.9998088514142965	WITHOUT_CLASSIFICATION	1.9114858570337424E-4	DEFECT
it might still need to apply a collection ordering based on a many-to-many defined order-by...	WITHOUT_CLASSIFICATION	0.9995338463190074	WITHOUT_CLASSIFICATION	4.661536809926151E-4	DEFECT
if a composite key, use "( (foo = ? and bar = ?) or (foo = ? and bar = ?) )" for batching TODO: unnecessary for databases with ANSI-style joins	WITHOUT_CLASSIFICATION	0.9353374926415606	WITHOUT_CLASSIFICATION	0.06466250735843927	DEFECT
belong to other persister belong to other persister	WITHOUT_CLASSIFICATION	0.9998453221910104	WITHOUT_CLASSIFICATION	1.5467780898957827E-4	DEFECT
we found it	WITHOUT_CLASSIFICATION	0.999925753588517	WITHOUT_CLASSIFICATION	7.424641148294541E-5	DEFECT
we can use an inner join for the many-to-many	WITHOUT_CLASSIFICATION	0.9999880011951411	WITHOUT_CLASSIFICATION	1.1998804859007801E-5	DEFECT
disable a join back to this same association	WITHOUT_CLASSIFICATION	0.9991395500152105	WITHOUT_CLASSIFICATION	8.604499847894088E-4	DEFECT
NOTE: unlike all other Loaders, this one is NOT multithreaded, or cacheable!!	WITHOUT_CLASSIFICATION	0.9999012084409029	WITHOUT_CLASSIFICATION	9.87915590970899E-5	DEFECT
the user visible aliases, which are unknown to the superclass, these are not the actual "physical" SQL aliases	WITHOUT_CLASSIFICATION	0.9998858349791258	WITHOUT_CLASSIFICATION	1.1416502087431522E-4	DEFECT
root entity comes last	WITHOUT_CLASSIFICATION	0.999887739994065	WITHOUT_CLASSIFICATION	1.1226000593503763E-4	DEFECT
deliberately ignore return value!	WITHOUT_CLASSIFICATION	0.9999674625605252	WITHOUT_CLASSIFICATION	3.2537439474865526E-5	DEFECT
alias may be null EARLY EXIT	WITHOUT_CLASSIFICATION	0.9998470147833712	WITHOUT_CLASSIFICATION	1.529852166287715E-4	DEFECT
if it is a compound path	WITHOUT_CLASSIFICATION	0.9998592580561628	WITHOUT_CLASSIFICATION	1.407419438372007E-4	DEFECT
otherwise assume the parent is the the criteria that created us	WITHOUT_CLASSIFICATION	0.9999658252060545	WITHOUT_CLASSIFICATION	3.417479394555365E-5	DEFECT
if its the root criteria, we are done	WITHOUT_CLASSIFICATION	0.9999926215032471	WITHOUT_CLASSIFICATION	7.378496752943277E-6	DEFECT
otherwise, recurse	WITHOUT_CLASSIFICATION	0.9998583409929154	WITHOUT_CLASSIFICATION	1.4165900708458222E-4	DEFECT
the criteria instance	WITHOUT_CLASSIFICATION	0.9999627349230403	WITHOUT_CLASSIFICATION	3.726507695975412E-5	DEFECT
the entity name	WITHOUT_CLASSIFICATION	0.9999258691394171	WITHOUT_CLASSIFICATION	7.413086058295742E-5	DEFECT
not found in inner query , try the outer query	WITHOUT_CLASSIFICATION	0.9996058546836132	WITHOUT_CLASSIFICATION	3.941453163867662E-4	DEFECT
not found in inner query , try the outer query	WITHOUT_CLASSIFICATION	0.9996058546836132	WITHOUT_CLASSIFICATION	3.941453163867662E-4	DEFECT
it refers to an alias of a projection	WITHOUT_CLASSIFICATION	0.9998896594386304	WITHOUT_CLASSIFICATION	1.1034056136960579E-4	DEFECT
should never happen, i think	WITHOUT_CLASSIFICATION	0.9802608218836981	WITHOUT_CLASSIFICATION	0.01973917811630187	DEFECT
Detect discriminator values...	WITHOUT_CLASSIFICATION	0.9998943135865062	WITHOUT_CLASSIFICATION	1.0568641349379581E-4	DEFECT
Convert the string value into the proper type.	WITHOUT_CLASSIFICATION	0.997920982281351	WITHOUT_CLASSIFICATION	0.0020790177186490004	DEFECT
and the qualifier is not the alias of this criteria -> check to see if we belong to some criteria other than the one that created us	WITHOUT_CLASSIFICATION	0.9999033458602747	WITHOUT_CLASSIFICATION	9.665413972524999E-5	DEFECT
it does not refer to an alias of a projection, look for a property	WITHOUT_CLASSIFICATION	0.9980507622971069	WITHOUT_CLASSIFICATION	0.0019492377028931494	DEFECT
Otherwise, this is an ordinary value.	WITHOUT_CLASSIFICATION	0.9998452468943522	WITHOUT_CLASSIFICATION	1.5475310564775803E-4	DEFECT
Currently not cachable if autodiscover types is in effect (e.g. "select ...")	WITHOUT_CLASSIFICATION	0.998231894719455	WITHOUT_CLASSIFICATION	0.00176810528054504	DEFECT
private final String[] sqlAliases; private final String[] sqlAliasSuffixes;	WITHOUT_CLASSIFICATION	0.9997813170680656	WITHOUT_CLASSIFICATION	2.1868293193436208E-4	DEFECT
this is only needed (afaict) for ResultTransformer processing...	WITHOUT_CLASSIFICATION	0.9985555476763353	WITHOUT_CLASSIFICATION	0.0014444523236647367	DEFECT
determine if the collection elements are entities...	WITHOUT_CLASSIFICATION	0.9999788317338514	WITHOUT_CLASSIFICATION	2.1168266148648193E-5	DEFECT
build an array with indices equal to the total number of actual returns in the result Hibernate will return for this query (scalars + non-scalars)	WITHOUT_CLASSIFICATION	0.9997838442689679	WITHOUT_CLASSIFICATION	2.1615573103209954E-4	DEFECT
replace {....} with corresponding column aliases	WITHOUT_CLASSIFICATION	0.9999274435048953	WITHOUT_CLASSIFICATION	7.255649510471974E-5	DEFECT
No additional open braces found in the string, append the rest of the string in its entirty and quit this loop	WITHOUT_CLASSIFICATION	0.9999903904266518	WITHOUT_CLASSIFICATION	9.609573348086895E-6	DEFECT
apend everything up until the next encountered open brace	WITHOUT_CLASSIFICATION	0.9991656892675522	WITHOUT_CLASSIFICATION	8.34310732447712E-4	DEFECT
it is a simple table alias {foo}	WITHOUT_CLASSIFICATION	0.9999305994328062	WITHOUT_CLASSIFICATION	6.940056719375707E-5	DEFECT
passing through anything we do not know : to support jdbc escape sequences HB-898	WITHOUT_CLASSIFICATION	0.9887954485481816	WITHOUT_CLASSIFICATION	0.011204551451818338	DEFECT
passing through anything we do not know : to support jdbc escape sequences HB-898	WITHOUT_CLASSIFICATION	0.9887954485481816	WITHOUT_CLASSIFICATION	0.011204551451818338	DEFECT
The current alias is referencing the collection to be eagerly fetched	WITHOUT_CLASSIFICATION	0.9998677760495844	WITHOUT_CLASSIFICATION	1.322239504156489E-4	DEFECT
it is a property reference {foo.bar}	WITHOUT_CLASSIFICATION	0.9997452442449588	WITHOUT_CLASSIFICATION	2.5475575504120025E-4	DEFECT
Possibly handle :something parameters for the query ?	WITHOUT_CLASSIFICATION	0.9999456206566373	WITHOUT_CLASSIFICATION	5.4379343362675195E-5	DEFECT
Let return-propertys override whatever the persister has for aliases.	WITHOUT_CLASSIFICATION	0.9998984336470432	WITHOUT_CLASSIFICATION	1.0156635295672664E-4	DEFECT
private final List persisters = new ArrayList();	WITHOUT_CLASSIFICATION	0.9998859910572271	WITHOUT_CLASSIFICATION	1.1400894277290464E-4	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
NOTE: EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998969133110821	WITHOUT_CLASSIFICATION	1.0308668891793757E-4	DEFECT
private final List scalarTypes = new ArrayList(); private final List scalarColumnAliases = new ArrayList();	WITHOUT_CLASSIFICATION	0.9998859910572271	WITHOUT_CLASSIFICATION	1.1400894277290464E-4	DEFECT
Now, process the returns	WITHOUT_CLASSIFICATION	0.9999731225045835	WITHOUT_CLASSIFICATION	2.6877495416547145E-5	DEFECT
private List collectionOwnerAliases = new ArrayList(); private List collectionAliases = new ArrayList(); private List collectionPersisters = new ArrayList(); private List collectionResults = new ArrayList();	WITHOUT_CLASSIFICATION	0.999840100266363	WITHOUT_CLASSIFICATION	1.5989973363695183E-4	DEFECT
already been processed...	WITHOUT_CLASSIFICATION	0.999984884077641	WITHOUT_CLASSIFICATION	1.5115922359106576E-5	DEFECT
already been processed...	WITHOUT_CLASSIFICATION	0.999984884077641	WITHOUT_CLASSIFICATION	1.5115922359106576E-5	DEFECT
Make sure the owner alias is known...	WITHOUT_CLASSIFICATION	0.9999125432820943	WITHOUT_CLASSIFICATION	8.745671790577015E-5	DEFECT
first, break down the returns into maps keyed by alias so that role returns can be more easily resolved to their owners	WITHOUT_CLASSIFICATION	0.999962228733023	WITHOUT_CLASSIFICATION	3.777126697693532E-5	DEFECT
scalarColumnAliases.add( typeReturn.getColumnAlias() ); scalarTypes.add( typeReturn.getType() );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
If this return's alias has not been processed yet, do so b4 further processing of this return	WITHOUT_CLASSIFICATION	0.9999493243405281	WITHOUT_CLASSIFICATION	5.0675659471941694E-5	DEFECT
collectionOwnerAliases.add( ownerAlias );	WITHOUT_CLASSIFICATION	0.9993380004044653	WITHOUT_CLASSIFICATION	6.619995955347509E-4	DEFECT
for merging of versioned entities, we consider the version having been changed only when: 1) the two version values are different; AND 2) The target actually represents database state! This second condition is a special case which allows an entity to be merged during the same transaction (though during a seperate operation) in which it was originally persisted/saved	WITHOUT_CLASSIFICATION	0.99753393127138	WITHOUT_CLASSIFICATION	0.0024660687286200645	DEFECT
this is the second pass through on a merge op, so here we limit the replacement to associations types (value types were already replaced during the first pass)	WITHOUT_CLASSIFICATION	0.9997122595072112	WITHOUT_CLASSIFICATION	2.8774049278878626E-4	DEFECT
EARLY EXIT	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
cascade-save to collections AFTER the collection owner was saved	WITHOUT_CLASSIFICATION	0.9999030151207711	WITHOUT_CLASSIFICATION	9.698487922893912E-5	DEFECT
Initialize the error handling delegate.	WITHOUT_CLASSIFICATION	0.9998812290881026	WITHOUT_CLASSIFICATION	1.1877091189731369E-4	DEFECT
Use the delegate.	WITHOUT_CLASSIFICATION	0.9998655654489962	WITHOUT_CLASSIFICATION	1.3443455100380734E-4	DEFECT
currently only the Hibernate-supplied DbTimestampType is supported here	WITHOUT_CLASSIFICATION	0.9780752560061224	WITHOUT_CLASSIFICATION	0.021924743993877477	DEFECT
This is called when it's time to fully resolve a path expression.	WITHOUT_CLASSIFICATION	0.9992637550600658	WITHOUT_CLASSIFICATION	7.362449399342618E-4	DEFECT
make a new one	WITHOUT_CLASSIFICATION	0.9997432478349856	WITHOUT_CLASSIFICATION	2.5675216501434524E-4	DEFECT
not so sure this is even valid subtree. but if it was, it'd represent two unrelated table references...	WITHOUT_CLASSIFICATION	0.9996693237545138	WITHOUT_CLASSIFICATION	3.3067624548629597E-4	DEFECT
(NOT (GT a b) ) => (LE a b)	WITHOUT_CLASSIFICATION	0.9999156525490328	WITHOUT_CLASSIFICATION	8.434745096716243E-5	DEFECT
private Type[] sqlResultTypes;	WITHOUT_CLASSIFICATION	0.9998325255438357	WITHOUT_CLASSIFICATION	1.6747445616424502E-4	DEFECT
include the discriminator and class-level where, but not filters	WITHOUT_CLASSIFICATION	0.9997135651121416	WITHOUT_CLASSIFICATION	2.8643488785848244E-4	DEFECT
sqlResultTypes = selectClause.getSqlResultTypes();	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
by default	WITHOUT_CLASSIFICATION	0.9999958372468429	WITHOUT_CLASSIFICATION	4.162753157065796E-6	DEFECT
This is now handled earlier in this method.	WITHOUT_CLASSIFICATION	0.9976322781331752	WITHOUT_CLASSIFICATION	0.0023677218668248473	DEFECT
-- Loader implementation --	WITHOUT_CLASSIFICATION	0.9996587421376427	WITHOUT_CLASSIFICATION	3.412578623572734E-4	DEFECT
-- Loader overrides --	WITHOUT_CLASSIFICATION	0.9998070595845521	WITHOUT_CLASSIFICATION	1.9294041544790314E-4	DEFECT
(NOT (IS_NULL a b) ) => (IS_NOT_NULL a b)	WITHOUT_CLASSIFICATION	0.999830839395791	WITHOUT_CLASSIFICATION	1.6916060420893854E-4	DEFECT
NONE, because its the requested lock mode, not the actual!	WITHOUT_CLASSIFICATION	0.9999036690035042	WITHOUT_CLASSIFICATION	9.63309964958094E-5	DEFECT
meant to handle dynamic instantiation queries...	WITHOUT_CLASSIFICATION	0.9999255230821997	WITHOUT_CLASSIFICATION	7.447691780022393E-5	DEFECT
--- Query translator methods ---	WITHOUT_CLASSIFICATION	0.999854595416735	WITHOUT_CLASSIFICATION	1.4540458326485004E-4	DEFECT
-- Implementation private methods --	WITHOUT_CLASSIFICATION	0.9995674061872873	WITHOUT_CLASSIFICATION	4.325938127126242E-4	DEFECT
deduplicate unique constraints sharing the same columns this is needed by Hibernate Annotations since it creates automagically unique constraints for the user	WITHOUT_CLASSIFICATION	0.9997000471744849	WITHOUT_CLASSIFICATION	2.99952825515113E-4	DEFECT
Try to find out the name of the primary key to create it as identity if the IdentityGenerator is used	WITHOUT_CLASSIFICATION	0.9999987061381702	WITHOUT_CLASSIFICATION	1.2938618297157072E-6	DEFECT
to support dialects that have their own identity data type	WITHOUT_CLASSIFICATION	0.9999115906175053	WITHOUT_CLASSIFICATION	8.840938249467149E-5	DEFECT
Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999731483853671	WITHOUT_CLASSIFICATION	2.6851614632829588E-5	DEFECT
used also for generation of FK names!	WITHOUT_CLASSIFICATION	0.9999821148631037	WITHOUT_CLASSIFICATION	1.78851368963019E-5	DEFECT
usually useless	WITHOUT_CLASSIFICATION	0.9998376815890274	WITHOUT_CLASSIFICATION	1.6231841097264597E-4	DEFECT
added this caching as I noticed that getType() is being called multiple times...	WITHOUT_CLASSIFICATION	0.9862042631624842	WITHOUT_CLASSIFICATION	0.013795736837515817	DEFECT
do not add unique constraint on DB not supporting unique and nullable columns	WITHOUT_CLASSIFICATION	0.9975070736094314	WITHOUT_CLASSIFICATION	0.002492926390568761	DEFECT
for backward compatibility, disable this:	WITHOUT_CLASSIFICATION	0.9998753532398147	WITHOUT_CLASSIFICATION	1.2464676018529206E-4	DEFECT
may be final may be final may be final	WITHOUT_CLASSIFICATION	0.999769994488188	WITHOUT_CLASSIFICATION	2.3000551181186793E-4	DEFECT
may be final	WITHOUT_CLASSIFICATION	0.9998210261724024	WITHOUT_CLASSIFICATION	1.789738275976515E-4	DEFECT
may be final	WITHOUT_CLASSIFICATION	0.9998210261724024	WITHOUT_CLASSIFICATION	1.789738275976515E-4	DEFECT
Custom SQL	WITHOUT_CLASSIFICATION	0.9999862506862229	WITHOUT_CLASSIFICATION	1.3749313777176425E-5	DEFECT
Primary key constraint	WITHOUT_CLASSIFICATION	0.9999550518803028	WITHOUT_CLASSIFICATION	4.494811969734157E-5	DEFECT
the root of the incoming property path matched one of the embedded composite identifier properties	WITHOUT_CLASSIFICATION	0.9997844616614261	WITHOUT_CLASSIFICATION	2.1553833857393872E-4	DEFECT
ignore it...	WITHOUT_CLASSIFICATION	0.9998908492551246	WITHOUT_CLASSIFICATION	1.091507448754377E-4	DEFECT
flat recursive algorithm	WITHOUT_CLASSIFICATION	0.999479485960037	WITHOUT_CLASSIFICATION	5.205140399630998E-4	DEFECT
an identifier mapper => getKey will be included in the getNonDuplicatedPropertyIterator() and checked later, so it needs to be excluded	WITHOUT_CLASSIFICATION	0.9999096966754525	WITHOUT_CLASSIFICATION	9.030332454746888E-5	DEFECT
if the hibernate-mapping did not specify a schema/catalog, use the defaults specified by properties - but note that if the schema/catalog were specified in hibernate-mapping, or as params, they will already be initialized and will override the values set here (they are in identifierGeneratorProperties)	WITHOUT_CLASSIFICATION	0.9981850415620283	WITHOUT_CLASSIFICATION	0.0018149584379718092	DEFECT
pass the entity-name, if not a collection-id	WITHOUT_CLASSIFICATION	0.9979524869915314	WITHOUT_CLASSIFICATION	0.002047513008468577	DEFECT
Custom SQL	WITHOUT_CLASSIFICATION	0.9999862506862229	WITHOUT_CLASSIFICATION	1.3749313777176425E-5	DEFECT
Primary key constraint	WITHOUT_CLASSIFICATION	0.9999550518803028	WITHOUT_CLASSIFICATION	4.494811969734157E-5	DEFECT
pass the column name (a generated id almost always has a single column)	WITHOUT_CLASSIFICATION	0.9999017575444499	WITHOUT_CLASSIFICATION	9.824245555020192E-5	DEFECT
needed to satisfy KeyValue	WITHOUT_CLASSIFICATION	0.9998846634820772	WITHOUT_CLASSIFICATION	1.1533651792276881E-4	DEFECT
empty means no scoping	WITHOUT_CLASSIFICATION	0.9999963884980521	WITHOUT_CLASSIFICATION	3.61150194799827E-6	DEFECT
index should be last column listed	WITHOUT_CLASSIFICATION	0.999619083593699	WITHOUT_CLASSIFICATION	3.8091640630103684E-4	DEFECT
if it is a formula index, use the element columns in the PK	WITHOUT_CLASSIFICATION	0.9998240091993226	WITHOUT_CLASSIFICATION	1.7599080067751406E-4	DEFECT
don't create a unique key, 'cos some databases don't like a UK on nullable columns	WITHOUT_CLASSIFICATION	0.99828546400328	WITHOUT_CLASSIFICATION	0.0017145359967199619	DEFECT
ArrayList list = new ArrayList();list.addAll( getKey().getConstraintColumns() );list.addAll( getIndex().getConstraintColumns() );getCollectionTable().createUniqueKey(list);	WITHOUT_CLASSIFICATION	0.9999568830209037	WITHOUT_CLASSIFICATION	4.311697909628796E-5	DEFECT
}	WITHOUT_CLASSIFICATION	0.9999814972434341	WITHOUT_CLASSIFICATION	1.850275656585208E-5	DEFECT
no foreign key element of for a one-to-many	WITHOUT_CLASSIFICATION	0.9999842703595048	WITHOUT_CLASSIFICATION	1.5729640495237645E-5	DEFECT
TODO: we could just return all false...	WITHOUT_CLASSIFICATION	0.9995782266162425	WITHOUT_CLASSIFICATION	4.21773383757506E-4	DEFECT
the case of a foreign key to something other than the pk is handled in createPropertyRefConstraints	WITHOUT_CLASSIFICATION	0.9999612597040322	WITHOUT_CLASSIFICATION	3.8740295967954705E-5	DEFECT
TODO: we could just return all false...	WITHOUT_CLASSIFICATION	0.9995782266162425	WITHOUT_CLASSIFICATION	4.21773383757506E-4	DEFECT
if the property mapping consists of all formulas, make it non-updateable	WITHOUT_CLASSIFICATION	0.9996428978268949	WITHOUT_CLASSIFICATION	3.5710217310522187E-4	DEFECT
columnUpdateability.length==0 ||	WITHOUT_CLASSIFICATION	0.9998117767885086	WITHOUT_CLASSIFICATION	1.8822321149133413E-4	DEFECT
if the property mapping consists of all formulas, make it insertable	WITHOUT_CLASSIFICATION	0.9996428978268949	WITHOUT_CLASSIFICATION	3.5710217310522187E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998737322371494	WITHOUT_CLASSIFICATION	1.2626776285067011E-4	DEFECT
expected type is intrinsic here...	WITHOUT_CLASSIFICATION	0.9937646421997369	WITHOUT_CLASSIFICATION	0.006235357800263073	DEFECT
}	WITHOUT_CLASSIFICATION	0.9999814972434341	WITHOUT_CLASSIFICATION	1.850275656585208E-5	DEFECT
}	WITHOUT_CLASSIFICATION	0.9999814972434341	WITHOUT_CLASSIFICATION	1.850275656585208E-5	DEFECT
return memberPersister.getPropertyType(propertyName);	WITHOUT_CLASSIFICATION	0.999944354291771	WITHOUT_CLASSIFICATION	5.564570822900188E-5	DEFECT
return memberPersister.toColumns(alias, propertyName);	WITHOUT_CLASSIFICATION	0.9999444664546481	WITHOUT_CLASSIFICATION	5.553354535180746E-5	DEFECT
return memberPersister.getType();	WITHOUT_CLASSIFICATION	0.999944354291771	WITHOUT_CLASSIFICATION	5.564570822900188E-5	DEFECT
&& !indexIsFormula	WITHOUT_CLASSIFICATION	0.9998512631338683	WITHOUT_CLASSIFICATION	1.487368661316889E-4	DEFECT
return !isOneToMany();	WITHOUT_CLASSIFICATION	0.9999722553220374	WITHOUT_CLASSIFICATION	2.7744677962611717E-5	DEFECT
instanceof AssociationType;	WITHOUT_CLASSIFICATION	0.9999094379913415	WITHOUT_CLASSIFICATION	9.056200865848101E-5	DEFECT
we need to determine the best way to know that two joinables represent a single many-to-many...	WITHOUT_CLASSIFICATION	0.9998167531167971	WITHOUT_CLASSIFICATION	1.8324688320294074E-4	DEFECT
strip leading ','	WITHOUT_CLASSIFICATION	0.999845678238448	WITHOUT_CLASSIFICATION	1.5432176155202174E-4	DEFECT
public boolean isSubselectLoadable();	WITHOUT_CLASSIFICATION	0.9999410847111937	WITHOUT_CLASSIFICATION	5.891528880624082E-5	DEFECT
KEY	WITHOUT_CLASSIFICATION	0.9999791203443746	WITHOUT_CLASSIFICATION	2.0879655625363435E-5	DEFECT
columns	WITHOUT_CLASSIFICATION	0.9999766902702193	WITHOUT_CLASSIFICATION	2.3309729780766298E-5	DEFECT
SQL statements	WITHOUT_CLASSIFICATION	0.9999056629284254	WITHOUT_CLASSIFICATION	9.433707157459257E-5	DEFECT
extra information about the element type	WITHOUT_CLASSIFICATION	0.9989188727806484	WITHOUT_CLASSIFICATION	0.0010811272193516084	DEFECT
types	WITHOUT_CLASSIFICATION	0.9999771127996234	WITHOUT_CLASSIFICATION	2.2887200376687807E-5	DEFECT
custom sql	WITHOUT_CLASSIFICATION	0.9999848717248229	WITHOUT_CLASSIFICATION	1.5128275177120299E-5	DEFECT
private final String unquotedIdentifierColumnName;	WITHOUT_CLASSIFICATION	0.999814347241837	WITHOUT_CLASSIFICATION	1.8565275816302703E-4	DEFECT
dynamic filters specifically for many-to-many inside the collection	WITHOUT_CLASSIFICATION	0.9999239067892671	WITHOUT_CLASSIFICATION	7.609321073280117E-5	DEFECT
dynamic filters for the collection	WITHOUT_CLASSIFICATION	0.9999032513017739	WITHOUT_CLASSIFICATION	9.674869822618564E-5	DEFECT
NativeSQL: collect key column and auto-aliases	WITHOUT_CLASSIFICATION	0.9999611478398388	WITHOUT_CLASSIFICATION	3.8852160161300224E-5	DEFECT
unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
ELEMENT	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
NativeSQL: collect element column and auto-aliases	WITHOUT_CLASSIFICATION	0.9999490284088799	WITHOUT_CLASSIFICATION	5.097159112004929E-5	DEFECT
INDEX AND ROW SELECT	WITHOUT_CLASSIFICATION	0.9998872252259581	WITHOUT_CLASSIFICATION	1.1277477404192837E-4	DEFECT
NativeSQL: collect index column and auto-aliases	WITHOUT_CLASSIFICATION	0.9998759245307357	WITHOUT_CLASSIFICATION	1.240754692642659E-4	DEFECT
unquotedIdentifierColumnName = identifierColumnAlias;	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
unquotedIdentifierColumnName = null;	WITHOUT_CLASSIFICATION	0.9998361058263994	WITHOUT_CLASSIFICATION	1.6389417360065044E-4	DEFECT
GENERATE THE SQL:	WITHOUT_CLASSIFICATION	0.9997851052890706	WITHOUT_CLASSIFICATION	2.1489471092939663E-4	DEFECT
for non-arrays, we don't need to know the element class elementType.returnedClass();	WITHOUT_CLASSIFICATION	0.9962250278834818	WITHOUT_CLASSIFICATION	0.0037749721165182544	DEFECT
not all classpersisters implement PropertyMapping!	WITHOUT_CLASSIFICATION	0.9995460931626097	WITHOUT_CLASSIFICATION	4.539068373903967E-4	DEFECT
Handle any filters applied to this collection	WITHOUT_CLASSIFICATION	0.9997960271421006	WITHOUT_CLASSIFICATION	2.039728578994787E-4	DEFECT
Handle any filters applied to this collection for many-to-many	WITHOUT_CLASSIFICATION	0.9998064765878015	WITHOUT_CLASSIFICATION	1.9352341219856494E-4	DEFECT
if there is a user-specified loader, return that TODO: filters!?	WITHOUT_CLASSIFICATION	0.9599237386926301	WITHOUT_CLASSIFICATION	0.04007626130736979	DEFECT
Take care of any entities that might have been evicted!	WITHOUT_CLASSIFICATION	0.9998169729310924	WITHOUT_CLASSIFICATION	1.8302706890750554E-4	DEFECT
strip leading ','	WITHOUT_CLASSIFICATION	0.999845678238448	WITHOUT_CLASSIFICATION	1.5432176155202174E-4	DEFECT
Run a subquery loader	WITHOUT_CLASSIFICATION	0.9998979167891092	WITHOUT_CLASSIFICATION	1.0208321089071143E-4	DEFECT
needed by arrays	WITHOUT_CLASSIFICATION	0.9998944913382863	WITHOUT_CLASSIFICATION	1.0550866171373904E-4	DEFECT
TODO: something with formulas...	WITHOUT_CLASSIFICATION	0.960010107336152	WITHOUT_CLASSIFICATION	0.03998989266384791	DEFECT
an assertion	WITHOUT_CLASSIFICATION	0.999950846300109	WITHOUT_CLASSIFICATION	4.915369989100928E-5	DEFECT
Remove all the old entries	WITHOUT_CLASSIFICATION	0.9999673605631313	WITHOUT_CLASSIFICATION	3.263943686870196E-5	DEFECT
create all the new entries	WITHOUT_CLASSIFICATION	0.9999854232429052	WITHOUT_CLASSIFICATION	1.4576757094729442E-5	DEFECT
&& !indexIsFormula	WITHOUT_CLASSIFICATION	0.9998512631338683	WITHOUT_CLASSIFICATION	1.487368661316889E-4	DEFECT
&& !indexIsFormula	WITHOUT_CLASSIFICATION	0.9998512631338683	WITHOUT_CLASSIFICATION	1.487368661316889E-4	DEFECT
delete all the deleted entries	WITHOUT_CLASSIFICATION	0.9999638985049283	WITHOUT_CLASSIFICATION	3.610149507176307E-5	DEFECT
insert all the new entries	WITHOUT_CLASSIFICATION	0.9999783722033493	WITHOUT_CLASSIFICATION	2.1627796650736686E-5	DEFECT
==elementType ??	WITHOUT_CLASSIFICATION	0.9998446790958276	WITHOUT_CLASSIFICATION	1.5532090417247306E-4	DEFECT
update all the modified entries	WITHOUT_CLASSIFICATION	0.9999691600228727	WITHOUT_CLASSIFICATION	3.083997712717363E-5	DEFECT
identifier collections not supported for 1-to-many	WITHOUT_CLASSIFICATION	0.998058137217578	WITHOUT_CLASSIFICATION	0.0019418627824220737	DEFECT
update removed rows fks to null	WITHOUT_CLASSIFICATION	0.9994733744117886	WITHOUT_CLASSIFICATION	5.266255882113282E-4	DEFECT
will still be issued when it used to be null	WITHOUT_CLASSIFICATION	0.9991380659462071	WITHOUT_CLASSIFICATION	8.619340537927531E-4	DEFECT
now update all changed or added rows fks	WITHOUT_CLASSIFICATION	0.9999654812108253	WITHOUT_CLASSIFICATION	3.451878917468844E-5	DEFECT
buf.append( selectFragment( lhsAlias, "" ) )ignore suffix for collection columns!	WITHOUT_CLASSIFICATION	0.9998979456043356	WITHOUT_CLASSIFICATION	1.0205439566429291E-4	DEFECT
use suffix for the entity columns	WITHOUT_CLASSIFICATION	0.9998712344793573	WITHOUT_CLASSIFICATION	1.2876552064260529E-4	DEFECT
the class hierarchy structure	WITHOUT_CLASSIFICATION	0.99976711324134	WITHOUT_CLASSIFICATION	2.328867586600882E-4	DEFECT
private final String rootTableName;	WITHOUT_CLASSIFICATION	0.999814347241837	WITHOUT_CLASSIFICATION	1.8565275816302703E-4	DEFECT
INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Custom SQL	WITHOUT_CLASSIFICATION	0.9999862506862229	WITHOUT_CLASSIFICATION	1.3749313777176425E-5	DEFECT
the class hierarchy structure	WITHOUT_CLASSIFICATION	0.99976711324134	WITHOUT_CLASSIFICATION	2.328867586600882E-4	DEFECT
Execute the SQL:	WITHOUT_CLASSIFICATION	0.9998454895799394	WITHOUT_CLASSIFICATION	1.545104200605819E-4	DEFECT
This could also just be true all the time...	WITHOUT_CLASSIFICATION	0.9999906216100969	WITHOUT_CLASSIFICATION	9.378389903086113E-6	DEFECT
chop the last union (all)	WITHOUT_CLASSIFICATION	0.9999393065985386	WITHOUT_CLASSIFICATION	6.069340146154621E-5	DEFECT
TODO: check this....	WITHOUT_CLASSIFICATION	0.972673015530161	WITHOUT_CLASSIFICATION	0.027326984469839	DEFECT
INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
properties of this class, including inherited properties	WITHOUT_CLASSIFICATION	0.9994460655273417	WITHOUT_CLASSIFICATION	5.539344726582635E-4	DEFECT
the closure of all properties in the entire hierarchy including subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.9992016636307298	WITHOUT_CLASSIFICATION	7.98336369270247E-4	DEFECT
the closure of all columns used by the entire hierarchy including subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.999920511283151	WITHOUT_CLASSIFICATION	7.948871684899081E-5	DEFECT
subclass discrimination works by assigning particular values to certain combinations of null primary key values in the outer join using an SQL CASE	WITHOUT_CLASSIFICATION	0.9999065467830405	WITHOUT_CLASSIFICATION	9.345321695954414E-5	DEFECT
MULTITABLES	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Custom sql	WITHOUT_CLASSIFICATION	0.9999785698045023	WITHOUT_CLASSIFICATION	2.1430195497730878E-5	DEFECT
subclass closure properties	WITHOUT_CLASSIFICATION	0.9998612315204929	WITHOUT_CLASSIFICATION	1.3876847950713015E-4	DEFECT
SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
( (Column) model.getTable().getPrimaryKey().getColumnIterator().next() ).getName();	WITHOUT_CLASSIFICATION	0.9999143921871652	WITHOUT_CLASSIFICATION	8.560781283482628E-5	DEFECT
( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();	WITHOUT_CLASSIFICATION	0.9999143921871652	WITHOUT_CLASSIFICATION	8.560781283482628E-5	DEFECT
don't need subclass tables, because they can't appear in conditions	WITHOUT_CLASSIFICATION	0.9993956475551709	WITHOUT_CLASSIFICATION	6.043524448290394E-4	DEFECT
special case where we need to force incloude all subclass joins	WITHOUT_CLASSIFICATION	0.9999655196420293	WITHOUT_CLASSIFICATION	3.4480357970770676E-5	DEFECT
the class hierarchy structure	WITHOUT_CLASSIFICATION	0.99976711324134	WITHOUT_CLASSIFICATION	2.328867586600882E-4	DEFECT
properties of this class, including inherited properties	WITHOUT_CLASSIFICATION	0.9994460655273417	WITHOUT_CLASSIFICATION	5.539344726582635E-4	DEFECT
the closure of all columns used by the entire hierarchy including subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.999920511283151	WITHOUT_CLASSIFICATION	7.948871684899081E-5	DEFECT
get em on the second pass!	WITHOUT_CLASSIFICATION	0.9999179287802379	WITHOUT_CLASSIFICATION	8.207121976213069E-5	DEFECT
now look up the object we are really interested in! (this lets us correctly handle proxies and multi-row or multi-column queries)	WITHOUT_CLASSIFICATION	0.9999875455118493	WITHOUT_CLASSIFICATION	1.2454488150668818E-5	DEFECT
discriminator column	WITHOUT_CLASSIFICATION	0.9999162228937789	WITHOUT_CLASSIFICATION	8.377710622112056E-5	DEFECT
INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
private final Map propertyTableNumbersByName = new HashMap();	WITHOUT_CLASSIFICATION	0.9998839607536762	WITHOUT_CLASSIFICATION	1.1603924632386666E-4	DEFECT
CLASS + TABLE	WITHOUT_CLASSIFICATION	0.9998840724264435	WITHOUT_CLASSIFICATION	1.1592757355647242E-4	DEFECT
DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
PROPERTIES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
Execute the SQL:	WITHOUT_CLASSIFICATION	0.9998454895799394	WITHOUT_CLASSIFICATION	1.545104200605819E-4	DEFECT
JOINS	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
propertyTableNumbersByName.put( prop.getName(), join );	WITHOUT_CLASSIFICATION	0.999396592692183	WITHOUT_CLASSIFICATION	6.03407307817163E-4	DEFECT
Access cached SQL	WITHOUT_CLASSIFICATION	0.9999252963974128	WITHOUT_CLASSIFICATION	7.47036025871248E-5	DEFECT
figure out which tables need to be fetched	WITHOUT_CLASSIFICATION	0.9999642738907133	WITHOUT_CLASSIFICATION	3.5726109286680464E-5	DEFECT
figure out which columns are needed	WITHOUT_CLASSIFICATION	0.9999856882608587	WITHOUT_CLASSIFICATION	1.431173914136942E-5	DEFECT
figure out which formulas are needed	WITHOUT_CLASSIFICATION	0.9999857331804753	WITHOUT_CLASSIFICATION	1.4266819524653774E-5	DEFECT
render the SQL	WITHOUT_CLASSIFICATION	0.9999412916416224	WITHOUT_CLASSIFICATION	5.8708358377524984E-5	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998737322371494	WITHOUT_CLASSIFICATION	1.2626776285067011E-4	DEFECT
moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999702174290362	WITHOUT_CLASSIFICATION	2.9782570963802254E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
The optional SQL string defined in the where attribute	WITHOUT_CLASSIFICATION	0.9999750822612732	WITHOUT_CLASSIFICATION	2.4917738726744576E-5	DEFECT
information about lazy properties of this class	WITHOUT_CLASSIFICATION	0.9839472009704286	WITHOUT_CLASSIFICATION	0.016052799029571265	DEFECT
information about all properties in class hierarchy	WITHOUT_CLASSIFICATION	0.9929818836471573	WITHOUT_CLASSIFICATION	0.007018116352842648	DEFECT
information about all columns/formulas in class hierarchy	WITHOUT_CLASSIFICATION	0.9962346872835802	WITHOUT_CLASSIFICATION	0.0037653127164197857	DEFECT
dynamic filters attached to the class-level	WITHOUT_CLASSIFICATION	0.9993734324274183	WITHOUT_CLASSIFICATION	6.265675725816916E-4	DEFECT
SQL strings	WITHOUT_CLASSIFICATION	0.9995504296986284	WITHOUT_CLASSIFICATION	4.495703013715347E-4	DEFECT
for objects that came in via update()	WITHOUT_CLASSIFICATION	0.999537112979706	WITHOUT_CLASSIFICATION	4.6288702029386174E-4	DEFECT
PROPERTIES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
IDENTIFIER	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
VERSION	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
WHERE STRING	WITHOUT_CLASSIFICATION	0.9998605124836752	WITHOUT_CLASSIFICATION	1.3948751632477454E-4	DEFECT
SUBCLASS PROPERTY CLOSURE	WITHOUT_CLASSIFICATION	0.99989454719453	WITHOUT_CLASSIFICATION	1.0545280546996326E-4	DEFECT
before add :-)	WITHOUT_CLASSIFICATION	0.999523112304037	WITHOUT_CLASSIFICATION	4.7688769596299747E-4	DEFECT
Handle any filters applied to the class level	WITHOUT_CLASSIFICATION	0.9997234763552556	WITHOUT_CLASSIFICATION	2.765236447443824E-4	DEFECT
only one-to-one is lazy fetched	WITHOUT_CLASSIFICATION	0.9991825071161348	WITHOUT_CLASSIFICATION	8.174928838651618E-4	DEFECT
note early exit here:	WITHOUT_CLASSIFICATION	0.9997754208073762	WITHOUT_CLASSIFICATION	2.2457919262369088E-4	DEFECT
object have been loaded with setReadOnly(true); HHH-2236	WITHOUT_CLASSIFICATION	0.9999793092331608	WITHOUT_CLASSIFICATION	2.0690766839143895E-5	DEFECT
NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!	WITHOUT_CLASSIFICATION	0.9968645701366357	WITHOUT_CLASSIFICATION	0.0031354298633644497	DEFECT
strip leading ", "	WITHOUT_CLASSIFICATION	0.9998363908106369	WITHOUT_CLASSIFICATION	1.6360918936310034E-4	DEFECT
if there is no resulting row, return null	WITHOUT_CLASSIFICATION	0.9999757595890044	WITHOUT_CLASSIFICATION	2.424041099561347E-5	DEFECT
otherwise return the "hydrated" state (ie. associations are not resolved)	WITHOUT_CLASSIFICATION	0.999980428821877	WITHOUT_CLASSIFICATION	1.9571178123037366E-5	DEFECT
null owner ok??	WITHOUT_CLASSIFICATION	0.9996538434250248	WITHOUT_CLASSIFICATION	3.461565749751583E-4	DEFECT
null sql means that the only lazy properties are shared PK one-to-one associations which are handled differently in the Type#nullSafeGet code...	WITHOUT_CLASSIFICATION	0.9999865897552828	WITHOUT_CLASSIFICATION	1.3410244717114764E-5	DEFECT
Create a new FROM node for the referenced class.	WITHOUT_CLASSIFICATION	0.9999406503992829	WITHOUT_CLASSIFICATION	5.934960071702468E-5	DEFECT
the difficulty here is exactly what do we update in order to force the version to be incremented in the db...	WITHOUT_CLASSIFICATION	0.9992770909056345	WITHOUT_CLASSIFICATION	7.229090943653756E-4	DEFECT
performance op to avoid the array search	WITHOUT_CLASSIFICATION	0.9999587894227343	WITHOUT_CLASSIFICATION	4.121057726565584E-5	DEFECT
properly handle property-ref-based associations	WITHOUT_CLASSIFICATION	0.9999658508896988	WITHOUT_CLASSIFICATION	3.414911030124394E-5	DEFECT
Enable for HHH-440, which we don't like:	WITHOUT_CLASSIFICATION	0.9997365311850795	WITHOUT_CLASSIFICATION	2.6346881492044714E-4	DEFECT
ALIASES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
aliases named identifier ( alias.idname )	WITHOUT_CLASSIFICATION	0.9999352578371287	WITHOUT_CLASSIFICATION	6.474216287134107E-5	DEFECT
aliases for composite-id's	WITHOUT_CLASSIFICATION	0.999900169060191	WITHOUT_CLASSIFICATION	9.983093980909381E-5	DEFECT
Fetch embedded identifiers propertynames from the "virtual" identifier component	WITHOUT_CLASSIFICATION	0.9998051181223231	WITHOUT_CLASSIFICATION	1.9488187767692495E-4	DEFECT
embedded composite ids ( alias.idname1, alias.idname2 )	WITHOUT_CLASSIFICATION	0.9999432559796086	WITHOUT_CLASSIFICATION	5.674402039142528E-5	DEFECT
TODO: skip formulas?	WITHOUT_CLASSIFICATION	0.9511689204970156	WITHOUT_CLASSIFICATION	0.04883107950298439	DEFECT
don't need filters for the static loaders	WITHOUT_CLASSIFICATION	0.9996693014693384	WITHOUT_CLASSIFICATION	3.3069853066162937E-4	DEFECT
do two passes, for collection property-ref!	WITHOUT_CLASSIFICATION	0.9997594621530694	WITHOUT_CLASSIFICATION	2.4053784693062733E-4	DEFECT
select the correct row by either pk or rowid	WITHOUT_CLASSIFICATION	0.9998323820779712	WITHOUT_CLASSIFICATION	1.6761792202877484E-4	DEFECT
TODO: eventually, rowIdName[j]	WITHOUT_CLASSIFICATION	0.9536471697147949	WITHOUT_CLASSIFICATION	0.04635283028520504	DEFECT
this is a property of the table, which we are updating	WITHOUT_CLASSIFICATION	0.9998855778552646	WITHOUT_CLASSIFICATION	1.144221447353683E-4	DEFECT
special shortcut for id properties, skip the join! this must only occur at the _end_ of a path expression	WITHOUT_CLASSIFICATION	0.9998472473410009	WITHOUT_CLASSIFICATION	1.527526589990777E-4	DEFECT
we are using "all" or "dirty" property-based optimistic locking	WITHOUT_CLASSIFICATION	0.9999437927536077	WITHOUT_CLASSIFICATION	5.620724639227973E-5	DEFECT
nothing to do; even if the operand is a parameter, no way we could infer an appropriate expected type here	WITHOUT_CLASSIFICATION	0.9999974376760148	WITHOUT_CLASSIFICATION	2.5623239852767317E-6	DEFECT
this property belongs on the table and is to be inserted	WITHOUT_CLASSIFICATION	0.9996832997079279	WITHOUT_CLASSIFICATION	3.167002920721218E-4	DEFECT
add normal properties	WITHOUT_CLASSIFICATION	0.9996275303352007	WITHOUT_CLASSIFICATION	3.724696647992336E-4	DEFECT
add the discriminator	WITHOUT_CLASSIFICATION	0.9998865402207995	WITHOUT_CLASSIFICATION	1.1345977920058167E-4	DEFECT
more specifically : "? [op] datetime" 1) if the operator is MINUS, the param needs to be of some datetime type 2) if the operator is PLUS, the param needs to be of some numeric type	WITHOUT_CLASSIFICATION	0.9962785231710432	WITHOUT_CLASSIFICATION	0.003721476828956971	DEFECT
add normal properties	WITHOUT_CLASSIFICATION	0.9996275303352007	WITHOUT_CLASSIFICATION	3.724696647992336E-4	DEFECT
this property belongs on the table and is to be inserted	WITHOUT_CLASSIFICATION	0.9996832997079279	WITHOUT_CLASSIFICATION	3.167002920721218E-4	DEFECT
add the discriminator	WITHOUT_CLASSIFICATION	0.9998865402207995	WITHOUT_CLASSIFICATION	1.1345977920058167E-4	DEFECT
add the primary key	WITHOUT_CLASSIFICATION	0.9999407340605534	WITHOUT_CLASSIFICATION	5.926593944666776E-5	DEFECT
delegate already handles PK columns	WITHOUT_CLASSIFICATION	0.9999131621494636	WITHOUT_CLASSIFICATION	8.683785053643982E-5	DEFECT
we can't batch joined inserts, especially not if it is an identity insert; nor can we batch statements where the expectation is based on an output param	WITHOUT_CLASSIFICATION	0.9996658394350362	WITHOUT_CLASSIFICATION	3.3416056496390347E-4	DEFECT
Render the SQL query	WITHOUT_CLASSIFICATION	0.9997264135834796	WITHOUT_CLASSIFICATION	2.7358641652035643E-4	DEFECT
Write the values of fields onto the prepared statement - we MUST use the state at the time the insert was issued (cos of foreign key constraints). Not necessarily the object's current state	WITHOUT_CLASSIFICATION	0.999995233826517	WITHOUT_CLASSIFICATION	4.766173483016947E-6	DEFECT
TODO : shouldnt inserts be Expectations.NONE?	WITHOUT_CLASSIFICATION	0.9934766207364445	WITHOUT_CLASSIFICATION	0.006523379263555536	DEFECT
don't bother trying to update, we know there is no row there yet	WITHOUT_CLASSIFICATION	0.9978642732729929	WITHOUT_CLASSIFICATION	0.0021357267270071295	DEFECT
if all fields are null, we might need to delete existing row	WITHOUT_CLASSIFICATION	0.9996034162755759	WITHOUT_CLASSIFICATION	3.9658372442399274E-4	DEFECT
there is probably a row there, so try to update if no rows were updated, we will find out	WITHOUT_CLASSIFICATION	0.9999981800165908	WITHOUT_CLASSIFICATION	1.819983409215101E-6	DEFECT
note: updates to joined tables can't be batched...	WITHOUT_CLASSIFICATION	0.9990616732502136	WITHOUT_CLASSIFICATION	9.383267497864185E-4	DEFECT
starting index	WITHOUT_CLASSIFICATION	0.9998298974604026	WITHOUT_CLASSIFICATION	1.7010253959746542E-4	DEFECT
Now write the values of fields onto the prepared statement	WITHOUT_CLASSIFICATION	0.9999042807397839	WITHOUT_CLASSIFICATION	9.571926021610112E-5	DEFECT
Write any appropriate versioning conditional parameters	WITHOUT_CLASSIFICATION	0.9997947970712777	WITHOUT_CLASSIFICATION	2.0520292872230236E-4	DEFECT
Render the SQL query	WITHOUT_CLASSIFICATION	0.9997264135834796	WITHOUT_CLASSIFICATION	2.7358641652035643E-4	DEFECT
Do the key. The key is immutable so we can use the _current_ object state - not necessarily the state at the time the delete was issued	WITHOUT_CLASSIFICATION	0.9999987941449373	WITHOUT_CLASSIFICATION	1.2058550627434849E-6	DEFECT
We should use the _current_ object state (ie. after any updates that occurred during flush)	WITHOUT_CLASSIFICATION	0.9999404694051189	WITHOUT_CLASSIFICATION	5.9530594881036495E-5	DEFECT
this property belongs to the table and it is not specifically excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9989228004101292	WITHOUT_CLASSIFICATION	0.0010771995898708744	DEFECT
note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update oldFields==null just means we had no snapshot to begin with (we might have used select-before-update to get the dirtyFields)	WITHOUT_CLASSIFICATION	0.9999990164059946	WITHOUT_CLASSIFICATION	9.83594005345987E-7	DEFECT
more specifically : "datetime [op] ?" 1) if the operator is MINUS, we really cannot determine the expected type as either another datetime or numeric would be valid 2) if the operator is PLUS, the param needs to be of some numeric type	WITHOUT_CLASSIFICATION	0.9987976359413437	WITHOUT_CLASSIFICATION	0.0012023640586562394	DEFECT
For the case of dynamic-update="true", we need to generate the UPDATE SQL	WITHOUT_CLASSIFICATION	0.9998727644794311	WITHOUT_CLASSIFICATION	1.2723552056896094E-4	DEFECT
don't need to check laziness (dirty checking algorithm handles that)	WITHOUT_CLASSIFICATION	0.9975960600745796	WITHOUT_CLASSIFICATION	0.002403939925420478	DEFECT
For the case of dynamic-update="false", or no snapshot, we use the static SQL	WITHOUT_CLASSIFICATION	0.999995392652521	WITHOUT_CLASSIFICATION	4.6073474789849905E-6	DEFECT
if not "get", then try "is"	WITHOUT_CLASSIFICATION	0.9998073655679731	WITHOUT_CLASSIFICATION	1.9263443202682516E-4	DEFECT
Now update only the tables with dirty properties (and the table with the version number)	WITHOUT_CLASSIFICATION	0.9998317741296295	WITHOUT_CLASSIFICATION	1.682258703704652E-4	DEFECT
For the case of dynamic-insert="true", we need to generate the INSERT SQL	WITHOUT_CLASSIFICATION	0.9998611263499694	WITHOUT_CLASSIFICATION	1.3887365003063866E-4	DEFECT
For the case of dynamic-insert="true", we need to generate the INSERT SQL	WITHOUT_CLASSIFICATION	0.9998611263499694	WITHOUT_CLASSIFICATION	1.3887365003063866E-4	DEFECT
For the case of dynamic-insert="false", use the static SQL	WITHOUT_CLASSIFICATION	0.999966394306554	WITHOUT_CLASSIFICATION	3.360569344600921E-5	DEFECT
For the case of dynamic-insert="false", use the static SQL	WITHOUT_CLASSIFICATION	0.999966394306554	WITHOUT_CLASSIFICATION	3.360569344600921E-5	DEFECT
not supported	WITHOUT_CLASSIFICATION	0.9983518373304129	WITHOUT_CLASSIFICATION	0.0016481626695870333	DEFECT
this property belongs to the table and it is not specifically excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9989228004101292	WITHOUT_CLASSIFICATION	0.0010771995898708744	DEFECT
we need to utilize dynamic delete statements	WITHOUT_CLASSIFICATION	0.9999049827097334	WITHOUT_CLASSIFICATION	9.501729026664885E-5	DEFECT
otherwise, utilize the static delete statements	WITHOUT_CLASSIFICATION	0.9999414626443924	WITHOUT_CLASSIFICATION	5.8537355607716266E-5	DEFECT
just a performance opt!	WITHOUT_CLASSIFICATION	0.9999846591162777	WITHOUT_CLASSIFICATION	1.534088372241531E-5	DEFECT
just a performance opt!	WITHOUT_CLASSIFICATION	0.9999846591162777	WITHOUT_CLASSIFICATION	1.534088372241531E-5	DEFECT
all joins join to the pk of the driving table	WITHOUT_CLASSIFICATION	0.999964981839563	WITHOUT_CLASSIFICATION	3.501816043700673E-5	DEFECT
notice that we skip the first table; it is the driving table!	WITHOUT_CLASSIFICATION	0.9999470718020278	WITHOUT_CLASSIFICATION	5.2928197972147545E-5	DEFECT
we can inner join to superclass tables (the row MUST be there) we can never inner join to subclass tables	WITHOUT_CLASSIFICATION	0.9999688732513968	WITHOUT_CLASSIFICATION	3.112674860311785E-5	DEFECT
skip the driving table	WITHOUT_CLASSIFICATION	0.9999844695665453	WITHOUT_CLASSIFICATION	1.5530433454689827E-5	DEFECT
get 'em in the right order (not that it really matters)	WITHOUT_CLASSIFICATION	0.99988131757611	WITHOUT_CLASSIFICATION	1.1868242389000666E-4	DEFECT
here, we work under the following assumptions: ------------ valid cases -------------------------------------- 1) datetime + {something other than datetime} : always results in a datetime ( db will catch invalid conversions ) 2) datetime - datetime : always results in a DOUBLE 3) datetime - {something other than datetime} : always results in a datetime ( db will catch invalid conversions ) ------------ invalid cases ------------------------------------ 4) datetime + datetime 5) {something other than datetime} - datetime 6) datetime {any type} 7) datetime / {any type} 8) {any type} / datetime doing so allows us to properly handle parameters as either the left or right side here in the majority of cases	WITHOUT_CLASSIFICATION	0.9894247574634992	WITHOUT_CLASSIFICATION	0.01057524253650081	DEFECT
render the where and from parts	WITHOUT_CLASSIFICATION	0.99994847739281	WITHOUT_CLASSIFICATION	5.1522607190072567E-5	DEFECT
we could regerate this inside each called method!	WITHOUT_CLASSIFICATION	0.9999732972057215	WITHOUT_CLASSIFICATION	2.6702794278421717E-5	DEFECT
now render the joins	WITHOUT_CLASSIFICATION	0.9999181034149784	WITHOUT_CLASSIFICATION	8.189658502160392E-5	DEFECT
This will add the new from element to the origin.	WITHOUT_CLASSIFICATION	0.9965727466582394	WITHOUT_CLASSIFICATION	0.0034272533417606557	DEFECT
now render the select clause	WITHOUT_CLASSIFICATION	0.9999668730941439	WITHOUT_CLASSIFICATION	3.312690585604657E-5	DEFECT
now tie it all together	WITHOUT_CLASSIFICATION	0.9999440746022222	WITHOUT_CLASSIFICATION	5.592539777770044E-5	DEFECT
insert/update/delete SQL	WITHOUT_CLASSIFICATION	0.9999369797455224	WITHOUT_CLASSIFICATION	6.302025447758273E-5	DEFECT
select SQL	WITHOUT_CLASSIFICATION	0.9999854203587005	WITHOUT_CLASSIFICATION	1.4579641299523773E-5	DEFECT
no need to check laziness, dirty checking handles that	WITHOUT_CLASSIFICATION	0.999982004925757	WITHOUT_CLASSIFICATION	1.799507424303781E-5	DEFECT
Fully resolve the map reference, create implicit joins.	WITHOUT_CLASSIFICATION	0.9998066898754923	WITHOUT_CLASSIFICATION	1.9331012450783037E-4	DEFECT
temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998627975286344	WITHOUT_CLASSIFICATION	1.3720247136552217E-4	DEFECT
The basic implementation is to simply use the node's text	WITHOUT_CLASSIFICATION	0.9997290387265161	WITHOUT_CLASSIFICATION	2.709612734838893E-4	DEFECT
for dialects which are known to not support ANSI-SQL row-value-constructor syntax, we should mutate the tree.	WITHOUT_CLASSIFICATION	0.9997192200904167	WITHOUT_CLASSIFICATION	2.807799095833279E-4	DEFECT
Due to the complexity in initializing the SelectClause, do not generate one here. If it is not found; simply return null... Also, do not cache since it gets generated well after we are created.	WITHOUT_CLASSIFICATION	0.9970246838682312	WITHOUT_CLASSIFICATION	0.0029753161317688515	DEFECT
check the version unsaved-value, if appropriate	WITHOUT_CLASSIFICATION	0.9998973491648709	WITHOUT_CLASSIFICATION	1.0265083512913661E-4	DEFECT
let this take precedence if defined, since it works for assigned identifiers	WITHOUT_CLASSIFICATION	0.9948641711273631	WITHOUT_CLASSIFICATION	0.005135828872636834	DEFECT
check the id unsaved-value	WITHOUT_CLASSIFICATION	0.9999722364055731	WITHOUT_CLASSIFICATION	2.776359442686566E-5	DEFECT
check to see if it is in the second-level cache	WITHOUT_CLASSIFICATION	0.9999516090384797	WITHOUT_CLASSIFICATION	4.839096152023296E-5	DEFECT
/	WITHOUT_CLASSIFICATION	0.9999819863298791	WITHOUT_CLASSIFICATION	1.801367012079905E-5	DEFECT
For property references generate <tablealias>.<columnname> as <projectionalias>	WITHOUT_CLASSIFICATION	0.9997901847282948	WITHOUT_CLASSIFICATION	2.0981527170505824E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
if there is no resulting row, return null	WITHOUT_CLASSIFICATION	0.9999757595890044	WITHOUT_CLASSIFICATION	2.424041099561347E-5	DEFECT
force immediate execution of the insert	WITHOUT_CLASSIFICATION	0.9998932597986318	WITHOUT_CLASSIFICATION	1.067402013682934E-4	DEFECT
If this from element is a collection and the path is a collection property (maxIndex, etc.) then generate a sub-query.	WITHOUT_CLASSIFICATION	0.9983206655613902	WITHOUT_CLASSIFICATION	0.001679334438609737	DEFECT
entities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997885943548691	WITHOUT_CLASSIFICATION	2.114056451308608E-4	DEFECT
collections ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997892444226646	WITHOUT_CLASSIFICATION	2.1075557733535595E-4	DEFECT
cannot occur	WITHOUT_CLASSIFICATION	0.9998948613713032	WITHOUT_CLASSIFICATION	1.0513862869675107E-4	DEFECT
cannot occur	WITHOUT_CLASSIFICATION	0.9998948613713032	WITHOUT_CLASSIFICATION	1.0513862869675107E-4	DEFECT
only carry on if the method has no parameters	WITHOUT_CLASSIFICATION	0.9999628561514045	WITHOUT_CLASSIFICATION	3.7143848595513676E-5	DEFECT
try "get"	WITHOUT_CLASSIFICATION	0.9999937754906302	WITHOUT_CLASSIFICATION	6.224509369765839E-6	DEFECT
do nothing...	WITHOUT_CLASSIFICATION	0.9998806076702242	WITHOUT_CLASSIFICATION	1.1939232977568928E-4	DEFECT
do nothing...	WITHOUT_CLASSIFICATION	0.9998806076702242	WITHOUT_CLASSIFICATION	1.1939232977568928E-4	DEFECT
should be safe to only ever expect EntityPersister references here	WITHOUT_CLASSIFICATION	0.9941171925612241	WITHOUT_CLASSIFICATION	0.005882807438775954	DEFECT
this page intentionally left blank :)	WITHOUT_CLASSIFICATION	0.9993551079928471	WITHOUT_CLASSIFICATION	6.448920071529826E-4	DEFECT
do not do anything	WITHOUT_CLASSIFICATION	0.9962373701986874	WITHOUT_CLASSIFICATION	0.003762629801312517	DEFECT
ignore	WITHOUT_CLASSIFICATION	0.9999855898485884	WITHOUT_CLASSIFICATION	1.4410151411497693E-5	DEFECT
cant instantiate	WITHOUT_CLASSIFICATION	0.9998427353948554	WITHOUT_CLASSIFICATION	1.5726460514459655E-4	DEFECT
if it is a property of an embedded component, invoke on the "identifier"	WITHOUT_CLASSIFICATION	0.9998103339809233	WITHOUT_CLASSIFICATION	1.8966601907663153E-4	DEFECT
otherwise:	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
skip finalize methods	WITHOUT_CLASSIFICATION	0.9999454227349753	WITHOUT_CLASSIFICATION	5.4577265024681016E-5	DEFECT
note: interfaces is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.999892734472065	WITHOUT_CLASSIFICATION	1.0726552793506858E-4	DEFECT
note: interfaces is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.999892734472065	WITHOUT_CLASSIFICATION	1.0726552793506858E-4	DEFECT
HHH-2481 make sure the callback gets cleared, otherwise the instance stays in a static thread local.	WITHOUT_CLASSIFICATION	0.9999185605993856	WITHOUT_CLASSIFICATION	8.143940061448851E-5	DEFECT
while constructor is running	WITHOUT_CLASSIFICATION	0.9999629437825616	WITHOUT_CLASSIFICATION	3.705621743846355E-5	DEFECT
while constructor is running	WITHOUT_CLASSIFICATION	0.9999629437825616	WITHOUT_CLASSIFICATION	3.705621743846355E-5	DEFECT
note: interface is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.9999177623811654	WITHOUT_CLASSIFICATION	8.223761883469154E-5	DEFECT
interfaces arguments	WITHOUT_CLASSIFICATION	0.9998540402846633	WITHOUT_CLASSIFICATION	1.4595971533673077E-4	DEFECT
TODO!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
Get the caller	WITHOUT_CLASSIFICATION	0.9999405796186709	WITHOUT_CLASSIFICATION	5.942038132919074E-5	DEFECT
Get the caller principals	WITHOUT_CLASSIFICATION	0.9999619239853179	WITHOUT_CLASSIFICATION	3.8076014682084554E-5	DEFECT
private static final Alias DEFAULT_ALIAS = new Alias(10, null);	WITHOUT_CLASSIFICATION	0.9999427168129094	WITHOUT_CLASSIFICATION	5.72831870905314E-5	DEFECT
Needed to bump this up to DotNode, because that is the only thing which currently knows about the property-ref path in the correct format; it is either this, or recurse over the DotNodes constructing the property path just like DotNode does internally	WITHOUT_CLASSIFICATION	0.9986771131142133	WITHOUT_CLASSIFICATION	0.0013228868857867863	DEFECT
if the identifier is quoted, remove the quotes	WITHOUT_CLASSIFICATION	0.999122320194999	WITHOUT_CLASSIFICATION	8.776798050009391E-4	DEFECT
truncate the identifier to the max alias length, less the suffix length	WITHOUT_CLASSIFICATION	0.9999235242412353	WITHOUT_CLASSIFICATION	7.647575876463145E-5	DEFECT
full joins are not supported.. yet!	WITHOUT_CLASSIFICATION	0.9992867675198098	WITHOUT_CLASSIFICATION	7.13232480190226E-4	DEFECT
null is not considered the same type as Integer. $NON-NLS-1 $NON-NLS-1	WITHOUT_CLASSIFICATION	0.998185241596836	WITHOUT_CLASSIFICATION	0.0018147584031639522	DEFECT
the outerJoinsAfterWhere needs to come before where clause to properly handle dynamic filters	WITHOUT_CLASSIFICATION	0.9999026383519858	WITHOUT_CLASSIFICATION	9.736164801423437E-5	DEFECT
$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
strip off any leading 'and' token	WITHOUT_CLASSIFICATION	0.9999274019876562	WITHOUT_CLASSIFICATION	7.259801234381782E-5	DEFECT
if the condition is not already there...	WITHOUT_CLASSIFICATION	0.9882132431130515	WITHOUT_CLASSIFICATION	0.01178675688694849	DEFECT
dontSpace.add("'");	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
for MySQL	WITHOUT_CLASSIFICATION	0.9999804154674622	WITHOUT_CLASSIFICATION	1.9584532537749078E-5	DEFECT
HashMap columnsUnique = new HashMap();	WITHOUT_CLASSIFICATION	0.9998905416624954	WITHOUT_CLASSIFICATION	1.0945833750452741E-4	DEFECT
null caused some problems	WITHOUT_CLASSIFICATION	0.9991443993611312	WITHOUT_CLASSIFICATION	8.556006388688083E-4	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
not sure if this would ever be null but wanted to be careful	WITHOUT_CLASSIFICATION	0.9970723965547434	WITHOUT_CLASSIFICATION	0.002927603445256574	DEFECT
even on inverse="true"	WITHOUT_CLASSIFICATION	0.9997403540352049	WITHOUT_CLASSIFICATION	2.5964596479517206E-4	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
If true then execute db updates, otherwise just generate and display updates	WITHOUT_CLASSIFICATION	0.9999112748903203	WITHOUT_CLASSIFICATION	8.872510967969975E-5	DEFECT
we only release the connection	WITHOUT_CLASSIFICATION	0.9998885635575535	WITHOUT_CLASSIFICATION	1.1143644244650445E-4	DEFECT
deprecated option...	WITHOUT_CLASSIFICATION	0.9998757852696144	WITHOUT_CLASSIFICATION	1.2421473038556107E-4	DEFECT
if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9998955518571758	WITHOUT_CLASSIFICATION	1.044481428241522E-4	DEFECT
actually, this last test is probably unnecessary, since beforeCompletion() doesn't get called during rollback	WITHOUT_CLASSIFICATION	0.9994116250129869	WITHOUT_CLASSIFICATION	5.883749870130657E-4	DEFECT
this one only really needed for badly-behaved applications! (if the TransactionManager has a Sychronization registered, its a noop) (actually we do need it for downgrading locks)	WITHOUT_CLASSIFICATION	0.9995446975913981	WITHOUT_CLASSIFICATION	4.553024086019039E-4	DEFECT
Create an DotNode AST for the path and resolve it.	WITHOUT_CLASSIFICATION	0.999986521639461	WITHOUT_CLASSIFICATION	1.3478360539034705E-5	DEFECT
if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9998955518571758	WITHOUT_CLASSIFICATION	1.044481428241522E-4	DEFECT
if we could not register a synchronization, do the before/after completion callbacks ourself (but we need to let jdbcContext know that this is what we are going to do, so it doesn't keep trying to register synchronizations)	WITHOUT_CLASSIFICATION	0.9998538683380214	WITHOUT_CLASSIFICATION	1.4613166197866934E-4	DEFECT
swallow it, and continue to roll back JTA transaction	WITHOUT_CLASSIFICATION	0.9995794480125527	WITHOUT_CLASSIFICATION	4.205519874472504E-4	DEFECT
so the transaction is already rolled back, by JTA spec	WITHOUT_CLASSIFICATION	0.9999893490644455	WITHOUT_CLASSIFICATION	1.0650935554491044E-5	DEFECT
this method is a noop if there is a Synchronization!	WITHOUT_CLASSIFICATION	0.9997811515860312	WITHOUT_CLASSIFICATION	2.1884841396880642E-4	DEFECT
two conditions where we need to transform this to a theta-join syntax: 1) 'elem' is the "root from-element" in correlated subqueries 2) The DotNode.useThetaStyleImplicitJoins has been set to true and 'elem' represents an implicit join	WITHOUT_CLASSIFICATION	0.999969472266422	WITHOUT_CLASSIFICATION	3.0527733577928235E-5	DEFECT
WebSphere, however, is not a sane JEE/JTA container...	WITHOUT_CLASSIFICATION	0.9980039086503357	WITHOUT_CLASSIFICATION	0.0019960913496642947	DEFECT
for sane JEE/JTA containers, the transaction itself functions as its identifier...	WITHOUT_CLASSIFICATION	0.9999528514461582	WITHOUT_CLASSIFICATION	4.714855384190665E-5	DEFECT
swallow, the transaction was finished	WITHOUT_CLASSIFICATION	0.9999628786934297	WITHOUT_CLASSIFICATION	3.712130657032563E-5	DEFECT
all AliasToEntityMapResultTransformer are considered equal ~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999743709775696	WITHOUT_CLASSIFICATION	2.562902243040677E-5	DEFECT
Create the join element under the from element.	WITHOUT_CLASSIFICATION	0.9997678422700685	WITHOUT_CLASSIFICATION	2.321577299314119E-4	DEFECT
all DistinctRootEntityResultTransformer are considered equal ~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999743709775696	WITHOUT_CLASSIFICATION	2.562902243040677E-5	DEFECT
map of EntityMode -> Tuplizer	WITHOUT_CLASSIFICATION	0.9999103226820313	WITHOUT_CLASSIFICATION	8.967731796878498E-5	DEFECT
this is a virtual id property...	WITHOUT_CLASSIFICATION	0.9993335995236815	WITHOUT_CLASSIFICATION	6.664004763185328E-4	DEFECT
this one needed only for guessEntityMode()	WITHOUT_CLASSIFICATION	0.9990661175149339	WITHOUT_CLASSIFICATION	9.338824850661034E-4	DEFECT
create our own copy of the user-supplied tuplizer impl map	WITHOUT_CLASSIFICATION	0.9998326955646438	WITHOUT_CLASSIFICATION	1.6730443535605067E-4	DEFECT
todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodel	WITHOUT_CLASSIFICATION	0.9998913353330574	WITHOUT_CLASSIFICATION	1.0866466694253846E-4	DEFECT
then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available	WITHOUT_CLASSIFICATION	0.999959318278903	WITHOUT_CLASSIFICATION	4.0681721096965226E-5	DEFECT
Build the dynamic-map tuplizer...	WITHOUT_CLASSIFICATION	0.999854743993375	WITHOUT_CLASSIFICATION	1.4525600662495513E-4	DEFECT
then dom4j tuplizer, if dom4j representation is available	WITHOUT_CLASSIFICATION	0.9997121056026782	WITHOUT_CLASSIFICATION	2.8789439732184976E-4	DEFECT
Build the dynamic-map tuplizer...	WITHOUT_CLASSIFICATION	0.999854743993375	WITHOUT_CLASSIFICATION	1.4525600662495513E-4	DEFECT
put the "standard" tuplizers into the tuplizer map first	WITHOUT_CLASSIFICATION	0.9998347982098056	WITHOUT_CLASSIFICATION	1.6520179019437572E-4	DEFECT
found a ctor, but it was not publicly accessible so try to request accessibility	WITHOUT_CLASSIFICATION	0.9999695306215406	WITHOUT_CLASSIFICATION	3.046937845936879E-5	DEFECT
private final SessionFactoryImplementor sessionFactory;	WITHOUT_CLASSIFICATION	0.9997605291524841	WITHOUT_CLASSIFICATION	2.3947084751572037E-4	DEFECT
cached for efficiency...	WITHOUT_CLASSIFICATION	0.9999225678721221	WITHOUT_CLASSIFICATION	7.743212787791071E-5	DEFECT
public ComponentMetamodel(Component component, SessionFactoryImplementor sessionFactory) {	WITHOUT_CLASSIFICATION	0.9999376691892731	WITHOUT_CLASSIFICATION	6.233081072696472E-5	DEFECT
this.sessionFactory = sessionFactory;	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
it was not embedded, so the argument is just an id	WITHOUT_CLASSIFICATION	0.9999896915098696	WITHOUT_CLASSIFICATION	1.0308490130523377E-5	DEFECT
then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available	WITHOUT_CLASSIFICATION	0.999959318278903	WITHOUT_CLASSIFICATION	4.0681721096965226E-5	DEFECT
then dom4j tuplizer, if dom4j representation is available	WITHOUT_CLASSIFICATION	0.9997121056026782	WITHOUT_CLASSIFICATION	2.8789439732184976E-4	DEFECT
put the "standard" tuplizers into the tuplizer map first	WITHOUT_CLASSIFICATION	0.9998347982098056	WITHOUT_CLASSIFICATION	1.6520179019437572E-4	DEFECT
then handle any user-defined entity modes...	WITHOUT_CLASSIFICATION	0.9999649281152586	WITHOUT_CLASSIFICATION	3.507188474142115E-5	DEFECT
return currentId;	WITHOUT_CLASSIFICATION	0.9999567021678507	WITHOUT_CLASSIFICATION	4.329783214919863E-5	DEFECT
reset the id	WITHOUT_CLASSIFICATION	0.9998003215805752	WITHOUT_CLASSIFICATION	1.996784194248911E-4	DEFECT
origin.addDestination( destination ); This was the cause of HHH-242 origin.setType( FROM_FRAGMENT ); Set the parent node type so that the AST is properly formed. The destination node will have all the FROM text. The parent node is a collection join too (voodoo - see JoinProcessor)	WITHOUT_CLASSIFICATION	0.9977964118187862	WITHOUT_CLASSIFICATION	0.0022035881812138176	DEFECT
reset the version	WITHOUT_CLASSIFICATION	0.9995602745830607	WITHOUT_CLASSIFICATION	4.3972541693927946E-4	DEFECT
the default is to simply not lazy fetch properties for now...	WITHOUT_CLASSIFICATION	0.9995827408625775	WITHOUT_CLASSIFICATION	4.17259137422524E-4	DEFECT
Add the second join, the one that ends in the destination table.	WITHOUT_CLASSIFICATION	0.9999541760323513	WITHOUT_CLASSIFICATION	4.582396764882383E-5	DEFECT
temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998627975286344	WITHOUT_CLASSIFICATION	1.3720247136552217E-4	DEFECT
found a ctor, but it was not publicly accessible so try to request accessibility	WITHOUT_CLASSIFICATION	0.9999695306215406	WITHOUT_CLASSIFICATION	3.046937845936879E-5	DEFECT
determine the id getter and setter methods from the proxy interface (if any) determine all interfaces needed by the resulting proxy	WITHOUT_CLASSIFICATION	0.9999524855989795	WITHOUT_CLASSIFICATION	4.7514401020537327E-5	DEFECT
return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();	WITHOUT_CLASSIFICATION	0.999944354291771	WITHOUT_CLASSIFICATION	5.564570822900188E-5	DEFECT
not final because proxy factory creation can fail	WITHOUT_CLASSIFICATION	0.999326917682849	WITHOUT_CLASSIFICATION	6.730823171510261E-4	DEFECT
superclass entity-name	WITHOUT_CLASSIFICATION	0.9999538294595455	WITHOUT_CLASSIFICATION	4.617054045446642E-5	DEFECT
temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998627975286344	WITHOUT_CLASSIFICATION	1.3720247136552217E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
init the aliases, after initing the constructornode	WITHOUT_CLASSIFICATION	0.9998969239610002	WITHOUT_CLASSIFICATION	1.0307603899985699E-4	DEFECT
temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998627975286344	WITHOUT_CLASSIFICATION	1.3720247136552217E-4	DEFECT
legacy behavior (with no abstract attribute specified)	WITHOUT_CLASSIFICATION	0.9999560026271045	WITHOUT_CLASSIFICATION	4.3997372895538245E-5	DEFECT
Get ready to start adding nodes.	WITHOUT_CLASSIFICATION	0.9997563712927705	WITHOUT_CLASSIFICATION	2.4362870722942858E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
note: this affects the return value!	WITHOUT_CLASSIFICATION	0.9999290663157379	WITHOUT_CLASSIFICATION	7.093368426217572E-5	DEFECT
Need to account for allowable '_' within the variant	WITHOUT_CLASSIFICATION	0.9999438641653039	WITHOUT_CLASSIFICATION	5.613583469616612E-5	DEFECT
Add the type to the list of returned sqlResultTypes.	WITHOUT_CLASSIFICATION	0.9999258888215503	WITHOUT_CLASSIFICATION	7.411117844966825E-5	DEFECT
Collection Types:	WITHOUT_CLASSIFICATION	0.9998520337551211	WITHOUT_CLASSIFICATION	1.4796624487896517E-4	DEFECT
convenience methods relating to operations across arrays of types...	WITHOUT_CLASSIFICATION	0.9998782202792046	WITHOUT_CLASSIFICATION	1.2177972079547683E-4	DEFECT
lobs cannot be compared	WITHOUT_CLASSIFICATION	0.9997871440056447	WITHOUT_CLASSIFICATION	2.1285599435532667E-4	DEFECT
Blobs are ignored by merge()	WITHOUT_CLASSIFICATION	0.9999641416709939	WITHOUT_CLASSIFICATION	3.5858329006033654E-5	DEFECT
value is the entity name	WITHOUT_CLASSIFICATION	0.9999379618494777	WITHOUT_CLASSIFICATION	6.203815052231354E-5	DEFECT
EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
generate id select fragment and then property select fragment for each expression, just like generateSelectFragments().	WITHOUT_CLASSIFICATION	0.99994309628432	WITHOUT_CLASSIFICATION	5.6903715679906526E-5	DEFECT
TODO!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
xml is the entity name	WITHOUT_CLASSIFICATION	0.9999340786089481	WITHOUT_CLASSIFICATION	6.592139105194745E-5	DEFECT
special case ... this is the leaf of the containment graph, even though not immutable	WITHOUT_CLASSIFICATION	0.9851154657529309	WITHOUT_CLASSIFICATION	0.01488453424706909	DEFECT
tolerates nulls	WITHOUT_CLASSIFICATION	0.9998128347915481	WITHOUT_CLASSIFICATION	1.871652084519106E-4	DEFECT
sqlResultTypeList,	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
metaType is assumed to be single-column type	WITHOUT_CLASSIFICATION	0.9993986311874106	WITHOUT_CLASSIFICATION	6.013688125894149E-4	DEFECT
Get all the select expressions (that we just generated) and render the select.	WITHOUT_CLASSIFICATION	0.9999949238837513	WITHOUT_CLASSIFICATION	5.076116248623851E-6	DEFECT
Look through the FromElement's children to find any collections of values that should be fetched...	WITHOUT_CLASSIFICATION	0.9999622197719729	WITHOUT_CLASSIFICATION	3.7780228027179334E-5	DEFECT
return AssociationType.FOREIGN_KEY_TO_PARENT; this is better but causes a transient object exception...	WITHOUT_CLASSIFICATION	0.999789950255835	WITHOUT_CLASSIFICATION	2.100497441649938E-4	DEFECT
Use the lower case function name. Remember whether we're in a SELECT clause or not.	WITHOUT_CLASSIFICATION	0.9999737015889801	WITHOUT_CLASSIFICATION	2.629841101984641E-5	DEFECT
IDENT might be the name of a class.	WITHOUT_CLASSIFICATION	0.9997007224694916	WITHOUT_CLASSIFICATION	2.992775305084216E-4	DEFECT
TODO!!!	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
st.setTimestamp( index, new Timestamp( cal.getTimeInMillis() ), cal ); JDK 1.5 only	WITHOUT_CLASSIFICATION	0.997412614032588	WITHOUT_CLASSIFICATION	0.0025873859674119494	DEFECT
st.setDate( index, new Date( cal.getTimeInMillis() ), cal ); JDK 1.5 only	WITHOUT_CLASSIFICATION	0.997412614032588	WITHOUT_CLASSIFICATION	0.0025873859674119494	DEFECT
both are Timestamps	WITHOUT_CLASSIFICATION	0.9999445760262697	WITHOUT_CLASSIFICATION	5.5423973730277786E-5	DEFECT
at least one is a plain old Date	WITHOUT_CLASSIFICATION	0.9998966960518149	WITHOUT_CLASSIFICATION	1.0330394818509265E-4	DEFECT
noop	WITHOUT_CLASSIFICATION	0.9999770556436615	WITHOUT_CLASSIFICATION	2.2944356338565953E-5	DEFECT
if the corresponding SQL value is NULL, the reader we got is NULL as well	WITHOUT_CLASSIFICATION	0.9999609184440638	WITHOUT_CLASSIFICATION	3.908155593628481E-5	DEFECT
Fetch Reader content up to the end - and put characters in a StringBuffer	WITHOUT_CLASSIFICATION	0.999719265881168	WITHOUT_CLASSIFICATION	2.807341188320237E-4	DEFECT
Return StringBuffer content as a large String	WITHOUT_CLASSIFICATION	0.9999146353561243	WITHOUT_CLASSIFICATION	8.536464387565699E-5	DEFECT
or Types.LONGVARCHAR?	WITHOUT_CLASSIFICATION	0.9999006131668068	WITHOUT_CLASSIFICATION	9.938683319318598E-5	DEFECT
Not called at runtime so doesn't matter if its slow :)	WITHOUT_CLASSIFICATION	0.9722632001180164	WITHOUT_CLASSIFICATION	0.02773679988198363	DEFECT
TODO	WITHOUT_CLASSIFICATION	0.9997848405176439	WITHOUT_CLASSIFICATION	2.1515948235609761E-4	DEFECT
Chop off the rest of the tree.	WITHOUT_CLASSIFICATION	0.9999615860208712	WITHOUT_CLASSIFICATION	3.8413979128812885E-5	DEFECT
different nullability rules for pk/fk	WITHOUT_CLASSIFICATION	0.9998896015756772	WITHOUT_CLASSIFICATION	1.1039842432279097E-4	DEFECT
cache this	WITHOUT_CLASSIFICATION	0.9999687750300259	WITHOUT_CLASSIFICATION	3.122496997407417E-5	DEFECT
only really need new array during semiresolve!	WITHOUT_CLASSIFICATION	0.9994850706518017	WITHOUT_CLASSIFICATION	5.149293481982945E-4	DEFECT
Forcefully remove leading ands from where fragments; the grammar will handle adding them	WITHOUT_CLASSIFICATION	0.9998706481314464	WITHOUT_CLASSIFICATION	1.2935186855357863E-4	DEFECT
TODO!!!!!!!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
Create a new FILTERS node as a parent of all filters	WITHOUT_CLASSIFICATION	0.9999648995762428	WITHOUT_CLASSIFICATION	3.5100423757290155E-5	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
public Object instantiate(Object parent, SessionImplementor session) throws HibernateException;	WITHOUT_CLASSIFICATION	0.9999117366720708	WITHOUT_CLASSIFICATION	8.826332792920233E-5	DEFECT
nothing to do	WITHOUT_CLASSIFICATION	0.9999417257014112	WITHOUT_CLASSIFICATION	5.827429858879218E-5	DEFECT
nothing to do	WITHOUT_CLASSIFICATION	0.9999417257014112	WITHOUT_CLASSIFICATION	5.827429858879218E-5	DEFECT
VersionType impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Note : simply returns null for seed() and next() as the only known application of binary types for versioning is for use with the TIMESTAMP datatype supported by Sybase and SQL Server, which are completely db-generated values...	WITHOUT_CLASSIFICATION	0.9998546190120694	WITHOUT_CLASSIFICATION	1.453809879306491E-4	DEFECT
lobs cannot be compared	WITHOUT_CLASSIFICATION	0.9997871440056447	WITHOUT_CLASSIFICATION	2.1285599435532667E-4	DEFECT
not really necessary, I guess...	WITHOUT_CLASSIFICATION	0.9931822949611037	WITHOUT_CLASSIFICATION	0.006817705038896312	DEFECT
Clobs are ignored by merge() operation	WITHOUT_CLASSIFICATION	0.9999747578482164	WITHOUT_CLASSIFICATION	2.5242151783550728E-5	DEFECT
we do not have to worry about queued additions to uninitialized collections, since they can only occur for inverse collections!	WITHOUT_CLASSIFICATION	0.9996348154614308	WITHOUT_CLASSIFICATION	3.6518453856904755E-4	DEFECT
collections cannot be compared	WITHOUT_CLASSIFICATION	0.9997886246444602	WITHOUT_CLASSIFICATION	2.113753555397856E-4	DEFECT
remember the uk value	WITHOUT_CLASSIFICATION	0.9999374334715624	WITHOUT_CLASSIFICATION	6.256652843765309E-5	DEFECT
NOOP	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
processCollectionProperty(token, q.getCollectionPersister(collectionRole), collectionName);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
we must use the "remembered" uk value, since it is not available from the EntityEntry during assembly	WITHOUT_CLASSIFICATION	0.9995917704135477	WITHOUT_CLASSIFICATION	4.0822958645227186E-4	DEFECT
collections don't dirty an unversioned parent entity	WITHOUT_CLASSIFICATION	0.9996521289561785	WITHOUT_CLASSIFICATION	3.478710438214657E-4	DEFECT
return false;	WITHOUT_CLASSIFICATION	0.9999666309174949	WITHOUT_CLASSIFICATION	3.336908250513386E-5	DEFECT
This just handles a particular case of component projection, perhaps get rid of it and throw an exception	WITHOUT_CLASSIFICATION	0.9994823614054588	WITHOUT_CLASSIFICATION	5.17638594541172E-4	DEFECT
NOTE: we avoid joining to the next table if the named property is just the foreign key value	WITHOUT_CLASSIFICATION	0.9999891534469679	WITHOUT_CLASSIFICATION	1.0846553031970947E-5	DEFECT
the key is the owning entity itself, so get the ID from the key	WITHOUT_CLASSIFICATION	0.9999877906278016	WITHOUT_CLASSIFICATION	1.2209372198299097E-5	DEFECT
if the original is a PersistentCollection, and that original was not flagged as dirty, then reset the target's dirty flag here after the copy operation. </p> One thing to be careful of here is a "bare" original collection in which case we should never ever ever reset the dirty flag on the target because we simply do not know...	WITHOUT_CLASSIFICATION	0.9999351827000491	WITHOUT_CLASSIFICATION	6.481729995087208E-5	DEFECT
ignore subselect keywords	WITHOUT_CLASSIFICATION	0.9999353571855738	WITHOUT_CLASSIFICATION	6.464281442621967E-5	DEFECT
copy elements into newly empty target collection	WITHOUT_CLASSIFICATION	0.9999525897627481	WITHOUT_CLASSIFICATION	4.741023725182577E-5	DEFECT
for a null target, or a target which is the same as the original, we need to put the merged elements in a new collection	WITHOUT_CLASSIFICATION	0.9999924064212381	WITHOUT_CLASSIFICATION	7.59357876187226E-6	DEFECT
by default just use an unanticipated capacity since we don't know how to extract the capacity to use from original here...	WITHOUT_CLASSIFICATION	0.9968374854093243	WITHOUT_CLASSIFICATION	0.0031625145906758107	DEFECT
get the elements back into the target making sure to handle dirty flag	WITHOUT_CLASSIFICATION	0.9999955327083739	WITHOUT_CLASSIFICATION	4.4672916260523664E-6	DEFECT
check if collection is currently being loaded	WITHOUT_CLASSIFICATION	0.9997949452379304	WITHOUT_CLASSIFICATION	2.0505476206953617E-4	DEFECT
check if it is already completely loaded, but unowned	WITHOUT_CLASSIFICATION	0.9999375795590584	WITHOUT_CLASSIFICATION	6.242044094167512E-5	DEFECT
cache the actual id of the object, not the value of the property-ref, which might not be initialized	WITHOUT_CLASSIFICATION	0.9993993828876955	WITHOUT_CLASSIFICATION	6.006171123045196E-4	DEFECT
TODO!!!!!!!	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
create a new collection wrapper, to be initialized later	WITHOUT_CLASSIFICATION	0.9999310262286292	WITHOUT_CLASSIFICATION	6.89737713709233E-5	DEFECT
Some JDBC drivers erroneously return an empty array here for a null DB value :/	WITHOUT_CLASSIFICATION	0.9999611571218495	WITHOUT_CLASSIFICATION	3.8842878150528455E-5	DEFECT
our column span is the number of columns in the PK	WITHOUT_CLASSIFICATION	0.9999192644468159	WITHOUT_CLASSIFICATION	8.073555318408568E-5	DEFECT
cannot batch fetch by unique key (property-ref associations)	WITHOUT_CLASSIFICATION	0.9999263914581897	WITHOUT_CLASSIFICATION	7.360854181031892E-5	DEFECT
we already know current is not null...	WITHOUT_CLASSIFICATION	0.9994291667068484	WITHOUT_CLASSIFICATION	5.708332931514839E-4	DEFECT
the ids are fully resolved, so compare them with isDirty(), not isModified()	WITHOUT_CLASSIFICATION	0.9999294978342967	WITHOUT_CLASSIFICATION	7.050216570324728E-5	DEFECT
the owner of the association is not the owner of the id	WITHOUT_CLASSIFICATION	0.9989963101665406	WITHOUT_CLASSIFICATION	0.0010036898334594235	DEFECT
----------------------------------------------------------- Constructors	WITHOUT_CLASSIFICATION	0.9997915321170872	WITHOUT_CLASSIFICATION	2.0846788291275123E-4	DEFECT
----------------------------------------------------- Instance Variables	WITHOUT_CLASSIFICATION	0.9998359017848798	WITHOUT_CLASSIFICATION	1.6409821512015717E-4	DEFECT
public static JDBCException newJDBCException(String string, SQLException root, String sql) { string = string + " [" + sql + ']'; log.error(string, root); logExceptions(root); return new JDBCException(string, root, sql); } public static JDBCException newJDBCException(String string, SQLException root) { log.error(string, root); logExceptions(root); return new JDBCException(string, root); }	WITHOUT_CLASSIFICATION	0.9999966128196912	WITHOUT_CLASSIFICATION	3.387180308755152E-6	DEFECT
--------------------------------------------------------- Public Methods	WITHOUT_CLASSIFICATION	0.9998122289687081	WITHOUT_CLASSIFICATION	1.8777103129177038E-4	DEFECT
Compare the two maps for equality	WITHOUT_CLASSIFICATION	0.9996731983343328	WITHOUT_CLASSIFICATION	3.2680166566725904E-4	DEFECT
Simple tests that require no synchronization	WITHOUT_CLASSIFICATION	0.9981865127108763	WITHOUT_CLASSIFICATION	0.0018134872891237134	DEFECT
Sybase fail if we don't do that, sigh...	WITHOUT_CLASSIFICATION	0.9980735428224754	WITHOUT_CLASSIFICATION	0.001926457177524604	DEFECT
Handles things like: a and b or c a and ( b or c ) not a and not b not ( a and b ) x between y and z (overloaded "and") x in ( a, b, c ) (overloaded brackets) not not a a is not null (overloaded "not") etc...... and expressions like foo = bar (maps to: foo.id = bar.id) foo.Bar = 'foo' (maps to: foo.bar = 'foo') foo.Bar.Baz = 1.0 (maps to: foo.bar = bar.id and bar.baz = 1.0) 1.0 = foo.Bar.Baz (maps to: bar.baz = 1.0 and foo.Bar = bar.id) foo.Bar.Baz = a.B.C (maps to: bar.Baz = b.C and foo.Bar = bar.id and a.B = b.id) foo.Bar.Baz + a.B.C (maps to: bar.Baz + b.C and foo.Bar = bar.id and a.B = b.id) ( foo.Bar.Baz + 1.0 ) < 2.0 (maps to: ( bar.Baz + 1.0 ) < 2.0 and foo.Bar = bar.id)	WITHOUT_CLASSIFICATION	0.9894067068224516	WITHOUT_CLASSIFICATION	0.010593293177548329	DEFECT
release the jdk internal caches everytime to ensure this plays nicely with destroyable class-loaders	WITHOUT_CLASSIFICATION	0.9995177393213938	WITHOUT_CLASSIFICATION	4.8226067860635067E-4	DEFECT
release the jdk internal caches everytime to ensure this plays nicely with destroyable class-loaders	WITHOUT_CLASSIFICATION	0.9995177393213938	WITHOUT_CLASSIFICATION	4.8226067860635067E-4	DEFECT
try to "pretty print" it	WITHOUT_CLASSIFICATION	0.9999455283953662	WITHOUT_CLASSIFICATION	5.447160463364551E-5	DEFECT
otherwise, just dump it	WITHOUT_CLASSIFICATION	0.9999537126163649	WITHOUT_CLASSIFICATION	4.628738363499141E-5	DEFECT
its an interface so we can't really tell anything...	WITHOUT_CLASSIFICATION	0.999971459113901	WITHOUT_CLASSIFICATION	2.854088609898009E-5	DEFECT
its an interface so we can't really tell anything...	WITHOUT_CLASSIFICATION	0.999971459113901	WITHOUT_CLASSIFICATION	2.854088609898009E-5	DEFECT
use default behavior	WITHOUT_CLASSIFICATION	0.9999837168616523	WITHOUT_CLASSIFICATION	1.628313834768258E-5	DEFECT
NOTE: early return	WITHOUT_CLASSIFICATION	0.9999732283876541	WITHOUT_CLASSIFICATION	2.677161234581969E-5	DEFECT
the MRU cache used to keep hard references to the most recently used query plans; note : LRU here is a bit of a misnomer, it indicates that LRU entries are removed, the actual kept entries are the MRU entries	WITHOUT_CLASSIFICATION	0.9995490311974681	WITHOUT_CLASSIFICATION	4.5096880253204174E-4	DEFECT
we want to be able to just use the defaults, if JNDI environment properties are not supplied so don't put null in anywhere	WITHOUT_CLASSIFICATION	0.999992257218194	WITHOUT_CLASSIFICATION	7.742781806087364E-6	DEFECT
Clone -----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9997896097307516	WITHOUT_CLASSIFICATION	2.103902692483069E-4	DEFECT
Serialize -----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
stream closed in the finally	WITHOUT_CLASSIFICATION	0.9999440299899428	WITHOUT_CLASSIFICATION	5.5970010057079926E-5	DEFECT
stream closed in the finally	WITHOUT_CLASSIFICATION	0.9999440299899428	WITHOUT_CLASSIFICATION	5.5970010057079926E-5	DEFECT
Deserialize -----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
static methods only - hide constructor	WITHOUT_CLASSIFICATION	0.9996616414778411	WITHOUT_CLASSIFICATION	3.3835852215894545E-4	DEFECT
&& !('_'==character)	WITHOUT_CLASSIFICATION	0.9998512631338683	WITHOUT_CLASSIFICATION	1.487368661316889E-4	DEFECT
returnign null!	WITHOUT_CLASSIFICATION	0.9998351912420879	WITHOUT_CLASSIFICATION	1.6480875791211212E-4	DEFECT
returnign null!	WITHOUT_CLASSIFICATION	0.9998351912420879	WITHOUT_CLASSIFICATION	1.6480875791211212E-4	DEFECT
includes last '.'	WITHOUT_CLASSIFICATION	0.9998934349042508	WITHOUT_CLASSIFICATION	1.065650957491996E-4	DEFECT
+1 to include the following '.'	WITHOUT_CLASSIFICATION	0.9998328098461142	WITHOUT_CLASSIFICATION	1.671901538858045E-4	DEFECT
Impl note: takes advantage of the fact that an escpaed single quote embedded within a quote-block can really be handled as two seperate quote-blocks for the purposes of this method...	WITHOUT_CLASSIFICATION	0.9999876088687948	WITHOUT_CLASSIFICATION	1.2391131205099555E-5	DEFECT
first time we find match!	WITHOUT_CLASSIFICATION	0.999991906468775	WITHOUT_CLASSIFICATION	8.093531224953419E-6	DEFECT
entityNames may now include slashes for the representations classname may be an inner class	WITHOUT_CLASSIFICATION	0.9999380502234361	WITHOUT_CLASSIFICATION	6.194977656388481E-5	DEFECT
wrapped iterators	WITHOUT_CLASSIFICATION	0.9998497884760902	WITHOUT_CLASSIFICATION	1.5021152390976963E-4	DEFECT
index of current iterator in the wrapped iterators array	WITHOUT_CLASSIFICATION	0.9999139671010363	WITHOUT_CLASSIFICATION	8.603289896372793E-5	DEFECT
the current iterator	WITHOUT_CLASSIFICATION	0.9999592719609662	WITHOUT_CLASSIFICATION	4.072803903370423E-5	DEFECT
the last used iterator	WITHOUT_CLASSIFICATION	0.9999864259471637	WITHOUT_CLASSIFICATION	1.3574052836409558E-5	DEFECT
it was a boolean expression	WITHOUT_CLASSIFICATION	0.9999778465110222	WITHOUT_CLASSIFICATION	2.215348897781405E-5	DEFECT
public static Object[] clone(Class elementClass, Object[] array) {Object[] result = (Object[]) Array.newInstance( elementClass, array.length );System.arraycopy(array, 0, result, 0, array.length);return result;}	WITHOUT_CLASSIFICATION	0.9998851053893757	WITHOUT_CLASSIFICATION	1.1489461062436586E-4	DEFECT
call this before any Iterator method to make sure that the current Iterator is not exhausted	WITHOUT_CLASSIFICATION	0.9998488274777649	WITHOUT_CLASSIFICATION	1.511725222351287E-4	DEFECT
doable if needed	WITHOUT_CLASSIFICATION	0.999882058600346	WITHOUT_CLASSIFICATION	1.1794139965396982E-4	DEFECT
set last used iterator here, in case the user calls remove before calling hasNext() or next() (although they shouldn't)	WITHOUT_CLASSIFICATION	0.9995724455430056	WITHOUT_CLASSIFICATION	4.275544569943868E-4	DEFECT
peek ahead	WITHOUT_CLASSIFICATION	0.9999772897966954	WITHOUT_CLASSIFICATION	2.2710203304537174E-5	DEFECT
if we reach the end of the string w/o finding the matching end, that is an exception	WITHOUT_CLASSIFICATION	0.9996418431692056	WITHOUT_CLASSIFICATION	3.5815683079447346E-4	DEFECT
we have a placeholder, spin forward till we find the end	WITHOUT_CLASSIFICATION	0.9998708066847362	WITHOUT_CLASSIFICATION	1.2919331526380778E-4	DEFECT
make sure spinning forward did not put us past the end of the buffer...	WITHOUT_CLASSIFICATION	0.9994495188634218	WITHOUT_CLASSIFICATION	5.504811365782572E-4	DEFECT
First, try to locate this resource through the current context classloader.	WITHOUT_CLASSIFICATION	0.9999589044597027	WITHOUT_CLASSIFICATION	4.109554029723353E-5	DEFECT
Next, try to locate this resource through this class's classloader	WITHOUT_CLASSIFICATION	0.9993416820789606	WITHOUT_CLASSIFICATION	6.583179210394417E-4	DEFECT
Next, try to locate this resource through the system classloader	WITHOUT_CLASSIFICATION	0.9987203330226067	WITHOUT_CLASSIFICATION	0.0012796669773933878	DEFECT
Anywhere else we should look?	WITHOUT_CLASSIFICATION	0.9998617898221925	WITHOUT_CLASSIFICATION	1.3821017780757944E-4	DEFECT
would need an IdentitySet for this!	WITHOUT_CLASSIFICATION	0.9996789537051927	WITHOUT_CLASSIFICATION	3.2104629480729995E-4	DEFECT
Arrays.asList doesn't do primitive arrays	WITHOUT_CLASSIFICATION	0.9995227843710973	WITHOUT_CLASSIFICATION	4.7721562890265686E-4	DEFECT
faster?	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
the name of a class	WITHOUT_CLASSIFICATION	0.9997228471207159	WITHOUT_CLASSIFICATION	2.7715287928407417E-4	DEFECT
Its the listener class name	WITHOUT_CLASSIFICATION	0.9999233404088995	WITHOUT_CLASSIFICATION	7.665959110044284E-5	DEFECT
allow 9,8,7,6,5,4,3,2,1	WITHOUT_CLASSIFICATION	0.9999313428110987	WITHOUT_CLASSIFICATION	6.865718890118342E-5	DEFECT
default to element set if no elements() specified	WITHOUT_CLASSIFICATION	0.9999959624230903	WITHOUT_CLASSIFICATION	4.037576909685497E-6	DEFECT
look for the instance by uuid	WITHOUT_CLASSIFICATION	0.9999731394556336	WITHOUT_CLASSIFICATION	2.686054436647244E-5	DEFECT
in case we were deserialized in a different JVM, look for an instance with the same name (alternatively we could do an actual JNDI lookup here....)	WITHOUT_CLASSIFICATION	0.9999974332688131	WITHOUT_CLASSIFICATION	2.5667311868828025E-6	DEFECT
first, lets determine whether to apply cglib or javassist based instrumentation...	WITHOUT_CLASSIFICATION	0.9998920405007329	WITHOUT_CLASSIFICATION	1.0795949926719173E-4	DEFECT
Make sure we don't override previous set values	WITHOUT_CLASSIFICATION	0.9999794212369721	WITHOUT_CLASSIFICATION	2.0578763027856527E-5	DEFECT
entirely optional!!	WITHOUT_CLASSIFICATION	0.9996859904635077	WITHOUT_CLASSIFICATION	3.140095364923371E-4	DEFECT
Its the listener instance (or better be)	WITHOUT_CLASSIFICATION	0.9999909470786289	WITHOUT_CLASSIFICATION	9.052921371165611E-6	DEFECT
context.unbind(boundName);	WITHOUT_CLASSIFICATION	0.9998941739156183	WITHOUT_CLASSIFICATION	1.0582608438163543E-4	DEFECT
readResolveObject	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
cfg.setProperty("hibernate.show_sql", "true");	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
Defensive, convenience methods	WITHOUT_CLASSIFICATION	0.9999319682352764	WITHOUT_CLASSIFICATION	6.803176472352082E-5	DEFECT
Create the SessionFactory from hibernate.cfg.xml	WITHOUT_CLASSIFICATION	0.9998711349269481	WITHOUT_CLASSIFICATION	1.2886507305191546E-4	DEFECT
Make sure you log the exception, as it might be swallowed	WITHOUT_CLASSIFICATION	0.9998644258896614	WITHOUT_CLASSIFICATION	1.3557411033866164E-4	DEFECT
Begin unit of work	WITHOUT_CLASSIFICATION	0.997422168876589	WITHOUT_CLASSIFICATION	0.002577831123410967	DEFECT
Write HTML header	WITHOUT_CLASSIFICATION	0.9998633066040422	WITHOUT_CLASSIFICATION	1.3669339595784704E-4	DEFECT
Handle actions	WITHOUT_CLASSIFICATION	0.99989138122062	WITHOUT_CLASSIFICATION	1.0861877938002021E-4	DEFECT
Print page	WITHOUT_CLASSIFICATION	0.999965895936122	WITHOUT_CLASSIFICATION	3.410406387803233E-5	DEFECT
Write HTML footer	WITHOUT_CLASSIFICATION	0.9998370889691931	WITHOUT_CLASSIFICATION	1.629110308069494E-4	DEFECT
End unit of work	WITHOUT_CLASSIFICATION	0.9972765610394654	WITHOUT_CLASSIFICATION	0.0027234389605346574	DEFECT
Start the session to be used for this request	WITHOUT_CLASSIFICATION	0.9999348752902419	WITHOUT_CLASSIFICATION	6.512470975810482E-5	DEFECT
make the session available to the session factory's "current context"	WITHOUT_CLASSIFICATION	0.9996847568923296	WITHOUT_CLASSIFICATION	3.1524310767033266E-4	DEFECT
pass control along to the rest of the processing chain	WITHOUT_CLASSIFICATION	0.9998166507572219	WITHOUT_CLASSIFICATION	1.8334924277810258E-4	DEFECT
remove session from "current context"	WITHOUT_CLASSIFICATION	0.9996463586936893	WITHOUT_CLASSIFICATION	3.5364130631069737E-4	DEFECT
Eager fetch the collection so we can use it detached	WITHOUT_CLASSIFICATION	0.999989623976368	WITHOUT_CLASSIFICATION	1.0376023632012105E-5	DEFECT
If we want to handle it bidirectional and detached, we also need to load this collection with an eager outer-join fetch, this time with Criteria and not HQL:	WITHOUT_CLASSIFICATION	0.9999895234420496	WITHOUT_CLASSIFICATION	1.0476557950471548E-5	DEFECT
Event anEvent = (Event) session .createCriteria(Event.class).setFetchMode("participants", FetchMode.JOIN) .add( Expression.eq("id", eventId) ) .uniqueResult(); Eager fetch the colleciton so we can use it detached	WITHOUT_CLASSIFICATION	0.9999889931308196	WITHOUT_CLASSIFICATION	1.100686918044078E-5	DEFECT
End of first unit of work	WITHOUT_CLASSIFICATION	0.999293723343379	WITHOUT_CLASSIFICATION	7.062766566210029E-4	DEFECT
or bidirectional safety method, setting both sides: aPerson.addToEvent(anEvent);	WITHOUT_CLASSIFICATION	0.9999207596189442	WITHOUT_CLASSIFICATION	7.924038105573602E-5	DEFECT
Begin second unit of work	WITHOUT_CLASSIFICATION	0.9978168694124261	WITHOUT_CLASSIFICATION	0.0021831305875739462	DEFECT
Reattachment of aPerson	WITHOUT_CLASSIFICATION	0.9998969373966852	WITHOUT_CLASSIFICATION	1.03062603314944E-4	DEFECT
The getEmailAddresses() might trigger a lazy load of the collection	WITHOUT_CLASSIFICATION	0.998961272283196	WITHOUT_CLASSIFICATION	0.001038727716804015	DEFECT
We need our tm, so get it now and avoid doing other work if there is a problem	WITHOUT_CLASSIFICATION	0.9998753627310785	WITHOUT_CLASSIFICATION	1.2463726892153267E-4	DEFECT
Don't hold the JBC node lock throughout the tx, as that prevents reads and other updates	WITHOUT_CLASSIFICATION	0.9999693921603813	WITHOUT_CLASSIFICATION	3.0607839618779186E-5	DEFECT
Don't hold the JBC node lock throughout the tx, as that prevents reads and other updates	WITHOUT_CLASSIFICATION	0.9999693921603813	WITHOUT_CLASSIFICATION	3.0607839618779186E-5	DEFECT
JBC put a version in the node when it created as part of some internal operation. We are always newer, but if the JBC version is > 1 something odd has happened	WITHOUT_CLASSIFICATION	0.9999890512417456	WITHOUT_CLASSIFICATION	1.0948758254380641E-5	DEFECT
swaldman 2006-08-28: define c3p0-style configuration parameters for properties with hibernate-specific overrides to detect and warn about conflicting declarations	WITHOUT_CLASSIFICATION	0.9993071182851795	WITHOUT_CLASSIFICATION	6.928817148205793E-4	DEFECT
Not null if the Isolation level has been specified in the configuration file. Otherwise, it is left to the Driver's default value.	WITHOUT_CLASSIFICATION	0.9999804881698068	WITHOUT_CLASSIFICATION	1.951183019321925E-5	DEFECT
Configured outside of Hibernate (i.e. Servlet container, or Java Bean Container already has Proxool pools running, and this provider is to just borrow one of these	WITHOUT_CLASSIFICATION	0.9999132636960301	WITHOUT_CLASSIFICATION	8.673630396993785E-5	DEFECT
If you're closing down the ConnectionProvider chances are an is not a real big deal, just warn	WITHOUT_CLASSIFICATION	0.9998590166839263	WITHOUT_CLASSIFICATION	1.40983316073759E-4	DEFECT
(AS is always optional, for consistency with SQL/OQL)	WITHOUT_CLASSIFICATION	0.9994899120215158	WITHOUT_CLASSIFICATION	5.100879784841126E-4	DEFECT
process the "new" HQL style where aliases are assigned _after_ the class name or path expression ie. using the AS construction	WITHOUT_CLASSIFICATION	0.9999949997549136	WITHOUT_CLASSIFICATION	5.000245086346254E-6	DEFECT
the loaded owner will be set to null after the collection is removed, so capture its value as the affected owner so it is accessible to both pre- and post- events	WITHOUT_CLASSIFICATION	0.9999503045947644	WITHOUT_CLASSIFICATION	4.969540523561224E-5	DEFECT
is a primitive type invokespecial	WITHOUT_CLASSIFICATION	0.9997669912577131	WITHOUT_CLASSIFICATION	2.330087422869667E-4	DEFECT
array of primitive type do nothing	WITHOUT_CLASSIFICATION	0.9999668833768104	WITHOUT_CLASSIFICATION	3.3116623189689854E-5	DEFECT
handle a path expression or class name that appears at the start, in the "new" HQL style or an alias that appears at the start in the "old" HQL style	WITHOUT_CLASSIFICATION	0.9999857094989405	WITHOUT_CLASSIFICATION	1.4290501059581372E-5	DEFECT
handle <=, >=, !=, is not, not between, not in	WITHOUT_CLASSIFICATION	0.9994606891976101	WITHOUT_CLASSIFICATION	5.393108023897614E-4	DEFECT
The loop ensures atomicity of the select + update even for no transaction or read committed isolation level	WITHOUT_CLASSIFICATION	0.99999621037765	WITHOUT_CLASSIFICATION	3.7896223500743027E-6	DEFECT
transfer an explicitly defined entity name handle the lazy attribute	WITHOUT_CLASSIFICATION	0.9999982754529293	WITHOUT_CLASSIFICATION	1.724547070636084E-6	DEFECT
keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9998715546253691	WITHOUT_CLASSIFICATION	1.2844537463096824E-4	DEFECT
keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9998715546253691	WITHOUT_CLASSIFICATION	1.2844537463096824E-4	DEFECT
get meta's from <joined-subclass>	WITHOUT_CLASSIFICATION	0.9998856015375117	WITHOUT_CLASSIFICATION	1.1439846248830213E-4	DEFECT
parameters on the property mapping should override parameters in the typedef	WITHOUT_CLASSIFICATION	0.999183196827876	WITHOUT_CLASSIFICATION	8.168031721238452E-4	DEFECT
fetch="join" overrides default laziness fetch="join" overrides default laziness	WITHOUT_CLASSIFICATION	0.9999618356961048	WITHOUT_CLASSIFICATION	3.816430389518754E-5	DEFECT
NOTE SPECIAL CASE: default to join and non-lazy for the "second join" of the many-to-many	WITHOUT_CLASSIFICATION	0.9999819599080115	WITHOUT_CLASSIFICATION	1.804009198846168E-5	DEFECT
so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999821315713795	WITHOUT_CLASSIFICATION	1.7868428620599234E-5	DEFECT
state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999906354481357	WITHOUT_CLASSIFICATION	9.36455186430395E-5	DEFECT
void setComponentTuplizerFactory(ComponentTuplizerFactory componentTuplizerFactory) { this.componentTuplizerFactory = componentTuplizerFactory; }	WITHOUT_CLASSIFICATION	0.9999210944384944	WITHOUT_CLASSIFICATION	7.890556150553997E-5	DEFECT
element index -> id	WITHOUT_CLASSIFICATION	0.9999044432703948	WITHOUT_CLASSIFICATION	9.555672960517526E-5	DEFECT
note that it might be better to iterate the snapshot but this is safe, assuming the user implements equals() properly, as required by the Set contract!	WITHOUT_CLASSIFICATION	0.994046635305946	WITHOUT_CLASSIFICATION	0.005953364694054116	DEFECT
collections detect changes made via their public interface and mark themselves as dirty as a performance optimization	WITHOUT_CLASSIFICATION	0.999993757095296	WITHOUT_CLASSIFICATION	6.242904703956366E-6	DEFECT
essentially, if the real session is closed allow any method call to pass through since the real session will complain by throwing an appropriate exception; NOTE that allowing close() above has the same basic effect, but we capture that there simply to perform the unbind...	WITHOUT_CLASSIFICATION	0.9999946621934732	WITHOUT_CLASSIFICATION	5.33780652685616E-6	DEFECT
The default SQLExceptionConverter for all dialects is based on SQLState since SQLErrorCode is extremely vendor-specific. Specific Dialects may override to return whatever is most appropriate for that vendor.	WITHOUT_CLASSIFICATION	0.9999720712908806	WITHOUT_CLASSIFICATION	2.7928709119398622E-5	DEFECT
only necessary for postgre < 7.4 http:anoncvs.postgresql.org/cvsweb.cgi/pgsql/doc/src/sgml/ref/create_sequence.sgml	WITHOUT_CLASSIFICATION	0.9995871659365131	WITHOUT_CLASSIFICATION	4.1283406348689516E-4	DEFECT
select topic, syntax from information_schema.help where section like 'Function%' order by section, topic see also -> http:www.h2database.com/html/functions.html	WITHOUT_CLASSIFICATION	0.9999913577512394	WITHOUT_CLASSIFICATION	8.642248760640506E-6	DEFECT
registerColumnType(Types.VARBINARY, "CHARACTER($l)"); registerColumnType(Types.BLOB, "CHARACTER($l)" ); For use prior to CP 11.0 registerColumnType(Types.CLOB, "CHARACTER($l)" );	WITHOUT_CLASSIFICATION	0.9996557978875313	WITHOUT_CLASSIFICATION	3.442021124686836E-4	DEFECT
the BLOB type requires a size arguement - this defaults to bytes - no arg defaults to 1 whole byte! other argument mods include K - kilobyte, M - megabyte, G - gigabyte. refer to the PBdevelopers guide for more info.	WITHOUT_CLASSIFICATION	0.9998855715082497	WITHOUT_CLASSIFICATION	1.1442849175029299E-4	DEFECT
We must return a valid RDMS/RSA command from this method to prevent RDMS/RSA from issuing ERROR 400	WITHOUT_CLASSIFICATION	0.9999234032210984	WITHOUT_CLASSIFICATION	7.659677890149102E-5	DEFECT
Oracle driver reports to support getGeneratedKeys(), but they only support the version taking an array of the names of the columns to be returned (via its RETURNING clause). No other driver seems to support this overloaded version.	WITHOUT_CLASSIFICATION	0.9999862810725024	WITHOUT_CLASSIFICATION	1.3718927497438153E-5	DEFECT
add the comment nest the main query in an outer select add the rownnumber bit into the outer query select list	WITHOUT_CLASSIFICATION	0.9998143375434756	WITHOUT_CLASSIFICATION	1.8566245652437265E-4	DEFECT
You may still have other ResultSets or update counts left to process here but you can't do it now or the ResultSet you just got will be closed	WITHOUT_CLASSIFICATION	0.9980665341021299	WITHOUT_CLASSIFICATION	0.0019334658978702002	DEFECT
Note: For object <-> SQL datatype mappings see: Configuration Manager | Advanced | SQL | System DDL Datatype Mappings TBDregisterColumnType(Types.BINARY, "binary($1)"); changed 08-11-2005, jsl	WITHOUT_CLASSIFICATION	0.9999828993533977	WITHOUT_CLASSIFICATION	1.7100646602362316E-5	DEFECT
TRIM(end_keyword string-expression-1 FROM string-expression-2) use Hibernate implementation "From" is one of the parameters they pass in position ?3 registerFunction( "trim", new SQLFunctionTemplate(Hibernate.STRING, "trim(?1 ?2 from ?3)") );	WITHOUT_CLASSIFICATION	0.9996016057836359	WITHOUT_CLASSIFICATION	3.983942163641044E-4	DEFECT
Whether this dialect has an Identity clause added to the data type or a completely seperate identity data type	WITHOUT_CLASSIFICATION	0.9998744476631014	WITHOUT_CLASSIFICATION	1.2555233689859324E-4	DEFECT
According to both the ANSI-SQL and JPA specs, trim takes a variable number of parameters between 1 and 4. at least one paramer (trimSource) is required. From the SQL spec: <trim function> ::= TRIM <left paren> <trim operands> <right paren> <trim operands> ::= [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> <trim specification> ::= LEADING | TRAILING | BOTH If <trim specification> is omitted, BOTH is assumed. If <trim character> is omitted, space is assumed	WITHOUT_CLASSIFICATION	0.9999971054460081	WITHOUT_CLASSIFICATION	2.8945539919049284E-6	DEFECT
/ Prepare persisters and link them up with their cache region/access-strategy	WITHOUT_CLASSIFICATION	0.9999791387509752	WITHOUT_CLASSIFICATION	2.086124902479508E-5	DEFECT
Named Queries:	WITHOUT_CLASSIFICATION	0.9998348569953668	WITHOUT_CLASSIFICATION	1.6514300463321878E-4	DEFECT
this will throw an error if there's something wrong.	WITHOUT_CLASSIFICATION	0.9992801440221796	WITHOUT_CLASSIFICATION	7.19855977820378E-4	DEFECT
does not handle arrays (thats ok, cos they can't be lazy) or newly instantiated collections, so we can do the cast	WITHOUT_CLASSIFICATION	0.9999447285498689	WITHOUT_CLASSIFICATION	5.52714501309963E-5	DEFECT
collection deletions are a special case since update() can add deletions of collections not loaded by the session.	WITHOUT_CLASSIFICATION	0.9999491605498549	WITHOUT_CLASSIFICATION	5.083945014507444E-5	DEFECT
we can do the cast since orphan-delete does not apply to: 1. newly instantiated collections 2. arrays (we can't track orphans for detached arrays)	WITHOUT_CLASSIFICATION	0.9996619170721288	WITHOUT_CLASSIFICATION	3.380829278712327E-4	DEFECT
if the natural-id is marked as non-mutable, it is not retrieved during a normal database-snapshot operation...	WITHOUT_CLASSIFICATION	0.998507071351439	WITHOUT_CLASSIFICATION	0.0014929286485609327	DEFECT
watch out for a case where old is still referenced somewhere in the object graph! (which is a user error)	WITHOUT_CLASSIFICATION	0.9998734153902361	WITHOUT_CLASSIFICATION	1.2658460976397657E-4	DEFECT
slice, to get the columns for this component property	WITHOUT_CLASSIFICATION	0.9996417765009152	WITHOUT_CLASSIFICATION	3.582234990846915E-4	DEFECT
int result = 17; result = 37 result + type.hashCode(); result = 37 result + ( value==null ? 0 : value.hashCode() ); return result;	WITHOUT_CLASSIFICATION	0.9998289091528538	WITHOUT_CLASSIFICATION	1.7109084714619422E-4	DEFECT
The CollectionEntry.isReached() stuff is just to detect any silly users who set up circular or shared references between/to collections.	WITHOUT_CLASSIFICATION	0.9999881182917202	WITHOUT_CLASSIFICATION	1.1881708279789889E-5	DEFECT
detached collection wrappers that get found + reattached during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9997908379424653	WITHOUT_CLASSIFICATION	2.0916205753459115E-4	DEFECT
The unique property value represented here may or may not be serializable, so we do an explicit check here in order to generate a better error message	WITHOUT_CLASSIFICATION	0.9993816181322805	WITHOUT_CLASSIFICATION	6.183818677194418E-4	DEFECT
if the version of a newly instantiated object is not the same as the version seed value, use that as the unsaved-value	WITHOUT_CLASSIFICATION	0.9990394998468098	WITHOUT_CLASSIFICATION	9.605001531902098E-4	DEFECT
ie. we never have to null out a reference to an uninitialized proxy	WITHOUT_CLASSIFICATION	0.9999120185618013	WITHOUT_CLASSIFICATION	8.798143819866229E-5	DEFECT
ignore this row, the collection is in process of being loaded somewhere further "up" the stack	WITHOUT_CLASSIFICATION	0.999846265543967	WITHOUT_CLASSIFICATION	1.5373445603289522E-4	DEFECT
Entity load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ currently, not yet used...	WITHOUT_CLASSIFICATION	0.9966545560064782	WITHOUT_CLASSIFICATION	0.003345443993521832	DEFECT
should be ok performance-wise to generate new delegate instances for each request since these are locally stack-scoped. Besides, it makes the code much easier to read than the old TransactionHelper stuff...	WITHOUT_CLASSIFICATION	0.9999314098234376	WITHOUT_CLASSIFICATION	6.859017656237569E-5	DEFECT
this implementation is supposed to tolerate incorrect unsaved-value mappings, for the purpose of backward-compatibility	WITHOUT_CLASSIFICATION	0.9972784646322558	WITHOUT_CLASSIFICATION	0.002721535367744283	DEFECT
this implementation is supposed to tolerate incorrect unsaved-value mappings, for the purpose of backward-compatibility	WITHOUT_CLASSIFICATION	0.9972784646322558	WITHOUT_CLASSIFICATION	0.002721535367744283	DEFECT
wrap up any new collections directly referenced by the object or its components	WITHOUT_CLASSIFICATION	0.9998915658608879	WITHOUT_CLASSIFICATION	1.0843413911213719E-4	DEFECT
remove any snapshot, not really for memory management purposes, but rather because it might now be stale, and there is no longer any EntityEntry to take precedence This is now handled by removeEntity() session.getPersistenceContext().removeDatabaseSnapshot(key);	WITHOUT_CLASSIFICATION	0.9022775897577837	WITHOUT_CLASSIFICATION	0.09772241024221638	DEFECT
skip this check for composite-ids relating to dom4j entity-mode; alternatively, we could add a check to make sure the incoming id value is an instance of Element...	WITHOUT_CLASSIFICATION	0.9999959889041186	WITHOUT_CLASSIFICATION	4.0110958814374445E-6	DEFECT
upgrade the lock if necessary: lock(result, lockMode);	WITHOUT_CLASSIFICATION	0.9999170437461188	WITHOUT_CLASSIFICATION	8.295625388121756E-5	DEFECT
now, any collections that are initialized inside this block do not get updated - they are ignored until the next flush	WITHOUT_CLASSIFICATION	0.9989943741887594	WITHOUT_CLASSIFICATION	0.0010056258112405591	DEFECT
we must clone embedded composite identifiers, or we will get back the same instance that we pass in	WITHOUT_CLASSIFICATION	0.9998411836312289	WITHOUT_CLASSIFICATION	1.5881636877119218E-4	DEFECT
Sub-insertions should occur before containing insertion so Try to do the callback now	WITHOUT_CLASSIFICATION	0.9999305556109701	WITHOUT_CLASSIFICATION	6.944438902996301E-5	DEFECT
the entity is not associated with the session, so try interceptor and unsaved-value	WITHOUT_CLASSIFICATION	0.999950953757324	WITHOUT_CLASSIFICATION	4.9046242675999695E-5	DEFECT
scan the query string for class names appearing in the from clause and replace with all persistent implementors of the class/interface, returning multiple query strings (make sure we don't pick up a class in the select clause!)	WITHOUT_CLASSIFICATION	0.9980507123299261	WITHOUT_CLASSIFICATION	0.001949287670073911	DEFECT
save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997425549310137	WITHOUT_CLASSIFICATION	2.5744506898627733E-4	DEFECT
evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998344488741561	WITHOUT_CLASSIFICATION	1.6555112584392385E-4	DEFECT
stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9997433737678693	WITHOUT_CLASSIFICATION	2.5662623213077243E-4	DEFECT
if it is an uninitialized proxy, pointing with this session, then when it is accessed, the underlying instance will be "contained"	WITHOUT_CLASSIFICATION	0.99960728440782	WITHOUT_CLASSIFICATION	3.9271559218001485E-4	DEFECT
Generate an explicit join for the root dot node. The implied joins will be collected and passed up to the root dot node.	WITHOUT_CLASSIFICATION	0.9998212570059269	WITHOUT_CLASSIFICATION	1.7874299407302078E-4	DEFECT
A session is considered to contain an entity only if the entity has an entry in the session's persistence context and the entry reports that the entity has not been removed	WITHOUT_CLASSIFICATION	0.9993671472926092	WITHOUT_CLASSIFICATION	6.328527073908048E-4	DEFECT
Does the collection referenced by this FromElement specify an order-by attribute? If so, attach it to the query's order-by	WITHOUT_CLASSIFICATION	0.9990042702803926	WITHOUT_CLASSIFICATION	9.95729719607315E-4	DEFECT
... and the token could be an identifer and the error is a mismatched token error ...	WITHOUT_CLASSIFICATION	0.9999686415509795	WITHOUT_CLASSIFICATION	3.135844902051856E-5	DEFECT
If a where clause was specified in the update/delete query, use it to limit the returned ids here...	WITHOUT_CLASSIFICATION	0.9969010331776416	WITHOUT_CLASSIFICATION	0.003098966822358486	DEFECT
int parameterStart = getWalker().getNumberOfParametersInSetClause(); List allParams = getIdSelectParameterSpecifications(); Iterator whereParams = allParams.subList( parameterStart, allParams.size() ).iterator();	WITHOUT_CLASSIFICATION	0.999521544579648	WITHOUT_CLASSIFICATION	4.784554203519788E-4	DEFECT
Default implementation: If this node has a data type, and that data type is not an association, then this is scalar.	WITHOUT_CLASSIFICATION	0.9988817160395191	WITHOUT_CLASSIFICATION	0.00111828396048086	DEFECT
Resolve the LHS fully, generate implicit joins. Pass in the property name so that the resolver can discover foreign key (id) properties.	WITHOUT_CLASSIFICATION	0.9999244788253936	WITHOUT_CLASSIFICATION	7.552117460631515E-5	DEFECT
If the propertyType is null and there isn't a parent, just stop now... there was a problem resolving the node anyway.	WITHOUT_CLASSIFICATION	0.9998196389365979	WITHOUT_CLASSIFICATION	1.8036106340218598E-4	DEFECT
We do not look for an existing join on the same path, because it makes sense to join twice on the same collection role	WITHOUT_CLASSIFICATION	0.9998555497406575	WITHOUT_CLASSIFICATION	1.4445025934249392E-4	DEFECT
our parent is another dot node, meaning we are being further dereferenced. thus we need to generate a join unless the parent refers to the associated entity's PK (because 'our' table would know the FK).	WITHOUT_CLASSIFICATION	0.9995732250103285	WITHOUT_CLASSIFICATION	4.267749896714419E-4	DEFECT
public final Currency getCurrency(int col) throws HibernateException {return (Currency) get(col);}	WITHOUT_CLASSIFICATION	0.9999185649518884	WITHOUT_CLASSIFICATION	8.143504811166699E-5	DEFECT
here, we have two possibilities: 1) the property-name matches the explicitly identifier property name 2) the property-name matches the implicit 'id' property name	WITHOUT_CLASSIFICATION	0.999797105311937	WITHOUT_CLASSIFICATION	2.028946880630473E-4	DEFECT
Set the unresolved path in this node and the parent. Set the text for the parent.	WITHOUT_CLASSIFICATION	0.9999111129238852	WITHOUT_CLASSIFICATION	8.888707611474007E-5	DEFECT
Get the first child to be considered. Sub-classes may do this differently in order to skip nodes that are not select expressions (e.g. DISTINCT).	WITHOUT_CLASSIFICATION	0.9997121939586164	WITHOUT_CLASSIFICATION	2.878060413836035E-4	DEFECT
If this is an entity and the property is the identifier property, then use getIdentifierType(). Note that the propertyName.equals( propertyPath ) checks whether we have a component key reference, where the component class property name is the same as the entity id property name; if the two are not equal, this is the case and we'd need to "fall through" to using the property mapping.	WITHOUT_CLASSIFICATION	0.9994103973223155	WITHOUT_CLASSIFICATION	5.896026776844776E-4	DEFECT
for a subquery, the alias to use depends on a few things (we already know this is not an overall SELECT): 1) if this FROM_ELEMENT represents a correlation to the outer-most query A) if the outer query represents a multi-table persister, we need to use the given alias in anticipation of one of the multi-table executors being used (as this subquery will actually be used in the "id select" phase of that multi-table executor) B) otherwise, we need to use the persister's table name as the column qualification 2) otherwise (not correlated), use the given alias	WITHOUT_CLASSIFICATION	0.9995962843921555	WITHOUT_CLASSIFICATION	4.037156078444407E-4	DEFECT
Not a collection? Return the entity property mapping.	WITHOUT_CLASSIFICATION	0.9993692456781226	WITHOUT_CLASSIFICATION	6.307543218774869E-4	DEFECT
collection of <many-to-any/> mappings... used to circumvent the component-collection check below...	WITHOUT_CLASSIFICATION	0.999987091337005	WITHOUT_CLASSIFICATION	1.2908662994957609E-5	DEFECT
Otherwise, the destination node was implied by the FROM clause and the FROM clause processor will automatically add it in the right place.	WITHOUT_CLASSIFICATION	0.9999303064733421	WITHOUT_CLASSIFICATION	6.969352665784575E-5	DEFECT
If the first identifier in the path referrs to the class alias (not the class name), then this is a correlated subselect. If it's a correlated sub-select, use the existing table alias. Otherwise generate a new one.	WITHOUT_CLASSIFICATION	0.9995136238020695	WITHOUT_CLASSIFICATION	4.863761979305755E-4	DEFECT
check to see if our "propPath" actually represents a property on the persister	WITHOUT_CLASSIFICATION	0.9998366660037246	WITHOUT_CLASSIFICATION	1.633339962754368E-4	DEFECT
An ident node can represent an index expression if the ident represents a naked property ref Note: this makes the assumption (which is currently the case in the hql-sql grammar) that the ident is first resolved itself (addrExpr -> resolve()). The other option, if that changes, is to call resolve from here; but it is currently un-needed overhead.	WITHOUT_CLASSIFICATION	0.9999566908573775	WITHOUT_CLASSIFICATION	4.3309142622566645E-5	DEFECT
This uses a PathExpressionParser but notice that compound paths are not valid, only bare names and simple paths:	WITHOUT_CLASSIFICATION	0.998513053646776	WITHOUT_CLASSIFICATION	0.0014869463532239998	DEFECT
If this is an implied join in a FROM clause, then use ANSI-style joining, and set the flag on the FromElement that indicates that it was implied in the FROM clause itself.	WITHOUT_CLASSIFICATION	0.9999226932738992	WITHOUT_CLASSIFICATION	7.730672610083889E-5	DEFECT
origin.addDestination(destination); Add the query spaces.	WITHOUT_CLASSIFICATION	0.9997354154879191	WITHOUT_CLASSIFICATION	2.6458451208091294E-4	DEFECT
For an explicit many-to-many relationship, add a second join from the intermediate (many-to-many) table to the destination table. Also, make sure that the from element's idea of the destination is the destination table.	WITHOUT_CLASSIFICATION	0.9999745784945983	WITHOUT_CLASSIFICATION	2.5421505401839014E-5	DEFECT
Reset the node type, because the rest of the system is expecting FROM_FRAGMENT, all we wanted was for the factory to create the right sub-class. This might get reset again later on anyway to make the SQL generation simpler.	WITHOUT_CLASSIFICATION	0.9998956676904125	WITHOUT_CLASSIFICATION	1.0433230958760138E-4	DEFECT
explicit = true; This is an explict Select. ArrayList sqlResultTypeList = new ArrayList();	WITHOUT_CLASSIFICATION	0.9997867962973657	WITHOUT_CLASSIFICATION	2.1320370263445816E-4	DEFECT
sqlResultTypeList.add( type ); Generate the select expression.	WITHOUT_CLASSIFICATION	0.9991847079522045	WITHOUT_CLASSIFICATION	8.152920477955397E-4	DEFECT
If the expression list has exactly one expression, and the type of the expression is a collection then this might be a collection function, such as index(c) or size(c).	WITHOUT_CLASSIFICATION	0.9998975834255411	WITHOUT_CLASSIFICATION	1.024165744588879E-4	DEFECT
Need to parse off the column qualifiers; this is assuming (which is true as of now) that this is only used from update and delete HQL statement parsing	WITHOUT_CLASSIFICATION	0.999879617495483	WITHOUT_CLASSIFICATION	1.203825045170168E-4	DEFECT
for regression testing against output from the old parser... found it easiest to simply reorder the FromElements here into ascending order in terms of injecting them into the resulting sql ast in orders relative to those expected by the old parser; this is definitely another of those "only needed for regression purposes". The SyntheticAndFactory, then, simply injects them as it encounters them.	WITHOUT_CLASSIFICATION	0.999874167874359	WITHOUT_CLASSIFICATION	1.258321256410678E-4	DEFECT
The uber-rule here is that we need to include subclass joins if the FromElement is in any way dereferenced by a property from the subclass table; otherwise we end up with column references qualified by a non-existent table reference in the resulting SQL...	WITHOUT_CLASSIFICATION	0.9999939698720244	WITHOUT_CLASSIFICATION	6.030127975648115E-6	DEFECT
classic translator does not support collection of ordinal param metadata	WITHOUT_CLASSIFICATION	0.9987395319847436	WITHOUT_CLASSIFICATION	0.001260468015256289	DEFECT
The following variables are stacks that keep information about each subexpression in the list of nested subexpressions we are currently processing.	WITHOUT_CLASSIFICATION	0.9987139333004348	WITHOUT_CLASSIFICATION	0.0012860666995651508	DEFECT
The loop ensures atomicity of the select + update even for no transaction or read committed isolation level	WITHOUT_CLASSIFICATION	0.99999621037765	WITHOUT_CLASSIFICATION	3.7896223500743027E-6	DEFECT
should not be able to reach last without maxPosition being set unless there are no results	WITHOUT_CLASSIFICATION	0.9975418647952415	WITHOUT_CLASSIFICATION	0.0024581352047583524	DEFECT
we found it in the temp PC. Should indicate we are in the midst of processing a result set containing eager fetches via join fetch	WITHOUT_CLASSIFICATION	0.999984270449673	WITHOUT_CLASSIFICATION	1.572955032704835E-5	DEFECT
do not use proxiesByKey, since not all proxies that point to this session's instances are in that collection!	WITHOUT_CLASSIFICATION	0.9998470084867656	WITHOUT_CLASSIFICATION	1.5299151323446895E-4	DEFECT
if there is no TM configured, we will not be able to access the javax.transaction.Transaction object in order to register a synch anyway.	WITHOUT_CLASSIFICATION	0.9995954139689559	WITHOUT_CLASSIFICATION	4.045860310441111E-4	DEFECT
Since the result set cursor is always left at the first physical row after the "last processed", we need to jump back one position to get the key value we are interested in skipping	WITHOUT_CLASSIFICATION	0.9999976296543155	WITHOUT_CLASSIFICATION	2.370345684447755E-6	DEFECT
true if this is a query and we are loading multiple instances of the same collection role otherwise this is a CollectionInitializer and we are loading up a single collection or batch	WITHOUT_CLASSIFICATION	0.9995564881650839	WITHOUT_CLASSIFICATION	4.435118349161073E-4	DEFECT
we don't need to worry about existing version being uninitialized because this block isn't called by a re-entrant load (re-entrant loads _always_ have lock mode NONE)	WITHOUT_CLASSIFICATION	0.9948384349531189	WITHOUT_CLASSIFICATION	0.005161565046881195	DEFECT
add temp entry so that the next step is circular-reference safe - only needed because some types don't take proper advantage of two-phase-load (esp. components)	WITHOUT_CLASSIFICATION	0.7414790056065855	WITHOUT_CLASSIFICATION	0.2585209943934144	DEFECT
assume we are in an auto-commit state	WITHOUT_CLASSIFICATION	0.99999105848401	WITHOUT_CLASSIFICATION	8.94151599005724E-6	DEFECT
log a message about potential connection leaks	WITHOUT_CLASSIFICATION	0.9988495833929665	WITHOUT_CLASSIFICATION	0.0011504166070334275	DEFECT
ps.close(); just close it; do NOT try to return it to the pool! NOTE: early exit!	WITHOUT_CLASSIFICATION	0.9999996916213112	WITHOUT_CLASSIFICATION	3.083786888206396E-7	DEFECT
this has been shown to happen occasionally in rare cases when using a transaction manager + transaction-timeout where the timeout calls back through Hibernate's registered transaction synchronization on a separate "reaping" thread. In cases where that reaping thread executes through this block at the same time the main application thread does we can get into situations where these CMEs occur. And though it is not "allowed" per-se, the end result without handling it specifically is infinite looping. So here, we simply break the loop	WITHOUT_CLASSIFICATION	0.9987164122890807	WITHOUT_CLASSIFICATION	0.0012835877109192658	DEFECT
unfortunately this stuff can't be cached because it is per-invocation, not constant for the QueryTranslator instance	WITHOUT_CLASSIFICATION	0.9989382839662476	WITHOUT_CLASSIFICATION	0.001061716033752347	DEFECT
can't cache this stuff either (per-invocation) we are given a map of user-alias -> lock mode create a new map of sql-alias -> lock mode	WITHOUT_CLASSIFICATION	0.999975574604414	WITHOUT_CLASSIFICATION	2.4425395585982216E-5	DEFECT
don't create a unique key, 'cos some databases don't like a UK on nullable columns getCollectionTable().createUniqueKey( getIdentifier().getConstraintColumns() );	WITHOUT_CLASSIFICATION	0.9946689476280802	WITHOUT_CLASSIFICATION	0.005331052371919764	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998758361422153	WITHOUT_CLASSIFICATION	1.2416385778477151E-4	DEFECT
isSet = collection.isSet(); isSorted = collection.isSorted();	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
lists, arrays sets, maps, bags	WITHOUT_CLASSIFICATION	0.9999482491072592	WITHOUT_CLASSIFICATION	5.17508927406658E-5	DEFECT
we finish all the "removes" first to take care of possible unique constraints and so that we can take better advantage of batching	WITHOUT_CLASSIFICATION	0.9999989515298884	WITHOUT_CLASSIFICATION	1.0484701115584104E-6	DEFECT
use a combination of foreign key columns and pk columns, since the ordering of removal and addition is not guaranteed when a child moves from one parent to another	WITHOUT_CLASSIFICATION	0.9988297611587632	WITHOUT_CLASSIFICATION	0.00117023884123674	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998758361422153	WITHOUT_CLASSIFICATION	1.2416385778477151E-4	DEFECT
information about properties of this class, including inherited properties (only really needed for updatable/insertable properties)	WITHOUT_CLASSIFICATION	0.9970464740704557	WITHOUT_CLASSIFICATION	0.00295352592954438	DEFECT
all this only really needs to consider properties of this class, not its subclasses, but since we are reusing code used for sequential selects, we use the subclass closure	WITHOUT_CLASSIFICATION	0.9991301584217955	WITHOUT_CLASSIFICATION	8.698415782043956E-4	DEFECT
Here we render the select column list based on the properties defined as being generated. For partial component generation, we currently just re-select the whole component rather than trying to handle the individual generated portions.	WITHOUT_CLASSIFICATION	0.9999867225740239	WITHOUT_CLASSIFICATION	1.327742597620374E-5	DEFECT
this is the root (versioned) table, and we are using version-based optimistic locking; if we are not updating the version, also don't check it (unless this is a "generated" version column)!	WITHOUT_CLASSIFICATION	0.9983491128811688	WITHOUT_CLASSIFICATION	0.001650887118831284	DEFECT
optimistic-lock="all", include all updatable properties optimistic-lock="dirty", include all properties we are updating this time	WITHOUT_CLASSIFICATION	0.9999729680173418	WITHOUT_CLASSIFICATION	2.703198265819423E-5	DEFECT
this property belongs to the table, and it is not specifically excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9968562393059531	WITHOUT_CLASSIFICATION	0.0031437606940469317	DEFECT
check to see if the connection is in auto-commit mode (no connection means aggressive connection release outside a JTA transaction context, so MUST be autocommit mode)	WITHOUT_CLASSIFICATION	0.9999838372091225	WITHOUT_CLASSIFICATION	1.6162790877454776E-5	DEFECT
need to treat this as if it where optimistic-lock="all" (dirty does not make sense); first we need to locate the "loaded" state Note, it potentially could be a proxy, so perform the location the safe way...	WITHOUT_CLASSIFICATION	0.9995797854388899	WITHOUT_CLASSIFICATION	4.202145611101235E-4	DEFECT
we always assume an instance with a null identifier or no identifier property is unsaved!	WITHOUT_CLASSIFICATION	0.9999858701998964	WITHOUT_CLASSIFICATION	1.412980010367756E-5	DEFECT
Need to use the identifier type of the collection owner since the incoming is value is actually the owner's id. Using the collection's key type causes problems with property-ref keys...	WITHOUT_CLASSIFICATION	0.9924229314157524	WITHOUT_CLASSIFICATION	0.00757706858424768	DEFECT
allow any identifier quoted with backtick only recognizes identifiers beginning with a letter	WITHOUT_CLASSIFICATION	0.9997121526683045	WITHOUT_CLASSIFICATION	2.878473316955249E-4	DEFECT
following doesn't handle (null, not null) but unnecessary since this would mean all rows	WITHOUT_CLASSIFICATION	0.9859407993679015	WITHOUT_CLASSIFICATION	0.014059200632098572	DEFECT
IMPL NOTE : due to the delayed population of setters (setters cached for performance), we really cannot pro0perly define equality for this transformer	WITHOUT_CLASSIFICATION	0.9999021540864227	WITHOUT_CLASSIFICATION	9.784591357727916E-5	DEFECT
we need to dirty check collections, since they can cause an owner version number increment	WITHOUT_CLASSIFICATION	0.999964318296566	WITHOUT_CLASSIFICATION	3.568170343405762E-5	DEFECT
return the id, so we can use it to reset the proxy id return result;	WITHOUT_CLASSIFICATION	0.9999945147115643	WITHOUT_CLASSIFICATION	5.48528843575239E-6	DEFECT
optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );	WITHOUT_CLASSIFICATION	0.999473053974349	WITHOUT_CLASSIFICATION	5.26946025651086E-4	DEFECT
cache the actual id of the object, not the value of the property-ref, which might not be initialized	WITHOUT_CLASSIFICATION	0.9993993828876955	WITHOUT_CLASSIFICATION	6.006171123045196E-4	DEFECT
We now have the value of the property-ref we reference. However, we need to dig a little deeper, as that property might also be an entity type, in which case we need to resolve its identitifier	WITHOUT_CLASSIFICATION	0.9997314318447363	WITHOUT_CLASSIFICATION	2.685681552635598E-4	DEFECT
Retrieve the value of the designated column in the current row of this ResultSet object as a java.io.Reader object	WITHOUT_CLASSIFICATION	0.9999885619584512	WITHOUT_CLASSIFICATION	1.1438041548807924E-5	DEFECT
not absolutely necessary, but helps for some equals()/hashCode() implementations	WITHOUT_CLASSIFICATION	0.997622343281731	WITHOUT_CLASSIFICATION	0.0023776567182688395	DEFECT
this should be a call to resolve(), not resolveIdentifier(), 'cos it might be a property-ref, and we did not cache the referenced value	WITHOUT_CLASSIFICATION	0.9954384926956074	WITHOUT_CLASSIFICATION	0.004561507304392649	DEFECT
If we have <tt>not-found="ignore"</tt> association mapped to a formula, we always need to dirty check it, so we can update the second-level cache	WITHOUT_CLASSIFICATION	0.9999947509850298	WITHOUT_CLASSIFICATION	5.24901497023395E-6	DEFECT
can't just return null here, since that would cause an owning component to become null	WITHOUT_CLASSIFICATION	0.9998328450718958	WITHOUT_CLASSIFICATION	1.671549281042539E-4	DEFECT
for arrays, replaceElements() may return a different reference, since the array length might not match	WITHOUT_CLASSIFICATION	0.9996603727028972	WITHOUT_CLASSIFICATION	3.3962729710276785E-4	DEFECT
actual cache of the entries. soft references are used for both the keys and the values here since the values pertaining to the MRU entries are kept in a seperate hard reference cache (to avoid their enqueuement/garbage-collection).	WITHOUT_CLASSIFICATION	0.9999995624083169	WITHOUT_CLASSIFICATION	4.3759168310491737E-7	DEFECT
as soon as we encounter our first letter, return the substring from that position	WITHOUT_CLASSIFICATION	0.9999982746770105	WITHOUT_CLASSIFICATION	1.7253229894523028E-6	DEFECT
Note : expected in the syntax: type=listenerClass ({sep}type=listenerClass) where {sep} is any whitespace or comma	WITHOUT_CLASSIFICATION	0.9999169042179317	WITHOUT_CLASSIFICATION	8.309578206830395E-5	DEFECT
isTransactionCallbackRegistered denotes whether any Hibernate Transaction has registered as a callback against this JDBCContext; only one such callback is allowed. Directly serializing this value causes problems with JDBCTransaction, or really any Transaction impl where the callback is local to the Transaction instance itself, since that Transaction is not serialized along with the JDBCContext. Thus we handle that fact here explicitly...	WITHOUT_CLASSIFICATION	0.9986885960621469	WITHOUT_CLASSIFICATION	0.0013114039378531836	DEFECT
note that for sequential scrolling, we make the assumption that the first persister element is the "root entity"	WITHOUT_CLASSIFICATION	0.9999328324026147	WITHOUT_CLASSIFICATION	6.716759738535721E-5	DEFECT
We call getKeyFromResultSet() here so that we can know the key value upon which to perform the breaking logic. However, it is also then called from getRowFromResultSet() which is certainly not the most efficient. But the call here is needed, and there currently is no other way without refactoring of the doQuery()/getRowFromResultSet() methods	WITHOUT_CLASSIFICATION	0.9965244632120352	WITHOUT_CLASSIFICATION	0.0034755367879647546	DEFECT
This check is needed since processing leaves the cursor after the last physical row for the current logical row; thus if we are after the last physical row, this might be caused by either: 1) scrolling to the last logical row 2) scrolling past the last logical row In the latter scenario, the previous logical row really is the last logical row. In all other cases, we should process back two logical records (the current logic row, plus the previous logical row).	WITHOUT_CLASSIFICATION	0.9999604927434985	WITHOUT_CLASSIFICATION	3.950725650149811E-5	DEFECT
and perform the load	WITHOUT_CLASSIFICATION	0.9999252018474349	WITHOUT_CLASSIFICATION	7.479815256514786E-5	DEFECT
important: reuse the same event instances for performance!	WITHOUT_CLASSIFICATION	0.999781595095886	WITHOUT_CLASSIFICATION	2.1840490411399502E-4	DEFECT
this is a query and we are loading multiple instances of the same collection role	WITHOUT_CLASSIFICATION	0.9987899967305057	WITHOUT_CLASSIFICATION	0.0012100032694942393	DEFECT
we found a collection element in the result set	WITHOUT_CLASSIFICATION	0.9999597365740185	WITHOUT_CLASSIFICATION	4.0263425981514843E-5	DEFECT
we did not find a collection element in the result set, so we ensure that a collection is created with the owner's identifier, since what we have is an empty collection	WITHOUT_CLASSIFICATION	0.9999983389133623	WITHOUT_CLASSIFICATION	1.6610866376607704E-6	DEFECT
this is a collection initializer, so we must create a collection for each of the passed-in keys, to account for the possibility that the collection is empty and has no rows in the result set	WITHOUT_CLASSIFICATION	0.9999990559121511	WITHOUT_CLASSIFICATION	9.440878488408597E-7	DEFECT
grab its state from the ResultSet and keep it in the Session (but don't yet initialize the object itself) note that we acquire LockMode.READ even if it was not requested	WITHOUT_CLASSIFICATION	0.9998055739810371	WITHOUT_CLASSIFICATION	1.9442601896298698E-4	DEFECT
a many-to-many; decrement currentDepth here to allow join across the association table without exceeding MAX_FETCH_DEPTH (i.e. the "currentDepth - 1" bit)	WITHOUT_CLASSIFICATION	0.9994318555584454	WITHOUT_CLASSIFICATION	5.681444415546824E-4	DEFECT
if not a composite key, use "foo in (?, ?, ?)" for batching if no batch, and not a composite key, use "foo = ?"	WITHOUT_CLASSIFICATION	0.9998734408203727	WITHOUT_CLASSIFICATION	1.2655917962736446E-4	DEFECT
the user visible aliases, which are unknown to the superclass, these are not the actual "physical" SQL aliases	WITHOUT_CLASSIFICATION	0.9998858349791258	WITHOUT_CLASSIFICATION	1.1416502087431522E-4	DEFECT
first look for a reference to a projection alias	WITHOUT_CLASSIFICATION	0.9999628443776152	WITHOUT_CLASSIFICATION	3.7155622384831294E-5	DEFECT
first look for a reference to a projection alias	WITHOUT_CLASSIFICATION	0.9999628443776152	WITHOUT_CLASSIFICATION	3.7155622384831294E-5	DEFECT
it does not refer to an alias of a projection, look for a property	WITHOUT_CLASSIFICATION	0.9980507622971069	WITHOUT_CLASSIFICATION	0.0019492377028931494	DEFECT
determine if the collection elements are entities...	WITHOUT_CLASSIFICATION	0.9999788317338514	WITHOUT_CLASSIFICATION	2.1168266148648193E-5	DEFECT
Let return-propertys override whatever the persister has for aliases.	WITHOUT_CLASSIFICATION	0.9998984336470432	WITHOUT_CLASSIFICATION	1.0156635295672664E-4	DEFECT
Translates an AST join type (i.e., the token type) into a JoinFragment.XXX join type. @param astJoinType The AST join type (from HqlSqlTokenTypes or SqlTokenTypes) @return a JoinFragment.XXX join type. @see JoinFragment @see SqlTokenTypes	WITHOUT_CLASSIFICATION	0.9999955743927051	WITHOUT_CLASSIFICATION	4.4256072948762505E-6	DEFECT
ignore	WITHOUT_CLASSIFICATION	0.9999855898485884	WITHOUT_CLASSIFICATION	1.4410151411497693E-5	DEFECT
ignore	WITHOUT_CLASSIFICATION	0.9999855898485884	WITHOUT_CLASSIFICATION	1.4410151411497693E-5	DEFECT
}	WITHOUT_CLASSIFICATION	0.9999814972434341	WITHOUT_CLASSIFICATION	1.850275656585208E-5	DEFECT
public List getCollectionAliases() { return collectionAliases; } public List getCollectionOwners() { return collectionOwners; } public List getCollectionOwnerAliases() { return collectionOwnerAliases; } public List getCollectionPersisters() { return collectionPersisters; } public Map getAlias2Persister() { return alias2Persister; } public boolean isCollectionInitializer() { return isCollectionInitializer; } public List getPersisters() { return persisters; } public Map getAlias2OwnerAlias() { return alias2OwnerAlias; } public List getScalarTypes() { return scalarTypes; } public List getScalarColumnAliases() { return scalarColumnAliases; } public List getPropertyResults() { return propertyResults; } public List getCollectionPropertyResults() { return collectionResults; } public Map getAlias2Return() { return alias2Return; }	WITHOUT_CLASSIFICATION	0.9999928606656134	WITHOUT_CLASSIFICATION	7.139334386525801E-6	DEFECT
SQLQueryParser parser = new SQLQueryParser( sqlQuery, processor.getAlias2Persister(), processor.getAlias2Return(), aliases, collAliases, collPersisters, suffixes, collSuffixes ); sql = parser.process(); namedParameterBindPoints = parser.getNamedParameters();	WITHOUT_CLASSIFICATION	0.9995943515616542	WITHOUT_CLASSIFICATION	4.0564843834582355E-4	DEFECT
include the discriminator and class-level where, but not filters	WITHOUT_CLASSIFICATION	0.9997135651121416	WITHOUT_CLASSIFICATION	2.8643488785848244E-4	DEFECT
sqlAliasSuffixes[i] = element.getColumnAliasSuffix();	WITHOUT_CLASSIFICATION	0.9998310807487872	WITHOUT_CLASSIFICATION	1.6891925121267546E-4	DEFECT
NONE, because its the requested lock mode, not the actual!	WITHOUT_CLASSIFICATION	0.9999036690035042	WITHOUT_CLASSIFICATION	9.63309964958094E-5	DEFECT
at this point we have (drivingSqlAlias) the SQL alias of the driving table corresponding to the given user alias. However, the driving table is not (necessarily) the table against which we want to apply locks. Mainly, the exception case here is joined-subclass hierarchies where we instead want to apply the lock against the root table (for all other strategies, it just happens that driving and root are the same).	WITHOUT_CLASSIFICATION	0.9999687075122025	WITHOUT_CLASSIFICATION	3.129248779750502E-5	DEFECT
the column doesnt exist at all.	WITHOUT_CLASSIFICATION	0.9994014284408358	WITHOUT_CLASSIFICATION	5.985715591642669E-4	DEFECT
we have a mapped identifier property and the root of the incoming property path matched that identifier property	WITHOUT_CLASSIFICATION	0.9998453833847628	WITHOUT_CLASSIFICATION	1.5461661523714657E-4	DEFECT
we have an embedded composite identifier	WITHOUT_CLASSIFICATION	0.9999377771377679	WITHOUT_CLASSIFICATION	6.22228622321843E-5	DEFECT
both many-to-one and one-to-one are represented as a Property. EntityPersister is relying on this value to determine "lazy fetch groups" in terms of field-level interception. So we need to make sure that we return true here for the case of many-to-one and one-to-one with lazy="no-proxy" impl note - lazy="no-proxy" currently forces both lazy and unwrap to be set to true. The other case we are extremely interested in here is that of lazy="proxy" where lazy is set to true, but unwrap is set to false. thus we use both here under the assumption that this return is really only ever used during persister construction to determine the lazy property/field fetch groupings. If that assertion changes then this check needs to change as well. Partially, this is an issue with the overloading of the term "lazy" here...	WITHOUT_CLASSIFICATION	0.9968474814389409	WITHOUT_CLASSIFICATION	0.003152518561059139	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999427809722686	WITHOUT_CLASSIFICATION	5.721902773137628E-5	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999427809722686	WITHOUT_CLASSIFICATION	5.721902773137628E-5	DEFECT
rootTableName = persistentClass.getRootTable().getQualifiedName( factory.getDialect(), factory.getDefaultCatalog(), factory.getDefaultSchema() );	WITHOUT_CLASSIFICATION	0.999473053974349	WITHOUT_CLASSIFICATION	5.26946025651086E-4	DEFECT
SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999767634307712	WITHOUT_CLASSIFICATION	2.3236569228780447E-5	DEFECT
Custom sql	WITHOUT_CLASSIFICATION	0.9999785698045023	WITHOUT_CLASSIFICATION	2.1430195497730878E-5	DEFECT
protected void initPropertyPaths(final String path,final Type type,final String[] columns,final String[] formulaTemplates,final Mapping factory)throws MappingException {addFormulaPropertyPath(path, type, formulaTemplates);initPropertyPaths(path, type, columns, formulaTemplates, factory);}	WITHOUT_CLASSIFICATION	0.9999510360271977	WITHOUT_CLASSIFICATION	4.896397280241311E-5	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
Custom SQL (would be better if these were private)	WITHOUT_CLASSIFICATION	0.9999220337696081	WITHOUT_CLASSIFICATION	7.7966230391995E-5	DEFECT
moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999702174290362	WITHOUT_CLASSIFICATION	2.9782570963802254E-4	DEFECT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'	WITHOUT_CLASSIFICATION	0.9998527782411082	WITHOUT_CLASSIFICATION	1.4722175889183764E-4	DEFECT
decide which ResultSet to get the property value from:	WITHOUT_CLASSIFICATION	0.9999376489049688	WITHOUT_CLASSIFICATION	6.235109503113307E-5	DEFECT
note: it is conceptually possible that a UserType could map null to a non-null value, so the following is arguable:	WITHOUT_CLASSIFICATION	0.9999076580717859	WITHOUT_CLASSIFICATION	9.234192821401555E-5	DEFECT
the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null is an indication that the specified entity-name (this.getEntityName) should be used.	WITHOUT_CLASSIFICATION	0.9999575742042619	WITHOUT_CLASSIFICATION	4.2425795738171056E-5	DEFECT
Need to use the identifier type of the collection owner since the incoming is value is actually the owner's id. Using the collection's key type causes problems with property-ref keys...	WITHOUT_CLASSIFICATION	0.9924229314157524	WITHOUT_CLASSIFICATION	0.00757706858424768	DEFECT
cache these since they are stateless this one could even be static...	WITHOUT_CLASSIFICATION	0.9999933637105062	WITHOUT_CLASSIFICATION	6.6362894937415615E-6	DEFECT
"as" is not in KEYWORDS	WITHOUT_CLASSIFICATION	0.998875860131143	WITHOUT_CLASSIFICATION	0.0011241398688569709	DEFECT
--Commented out by Inspection (12/4/04 9:10 AM): public abstract void addCondition(String alias, String[] columns, String condition);	WITHOUT_CLASSIFICATION	0.9999852985842917	WITHOUT_CLASSIFICATION	1.470141570825736E-5	DEFECT
use the id column alias	WITHOUT_CLASSIFICATION	0.999967547052574	WITHOUT_CLASSIFICATION	3.245294742605908E-5	DEFECT
private List aliases = new ArrayList();	WITHOUT_CLASSIFICATION	0.9998410130887062	WITHOUT_CLASSIFICATION	1.589869112938069E-4	DEFECT
columns.add(columnName); aliases.add(tableAlias);	WITHOUT_CLASSIFICATION	0.9997877681243403	WITHOUT_CLASSIFICATION	2.122318756597141E-4	DEFECT
where fragment must be empty!	WITHOUT_CLASSIFICATION	0.9999530587229264	WITHOUT_CLASSIFICATION	4.694127707359372E-5	DEFECT
revert to traditional hibernate behavior of setting initialPoolSize to minPoolSize unless otherwise specified with a c3p0.-style parameter.	WITHOUT_CLASSIFICATION	0.9999255768803856	WITHOUT_CLASSIFICATION	7.442311961446889E-5	DEFECT
arbitrary on clause ignored!!	WITHOUT_CLASSIFICATION	0.9998904857964799	WITHOUT_CLASSIFICATION	1.0951420352004352E-4	DEFECT
might happen with a managed connection	WITHOUT_CLASSIFICATION	0.9996963422089035	WITHOUT_CLASSIFICATION	3.036577910965321E-4	DEFECT
might happen with a managed connection	WITHOUT_CLASSIFICATION	0.9996963422089035	WITHOUT_CLASSIFICATION	3.036577910965321E-4	DEFECT
if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9998955518571758	WITHOUT_CLASSIFICATION	1.044481428241522E-4	DEFECT
Essentially: 1) If we have a local (Hibernate) transaction in progress and it already has the UserTransaction cached, use that UserTransaction to determine the status. 2) If a transaction manager has been located, use that transaction manager to determine the status. 3) Finally, as the last resort, try to lookup the UserTransaction via JNDI and use that to determine the status.	WITHOUT_CLASSIFICATION	0.9999979120376528	WITHOUT_CLASSIFICATION	2.0879623472811023E-6	DEFECT
package	WITHOUT_CLASSIFICATION	0.9999839843967555	WITHOUT_CLASSIFICATION	1.6015603244533317E-5	DEFECT
swallow it (the transaction _was_ successful or successfully rolled back)	WITHOUT_CLASSIFICATION	0.9997692242121154	WITHOUT_CLASSIFICATION	2.307757878845443E-4	DEFECT
ignore it	WITHOUT_CLASSIFICATION	0.9999813463475701	WITHOUT_CLASSIFICATION	1.8653652429912334E-5	DEFECT
we need to dirty check many-to-ones with not-found="ignore" in order to update the cache (not the database), since in this case a null entity reference can lose information	WITHOUT_CLASSIFICATION	0.9999856614226665	WITHOUT_CLASSIFICATION	1.433857733344591E-5	DEFECT
create our own copy of the user-supplied tuplizer impl map	WITHOUT_CLASSIFICATION	0.9998326955646438	WITHOUT_CLASSIFICATION	1.6730443535605067E-4	DEFECT
Regions can get instantiated in the course of normal work (e.g. a named query region will be created the first time the query is executed), so suspend any ongoing tx	WITHOUT_CLASSIFICATION	0.9999258610192987	WITHOUT_CLASSIFICATION	7.41389807012662E-5	DEFECT
then handle any user-defined entity modes...	WITHOUT_CLASSIFICATION	0.9999649281152586	WITHOUT_CLASSIFICATION	3.507188474142115E-5	DEFECT
Establish the region root node with a non-locking data version	WITHOUT_CLASSIFICATION	0.9996119717814917	WITHOUT_CLASSIFICATION	3.8802821850828504E-4	DEFECT
temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9998627975286344	WITHOUT_CLASSIFICATION	1.3720247136552217E-4	DEFECT
NOTE : this is being used from the process of shutting down a SessionFactory. Specific things to consider: (1) this clearing of the region should not propagate to other nodes on the cluster (if any); this is the cache-mode-local option bit... (2) really just trying a best effort to cleanup after ourselves; lock failures, etc are not critical here; this is the fail-silently option bit...	WITHOUT_CLASSIFICATION	0.9991101463802851	WITHOUT_CLASSIFICATION	8.898536197148769E-4	DEFECT
need to extract the component values and check for subtype replacements...	WITHOUT_CLASSIFICATION	0.9999609104211988	WITHOUT_CLASSIFICATION	3.908957880124331E-5	DEFECT
We ignore minimalPutOverride. JBossCache putForExternalRead is already about as minimal as we can get; it will promptly return if it discovers that the node we want to write to already exists	WITHOUT_CLASSIFICATION	0.9999906364949043	WITHOUT_CLASSIFICATION	9.363505095683894E-6	DEFECT
for now, just "re-flatten" the metamodel since this is temporary stuff anyway (HHH-1907)	WITHOUT_CLASSIFICATION	0.9999890704853076	WITHOUT_CLASSIFICATION	1.0929514692396564E-5	DEFECT
Configure the cache to use our TM	WITHOUT_CLASSIFICATION	0.9999226130671367	WITHOUT_CLASSIFICATION	7.738693286324633E-5	DEFECT
This solution would allow us to eliminate the owner arg to disassemble(), but what if the collection was null, and then later had elements added? seems unsafe session.getPersistenceContext().getCollectionEntry( (PersistentCollection) value ).getKey();	WITHOUT_CLASSIFICATION	0.989041275671472	WITHOUT_CLASSIFICATION	0.01095872432852799	DEFECT
Make sure JBC doesn't look one up	WITHOUT_CLASSIFICATION	0.9997669070881626	WITHOUT_CLASSIFICATION	2.3309291183730538E-4	DEFECT
some collections are not lazy:	WITHOUT_CLASSIFICATION	0.9994109323543499	WITHOUT_CLASSIFICATION	5.890676456501756E-4	DEFECT
Here we don't want to suspend the tx. If we do: 1) We might be caching query results that reflect uncommitted changes. No tx == no WL on cache node, so other threads can prematurely see those query results 2) No tx == immediate replication. More overhead, plus we spread issue #1 above around the cluster	WITHOUT_CLASSIFICATION	0.9881602835682802	WITHOUT_CLASSIFICATION	0.011839716431719723	DEFECT
return the (fully resolved) identifier value, but do not resolve to the actual referenced entity instance NOTE: the owner of the association is not really the owner of the id!	WITHOUT_CLASSIFICATION	0.9999489550303874	WITHOUT_CLASSIFICATION	5.104496961263228E-5	DEFECT
Add a zero (or quite low) timeout option so we don't block. Ignore any TimeoutException. Basically we forego caching the query result in order to avoid blocking. Reads are done with suspended tx, so they should not hold the lock for long. Not caching the query result is OK, since any subsequent read will just see the old result with its out-of-date timestamp; that result will be discarded and the db query performed again.	WITHOUT_CLASSIFICATION	0.9999993126768045	WITHOUT_CLASSIFICATION	6.87323195458595E-7	DEFECT
Impl note: takes advantage of the fact that an escpaed single quote embedded within a quote-block can really be handled as two seperate quote-blocks for the purposes of this method...	WITHOUT_CLASSIFICATION	0.9999876088687948	WITHOUT_CLASSIFICATION	1.2391131205099555E-5	DEFECT
We have the JBCWriteMutex, so no other local thread will be trying to write this key. It's possible here some remote thread has come in and changed the values again, but since we are reading the values to write to JBC right now, we know we are writing the latest values; i.e. we don't assume that what we cached in entry.update() above is what we should write to JBC now. Our write could be redundant, i.e. we are writing what some remote thread just came in an wrote. There is a chance that yet another remote thread will update us, and we'll then overwrite that later data in JBC. But, all remote nodes will ignore that change in their localCache; the only place it will live will be in JBC, where it can only effect the initial state transfer values on newly joined nodes (i.e. populateLocalCache()).	WITHOUT_CLASSIFICATION	0.9999999631732392	WITHOUT_CLASSIFICATION	3.6826760640973177E-8	DEFECT
local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999730417312245	WITHOUT_CLASSIFICATION	2.6958268775457967E-5	DEFECT
local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999730417312245	WITHOUT_CLASSIFICATION	2.6958268775457967E-5	DEFECT
Don't need to lock the cache here, since if someone else inserted the same pk first, the insert would fail	WITHOUT_CLASSIFICATION	0.9992892157244926	WITHOUT_CLASSIFICATION	7.107842755075148E-4	DEFECT
we need to grab the version value from the entity, otherwise we have issues with generated-version entities that may have multiple actions queued during the same flush	WITHOUT_CLASSIFICATION	0.9995721032563025	WITHOUT_CLASSIFICATION	4.2789674369750374E-4	DEFECT
we need to obtain the lock before any actions are executed, since this may be an inverse="true" bidirectional association and it is one of the earlier entity actions which actually updates the database (this action is resposible for second-level cache invalidation only)	WITHOUT_CLASSIFICATION	0.9999478362909701	WITHOUT_CLASSIFICATION	5.2163709029925736E-5	DEFECT
postDelete: After actually deleting a row, record the fact that the instance no longer exists on the database (needed for identity-column key generation), and remove it from the session cache	WITHOUT_CLASSIFICATION	0.9999148304962209	WITHOUT_CLASSIFICATION	8.516950377914355E-5	DEFECT
intentionally empty	WITHOUT_CLASSIFICATION	0.9999436620536992	WITHOUT_CLASSIFICATION	5.6337946300757954E-5	DEFECT
FIXME we don't have the associated entity table name here, has to be done in a second pass	DEFECT	0.9985180132453455	WITHOUT_CLASSIFICATION	0.0014819867546544577	DEFECT
For a one-to-many, a <bag> is not really a bag; it is really a set, since it can't contain the same element twice. It could be considered a bug in the mapping dtd that <bag> allows <one-to-many>.	DEFECT	0.9960158325564772	WITHOUT_CLASSIFICATION	0.00398416744352277	DEFECT
RDMS does not directly support the trim() function, we use rtrim() and ltrim()	DEFECT	0.9996346553264815	WITHOUT_CLASSIFICATION	3.653446735184154E-4	DEFECT
The following types are not supported in RDMS/JDBC and therefore commented out. However, in some cases, mapping them to CHARACTER columns works for many applications, but does not work for all cases.	DEFECT	0.9723819428719837	DEFECT	0.027618057128016373	WITHOUT_CLASSIFICATION
The preference here would be SQLFunctionTemplate( Hibernate.TIMESTAMP, "current_timestamp(?1)", false) but this appears not to work. Jay Nance 2006-09-22	DEFECT	0.508861986248322	DEFECT	0.491138013751678	WITHOUT_CLASSIFICATION
note: at least my local SQL Server 2005 Express shows this not working...	DEFECT	0.9996788559710167	WITHOUT_CLASSIFICATION	3.211440289833598E-4	DEFECT
note: at least my local MySQL 5.1 install shows this not working...	DEFECT	0.9994918298286742	WITHOUT_CLASSIFICATION	5.081701713258695E-4	DEFECT
Algorithm Check for any level one nullability breaks Look at non null components to recursively check next level of nullability breaks Look at Collections contraining component to recursively check next level of nullability breaks In the previous implementation, not-null stuffs where checked filtering by level one only updateable or insertable columns. So setting a sub component as update="false" has no effect on not-null check if the main component had good checkeability In this implementation, we keep this feature. However, I never see any documentation mentioning that, but it's for sure a limitation.	DEFECT	0.9998024401245444	WITHOUT_CLASSIFICATION	1.975598754555879E-4	DEFECT
Don't need this, because we should never ever be selecting no columns in an insert ... select... and because it causes a bug on DB2	DEFECT	0.9963430956730353	WITHOUT_CLASSIFICATION	0.0036569043269647854	DEFECT
TODO : this is broke for subqueries in statements other than selects...	DEFECT	0.8854678483399745	WITHOUT_CLASSIFICATION	0.11453215166002546	DEFECT
TODO : should this be an error?	DEFECT	0.9894901478357641	WITHOUT_CLASSIFICATION	0.010509852164235969	DEFECT
TODO : not sure which (either?) is correct, could not find docs on how to do this. did find various blogs and forums mentioning that select CURRENT_TIMESTAMP does not work...	DEFECT	0.9889268301989126	WITHOUT_CLASSIFICATION	0.011073169801087374	DEFECT
TODO: figure out how this should be set. / This was the reason for failures regarding INDEX_OP and subclass joins on theta-join dialects; not sure what behaviour we were trying to emulate ;) joinSequence = joinSequence.getFromPart(); Emulate the old addFromOnly behavior.	DEFECT	0.7098273984571637	DEFECT	0.2901726015428364	WITHOUT_CLASSIFICATION
TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.6506250000641993	WITHOUT_CLASSIFICATION	0.3493749999358008	DEFECT
TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.6506250000641993	WITHOUT_CLASSIFICATION	0.3493749999358008	DEFECT
TODO: cannot use generateSuffixes() - it handles the initial suffix differently.	DEFECT	0.9301600721829352	WITHOUT_CLASSIFICATION	0.06983992781706487	DEFECT
starts with an alias (old style) semi-bad thing about this: can't re-alias another alias.....	DEFECT	0.9999389553771988	WITHOUT_CLASSIFICATION	6.10446228011757E-5	DEFECT
TODO: BUG! this currently fails for named queries for non-POJO entities	DEFECT	0.7603511338381757	DEFECT	0.23964886616182438	WITHOUT_CLASSIFICATION
this call is side-effecty	DEFECT	0.9998775082458605	WITHOUT_CLASSIFICATION	1.224917541395728E-4	DEFECT
TODO: old version did not require hashmap lookup: keys[collectionOwner].getIdentifier()	DEFECT	0.9247464465674226	DEFECT	0.07525355343257749	WITHOUT_CLASSIFICATION
TODO: when this is the entry point, we should use an INNER_JOIN for fetching the many-to-many elements!	DEFECT	0.8926021728435042	WITHOUT_CLASSIFICATION	0.10739782715649586	DEFECT
this is only needed (afaict) for processing results from the query cache; however, this cannot possibly work in the case of discovered types...	DEFECT	0.7965939482624672	WITHOUT_CLASSIFICATION	0.2034060517375327	DEFECT
TODO: this requires that the collection is defined after the referenced property in the mapping file (ok?)	DEFECT	0.9768001124649698	WITHOUT_CLASSIFICATION	0.023199887535030286	DEFECT
TODO: is this completely correct?	DEFECT	0.7823748074031702	WITHOUT_CLASSIFICATION	0.21762519259682983	DEFECT
three general cases we check here as to whether to render a physical SQL join: 1) is our parent a DotNode as well? If so, our property reference is being further de-referenced... 2) is this a DML statement 3) we were asked to generate any needed joins (generateJoins==true) OR we are currently processing a select or from clause (an additional check is the REGRESSION_STYLE_JOIN_SUPPRESSION check solely intended for the test suite) The REGRESSION_STYLE_JOIN_SUPPRESSION is an additional check intended solely for use within the test suite. This forces the implicit join resolution to behave more like the classic parser. The underlying issue is that classic translator is simply wrong about its decisions on whether or not to render an implicit join into a physical SQL join in a lot of cases. The piece it generally tends to miss is that INNER joins effect the results by further restricting the data set! A particular manifestation of this is the fact that the classic translator will skip the physical join for ToOne implicit joins if the query is shallow; the result being that Query.list() and Query.iterate() could return different number of results!	DEFECT	0.8688897720187303	DEFECT	0.13111022798126964	WITHOUT_CLASSIFICATION
TODO : currently we really do not handle ValueInclusion.PARTIAL... ValueInclusion.PARTIAL would indicate parts of a component need to be included in the select; currently we then just render the entire component into the select clause in that case.	DEFECT	0.9740277779281663	WITHOUT_CLASSIFICATION	0.025972222071833664	DEFECT
TODO: inexact, what we really need to know is: are any outer joins used?	DEFECT	0.9500860996259946	WITHOUT_CLASSIFICATION	0.04991390037400549	DEFECT
todo : this call will not work for anything other than pojos!	DEFECT	0.5188835492824373	WITHOUT_CLASSIFICATION	0.48111645071756265	DEFECT
TODO: currently we don't know a SessionFactory reference when building the Tuplizer THIS IS A BUG (embedded-xml=false on component) TODO : fix this after HHH-1907 is complete	DEFECT	0.9996835698951684	DEFECT	3.1643010483163527E-4	WITHOUT_CLASSIFICATION
TODO: this disables laziness even in non-pojo entity modes:	DEFECT	0.6414749963972165	WITHOUT_CLASSIFICATION	0.3585250036027836	DEFECT
TODO: currently broken for unique-key references (does not detect change to unique key property of the associated object) the owner of the association is not the owner of the id	DEFECT	0.7359057162415333	DEFECT	0.2640942837584667	WITHOUT_CLASSIFICATION
TODO: entities CAN be compared, by PK, fix this! -> only if/when we can extract the id values....	DEFECT	0.8050307231700067	WITHOUT_CLASSIFICATION	0.19496927682999327	DEFECT
TODO: entities CAN be compared, by PK and entity name, fix this!	DEFECT	0.6466633739541094	WITHOUT_CLASSIFICATION	0.35333662604589067	DEFECT
TODO: this is kinda inconsistent with CollectionType	DEFECT	0.742165069541869	WITHOUT_CLASSIFICATION	0.2578349304581311	DEFECT
TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.6506250000641993	WITHOUT_CLASSIFICATION	0.3493749999358008	DEFECT
TODO: does not work for EntityMode.DOM4J yet!	DEFECT	0.9837142106848581	DEFECT	0.016285789315141887	WITHOUT_CLASSIFICATION
TODO: currently broken for unique-key references (does not detect change to unique key property of the associated object)	DEFECT	0.7226896809127304	DEFECT	0.27731031908726944	WITHOUT_CLASSIFICATION
TODO: not really completely correct, since the uoe could occur while resolving associations, leaving the PC in an inconsistent state	DEFECT	0.9868241362795248	WITHOUT_CLASSIFICATION	0.0131758637204753	DEFECT
could happen for custom Criteria impls. Not likely, but... for long term solution, see HHH-3514	DEFECT	0.9988479884038802	WITHOUT_CLASSIFICATION	0.001152011596119698	DEFECT
This does not support the Cache SQL 'DISTINCT BY (comma-list)' extensions, but this extension is not supported through Hibernate anyway.	DEFECT	0.9814867705232653	WITHOUT_CLASSIFICATION	0.018513229476734717	DEFECT
note that this timestamp is not correct if the connection provider returns an older JDBC connection that was associated with a transaction that was already begun before openSession() was called (don't know any possible solution to this!)	DEFECT	0.9985684013089675	WITHOUT_CLASSIFICATION	0.0014315986910325047	DEFECT
no need to take a snapshot - this is a performance optimization, but not really important, except for entities with huge mutable property values	DEFECT	0.9983280134542714	WITHOUT_CLASSIFICATION	0.0016719865457286546	DEFECT
TODO : this really needs to be delayed unitl after we definitively know the operand node type; where this is currently a problem is parameters for which where we cannot unequivocally resolve an expected type	DEFECT	0.9681627986634933	WITHOUT_CLASSIFICATION	0.03183720133650667	DEFECT
First, validate all the enabled filters... TODO: this implementation has bad performance	DEFECT	0.7070443048969839	WITHOUT_CLASSIFICATION	0.292955695103016	DEFECT
TODO: what if batchUpdate is a callablestatement ? calls executeBatch()	DEFECT	0.8829002775717262	WITHOUT_CLASSIFICATION	0.11709972242827384	DEFECT
assume that the row was not there since it previously had only null values, so do an INSERT instead TODO: does not respect dynamic-insert	DEFECT	0.9830476627148069	WITHOUT_CLASSIFICATION	0.016952337285193103	DEFECT
TODO: passing null here, because this method is not really used for DOM4J at the moment but it is still a bug, if we don't get rid of this!	DEFECT	0.9117886953716824	WITHOUT_CLASSIFICATION	0.08821130462831762	DEFECT
note that this implementation is kinda broken for components with many-to-one associations	DEFECT	0.995208875050081	WITHOUT_CLASSIFICATION	0.004791124949919025	DEFECT
TODO: at the point where we are resolving collection references, we don't know if the uk value has been resolved (depends if it was earlier or later in the mapping document) - now, we could try and use e.getStatus() to decide to semiResolve(), trouble is that initializeEntity() reuses the same array for resolved and hydrated values	DEFECT	0.9981031658795567	WITHOUT_CLASSIFICATION	0.0018968341204432895	DEFECT
TODO: This is assertion is disabled because there is a bug that means the original owner of a transient, uninitialized collection is not known if the collection is re-referenced by a different object associated with the current Session throw new AssertionFailure("bug loading unowned collection");	DEFECT	0.6894074828869377	DEFECT	0.3105925171130624	WITHOUT_CLASSIFICATION
This doesn't actually seem to work but it might work on some dbs. Also it doesn't work if there are multiple columns of results because it is not accounting for the suffix: return new String[] { getDiscriminatorColumnName() };	DEFECT	0.8154443556601771	DEFECT	0.1845556443398228	WITHOUT_CLASSIFICATION
TODO: Deal with the "optional" attribute in the <join> mapping; this code assumes that optional defaults to "true" because it doesn't actually seem to work in the fetch="join" code Note that actual proper handling of optional-ality here is actually more involved than this patch assumes. Remember that we might have multiple <join/> mappings associated with a single entity. Really a couple of things need to happen to properly handle optional here: 1) First and foremost, when handling multiple <join/>s, we really should be using the entity root table as the driving table; another option here would be to choose some non-optional joined table to use as the driving table. In all likelihood, just using the root table is much simplier 2) Need to add the FK columns corresponding to each joined table to the generated select list; these would then be used when iterating the result set to determine whether all non-optional data is present My initial thoughts on the best way to deal with this would be to introduce a new SequentialSelect abstraction that actually gets generated in the persisters (ok, SingleTable...) and utilized here. It would encapsulated all this required optional-ality checking...	DEFECT	0.9999936299004077	DEFECT	6.370099592184746E-6	WITHOUT_CLASSIFICATION
