//test out the optimizer:	WITHOUT_CLASSIFICATION	0.99999999462809	WITHOUT_CLASSIFICATION	5.37191002517778E-9	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
/* | this | bean | args | raw bean | */	WITHOUT_CLASSIFICATION	0.9999968439718936	WITHOUT_CLASSIFICATION	3.156028106333418E-6	DEFECT
// invokeinterface	WITHOUT_CLASSIFICATION	0.9999997252139589	WITHOUT_CLASSIFICATION	2.747860411221148E-7	DEFECT
// astore 4 // store the raw bean	WITHOUT_CLASSIFICATION	0.9999999582945387	WITHOUT_CLASSIFICATION	4.170546132409935E-8	DEFECT
/* current stack len = 0 */	WITHOUT_CLASSIFICATION	0.999994333513429	WITHOUT_CLASSIFICATION	5.666486570937788E-6	DEFECT
/* current stack len = 0 */	WITHOUT_CLASSIFICATION	0.999994333513429	WITHOUT_CLASSIFICATION	5.666486570937788E-6	DEFECT
/* local variables | target obj | each oldvalue | */	WITHOUT_CLASSIFICATION	0.9999999758996918	WITHOUT_CLASSIFICATION	2.410030822152278E-8	DEFECT
// invokeinterface // invoke Enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9999990974249233	WITHOUT_CLASSIFICATION	9.025750768072409E-7	DEFECT
// putfield // new value of the field	WITHOUT_CLASSIFICATION	0.99999975060355	WITHOUT_CLASSIFICATION	2.4939645006337494E-7	DEFECT
// reference type	WITHOUT_CLASSIFICATION	0.9999961103361368	WITHOUT_CLASSIFICATION	3.889663863173932E-6	DEFECT
// double	WITHOUT_CLASSIFICATION	0.9999928861394599	WITHOUT_CLASSIFICATION	7.1138605402061765E-6	DEFECT
// double	WITHOUT_CLASSIFICATION	0.9999928861394599	WITHOUT_CLASSIFICATION	7.1138605402061765E-6	DEFECT
// long	WITHOUT_CLASSIFICATION	0.9999314032376156	WITHOUT_CLASSIFICATION	6.859676238436045E-5	DEFECT
// just decrement the lock, don't recache // (we don't know which transaction won)	WITHOUT_CLASSIFICATION	0.999999953637425	WITHOUT_CLASSIFICATION	4.636257498366518E-8	DEFECT
// decode row selection...	WITHOUT_CLASSIFICATION	0.9998181195818986	WITHOUT_CLASSIFICATION	1.8188041810133726E-4	DEFECT
//disassembled state gets put in a new array (we write to cache by value!)	WITHOUT_CLASSIFICATION	0.9999891346096558	WITHOUT_CLASSIFICATION	1.0865390344209113E-5	DEFECT
// again, CCS did not have such a concept; but a reasonable // proximity is to clear the cache after transaction *as long as* // the underlying cache is not JTA aware.	WITHOUT_CLASSIFICATION	0.9999998637022656	WITHOUT_CLASSIFICATION	1.3629773441609232E-7	DEFECT
// CHECK	WITHOUT_CLASSIFICATION	0.9999992197428444	WITHOUT_CLASSIFICATION	7.802571555448704E-7	DEFECT
// ROW ID	WITHOUT_CLASSIFICATION	0.9999794463029585	WITHOUT_CLASSIFICATION	2.055369704135215E-5	DEFECT
// COMPOSITE-ID	WITHOUT_CLASSIFICATION	0.9999995099234557	WITHOUT_CLASSIFICATION	4.900765443139515E-7	DEFECT
// DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9999982806023665	WITHOUT_CLASSIFICATION	1.7193976335232055E-6	DEFECT
/*	WITHOUT_CLASSIFICATION	0.9935009427489204	WITHOUT_CLASSIFICATION	0.006499057251079584	DEFECT
// DYNAMIC INSERT	WITHOUT_CLASSIFICATION	0.9999997506366409	WITHOUT_CLASSIFICATION	2.493633590542286E-7	DEFECT
// PERSISTER	WITHOUT_CLASSIFICATION	0.9999993995385631	WITHOUT_CLASSIFICATION	6.004614368767224E-7	DEFECT
// get meta's from <subclass>	WITHOUT_CLASSIFICATION	0.9999993399730408	WITHOUT_CLASSIFICATION	6.600269592692501E-7	DEFECT
// PROPERTIES	WITHOUT_CLASSIFICATION	0.9999993176881365	WITHOUT_CLASSIFICATION	6.823118634709873E-7	DEFECT
// PROPERTIES	WITHOUT_CLASSIFICATION	0.9999993176881365	WITHOUT_CLASSIFICATION	6.823118634709873E-7	DEFECT
// generated properties can *never* be insertable...	WITHOUT_CLASSIFICATION	0.9999843362316448	WITHOUT_CLASSIFICATION	1.566376835513617E-5	DEFECT
// TABLE	WITHOUT_CLASSIFICATION	0.9999930994006406	WITHOUT_CLASSIFICATION	6.900599359467886E-6	DEFECT
//by default, natural-ids are "immutable" (constant)	WITHOUT_CLASSIFICATION	0.9999999502509058	WITHOUT_CLASSIFICATION	4.974909424998554E-8	DEFECT
// ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);	WITHOUT_CLASSIFICATION	0.9999983985398765	WITHOUT_CLASSIFICATION	1.601460123503361E-6	DEFECT
// we found some extends attributes referencing entities which were // not already processed.  here we need to locate all entity-names // and class-names contained in this document itself, making sure // that these get removed from the extendz list such that only // extends names which require us to delay processing (i.e. // external to this document and not yet processed) are contained // in the returned result	WITHOUT_CLASSIFICATION	0.9999999374660812	WITHOUT_CLASSIFICATION	6.253391879079021E-8	DEFECT
/**	WITHOUT_CLASSIFICATION	0.5238510211901031	WITHOUT_CLASSIFICATION	0.47614897880989693	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
/**	WITHOUT_CLASSIFICATION	0.5238510211901031	WITHOUT_CLASSIFICATION	0.47614897880989693	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// If close() is called, guarantee unbind()	WITHOUT_CLASSIFICATION	0.9999992712253492	WITHOUT_CLASSIFICATION	7.287746508602442E-7	DEFECT
// if a ThreadLocalSessionContext-bound session happens to get // serialized, to be completely correct, we need to make sure // that unbinding of that session occurs.	WITHOUT_CLASSIFICATION	0.9999786893623458	WITHOUT_CLASSIFICATION	2.131063765427284E-5	DEFECT
// on the inverse, it makes sense that if a ThreadLocalSessionContext- // bound session then gets deserialized to go ahead and re-bind it to // the ThreadLocalSessionContext session map.	WITHOUT_CLASSIFICATION	0.9999999945881373	WITHOUT_CLASSIFICATION	5.41186278133597E-9	DEFECT
//cannot be instantiated	WITHOUT_CLASSIFICATION	0.9999988920392295	WITHOUT_CLASSIFICATION	1.1079607705184335E-6	DEFECT
// 60 second lock timeout	WITHOUT_CLASSIFICATION	0.9999976883670673	WITHOUT_CLASSIFICATION	2.3116329326329336E-6	DEFECT
// OptimisticCache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999999893710953	WITHOUT_CLASSIFICATION	1.0628904688566707E-7	DEFECT
// Cache impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999985978436461	WITHOUT_CLASSIFICATION	1.4021563539461477E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// do the put outside the scope of the JTA txn	WITHOUT_CLASSIFICATION	0.9999991622704748	WITHOUT_CLASSIFICATION	8.37729525105928E-7	DEFECT
//ignore!	WITHOUT_CLASSIFICATION	0.9999559841318182	WITHOUT_CLASSIFICATION	4.40158681817504E-5	DEFECT
// tree cache in optimistic mode seems to have as very difficult // time with remove calls on non-existent nodes (NPEs)...	WITHOUT_CLASSIFICATION	0.9524853374388382	WITHOUT_CLASSIFICATION	0.047514662561161804	DEFECT
//60 seconds	WITHOUT_CLASSIFICATION	0.9999893301372668	WITHOUT_CLASSIFICATION	1.066986273322824E-5	DEFECT
//ignore!	WITHOUT_CLASSIFICATION	0.9999559841318182	WITHOUT_CLASSIFICATION	4.40158681817504E-5	DEFECT
//60 seconds	WITHOUT_CLASSIFICATION	0.9999893301372668	WITHOUT_CLASSIFICATION	1.066986273322824E-5	DEFECT
//do the failfast put outside the scope of the JTA txn	WITHOUT_CLASSIFICATION	0.9999970501150612	WITHOUT_CLASSIFICATION	2.9498849388183157E-6	DEFECT
// NOTE : evict() operates locally only (i.e., does not propogate // to any other nodes in the potential cluster).  This is // exactly what is needed when we destroy() here; destroy() is used // as part of the process of shutting down a SessionFactory; thus // these removals should not be propogated	WITHOUT_CLASSIFICATION	0.9999994583067204	WITHOUT_CLASSIFICATION	5.416932796316163E-7	DEFECT
//    protected RegionRootListener listener;	WITHOUT_CLASSIFICATION	0.9999994905846967	WITHOUT_CLASSIFICATION	5.094153031636854E-7	DEFECT
// Establish the region root node with a non-locking data version	WITHOUT_CLASSIFICATION	0.9999988224298142	WITHOUT_CLASSIFICATION	1.1775701858929255E-6	DEFECT
// If we've been blocking for the mutex, perhaps another // thread has already reestablished the root. // In case the node was reestablised via replication, confirm it's  // marked "resident" (a status which doesn't replicate)	WITHOUT_CLASSIFICATION	0.9999999714952427	WITHOUT_CLASSIFICATION	2.8504757340647238E-8	DEFECT
// For pessimistic locking, we just want to toss out our ref // to any old invalid root node and get the latest (may be null)            	WITHOUT_CLASSIFICATION	0.9999999897205786	WITHOUT_CLASSIFICATION	1.0279421484413758E-8	DEFECT
// The rest only matters for optimistic locking, where we // need to establish the proper data version on the region root	WITHOUT_CLASSIFICATION	0.9999708607838864	WITHOUT_CLASSIFICATION	2.91392161135752E-5	DEFECT
// Don't hold a transactional lock for this 	WITHOUT_CLASSIFICATION	0.9998906882745742	WITHOUT_CLASSIFICATION	1.093117254259353E-4	DEFECT
// Make sure the root node for the region exists and  // has a DataVersion that never complains	WITHOUT_CLASSIFICATION	0.9999998363212257	WITHOUT_CLASSIFICATION	1.6367877428495683E-7	DEFECT
// Never evict this node	WITHOUT_CLASSIFICATION	0.9999999476430371	WITHOUT_CLASSIFICATION	5.235696289638308E-8	DEFECT
// Fix up the resident flag	WITHOUT_CLASSIFICATION	0.9999953481514742	WITHOUT_CLASSIFICATION	4.6518485258740014E-6	DEFECT
// 60 seconds	WITHOUT_CLASSIFICATION	0.9999946456419397	WITHOUT_CLASSIFICATION	5.354358060211482E-6	DEFECT
// We ignore minimalPutOverride. JBossCache putForExternalRead is // already about as minimal as we can get; it will promptly return // if it discovers that the node we want to write to already exists	WITHOUT_CLASSIFICATION	0.9999996632682996	WITHOUT_CLASSIFICATION	3.367317004386725E-7	DEFECT
// no-op. We don't own the cache so we shouldn't stop it.	WITHOUT_CLASSIFICATION	0.9999988189441874	WITHOUT_CLASSIFICATION	1.1810558126153544E-6	DEFECT
// This should only be possible if the caches are constructor injected 	WITHOUT_CLASSIFICATION	0.999999757912876	WITHOUT_CLASSIFICATION	2.420871240153876E-7	DEFECT
// We only build caches if *none* were passed in.  Passing in // caches counts as a clear statement of exactly what is wanted	WITHOUT_CLASSIFICATION	0.9999934049489313	WITHOUT_CLASSIFICATION	6.595051068623284E-6	DEFECT
// Set up the cache factory	WITHOUT_CLASSIFICATION	0.9999994649832095	WITHOUT_CLASSIFICATION	5.350167905483588E-7	DEFECT
// See if the user configured a multiplexer stack	WITHOUT_CLASSIFICATION	0.9999972282865423	WITHOUT_CLASSIFICATION	2.771713457788067E-6	DEFECT
// Default to collections sharing entity cache if there is one	WITHOUT_CLASSIFICATION	0.9999998415388524	WITHOUT_CLASSIFICATION	1.5846114761450537E-7	DEFECT
// Default to sharing the entity cache if there is one	WITHOUT_CLASSIFICATION	0.9999998916274365	WITHOUT_CLASSIFICATION	1.0837256343644031E-7	DEFECT
// For Timestamps, we default to a separate config	WITHOUT_CLASSIFICATION	0.9999998697164678	WITHOUT_CLASSIFICATION	1.3028353219749336E-7	DEFECT
// We can't change the TM on a running cache; just check // if the cache has no TM and we're OK with that	WITHOUT_CLASSIFICATION	0.9999999999615586	WITHOUT_CLASSIFICATION	3.844145991140564E-11	DEFECT
// Configure the cache to use our TM	WITHOUT_CLASSIFICATION	0.9999999834593661	WITHOUT_CLASSIFICATION	1.6540633854809293E-8	DEFECT
// Make sure JBC doesn't look one up	WITHOUT_CLASSIFICATION	0.9999949367385129	WITHOUT_CLASSIFICATION	5.063261487057169E-6	DEFECT
// This method should be implemented assuming it's valid to  // do start/stop/start -- leave state appropriate for another start	WITHOUT_CLASSIFICATION	0.999985832599713	WITHOUT_CLASSIFICATION	1.416740028700574E-5	DEFECT
// Make sure we don't re-release the same cache	WITHOUT_CLASSIFICATION	0.9999997493148122	WITHOUT_CLASSIFICATION	2.506851878317477E-7	DEFECT
// We use a different delegate than the non-optimistic superclass default	WITHOUT_CLASSIFICATION	0.9999999991174491	WITHOUT_CLASSIFICATION	8.82550960274574E-10	DEFECT
// Following methods we don't delegate since they have so little logic // it's clearer to just implement them here	WITHOUT_CLASSIFICATION	0.9999999736386543	WITHOUT_CLASSIFICATION	2.6361345581273794E-8	DEFECT
// If JBC is using INVALIDATION, we don't want to propagate changes. // We use the Timestamps cache to manage invalidation	WITHOUT_CLASSIFICATION	0.9999999643935349	WITHOUT_CLASSIFICATION	3.560646513232063E-8	DEFECT
// We don't want to waste effort setting an option if JBC is // already in LOCAL mode. If JBC is REPL_(A)SYNC then check // if they passed an config option to disable query replication	WITHOUT_CLASSIFICATION	0.9999999945684864	WITHOUT_CLASSIFICATION	5.431513553928423E-9	DEFECT
// Don't hold the JBC node lock throughout the tx, as that // prevents updates // Add a zero (or low) timeout option so we don't block // waiting for tx's that did a put to commit	WITHOUT_CLASSIFICATION	0.9999999948975442	WITHOUT_CLASSIFICATION	5.102455861928648E-9	DEFECT
// Double check the distributed cache	WITHOUT_CLASSIFICATION	0.9999999980498329	WITHOUT_CLASSIFICATION	1.9501671140231756E-9	DEFECT
// Get an exclusive right to update JBC for this key from this node.	WITHOUT_CLASSIFICATION	0.9999920461103765	WITHOUT_CLASSIFICATION	7.953889623422838E-6	DEFECT
// We ensure ASYNC semantics (JBCACHE-1175)	WITHOUT_CLASSIFICATION	0.9999988191090242	WITHOUT_CLASSIFICATION	1.180890975769717E-6	DEFECT
// Initial load from JBC	WITHOUT_CLASSIFICATION	0.9999959812072269	WITHOUT_CLASSIFICATION	4.01879277321411E-6	DEFECT
// See if we had a 2nd invalidation from the same initial // preinvalidation timestamp. If so, only increment // if the new current value is an increase	WITHOUT_CLASSIFICATION	0.9999999683862709	WITHOUT_CLASSIFICATION	3.161372903808006E-8	DEFECT
// We ensure ASYNC semantics (JBCACHE-1175)	WITHOUT_CLASSIFICATION	0.9999988191090242	WITHOUT_CLASSIFICATION	1.180890975769717E-6	DEFECT
// If the workspace node has null as well, OK; if not we've // been modified in a non-comparable manner, which we have to // treat as us being newer	WITHOUT_CLASSIFICATION	0.9999993200477608	WITHOUT_CLASSIFICATION	6.799522391919509E-7	DEFECT
// The standard comparator types are not Serializable but are singletons	WITHOUT_CLASSIFICATION	0.9999959130963054	WITHOUT_CLASSIFICATION	4.0869036945513454E-6	DEFECT
// ignore!	WITHOUT_CLASSIFICATION	0.9999976303852054	WITHOUT_CLASSIFICATION	2.369614794582419E-6	DEFECT
// ignore it	WITHOUT_CLASSIFICATION	0.9999995583482444	WITHOUT_CLASSIFICATION	4.416517556879499E-7	DEFECT
// construct the cache	WITHOUT_CLASSIFICATION	0.9999999332846276	WITHOUT_CLASSIFICATION	6.671537250490464E-8	DEFECT
// local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999954346108603	WITHOUT_CLASSIFICATION	4.565389139697805E-6	DEFECT
// local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999954346108603	WITHOUT_CLASSIFICATION	4.565389139697805E-6	DEFECT
//ie. 60 seconds	WITHOUT_CLASSIFICATION	0.999988464484154	WITHOUT_CLASSIFICATION	1.1535515845885471E-5	DEFECT
//swaldman 2006-08-28: define c3p0-style configuration parameters for initialPoolSize, which //                     hibernate sensibly lets default to minPoolSize, but we'll let users //                     override it with the c3p0-style property if they want.	WITHOUT_CLASSIFICATION	0.9999996550779248	WITHOUT_CLASSIFICATION	3.449220752484732E-7	DEFECT
/*DataSource unpooled = DataSources.unpooledDataSource(	WITHOUT_CLASSIFICATION	0.9999896383791705	WITHOUT_CLASSIFICATION	1.036162082947147E-5	DEFECT
// TRUE if the pool is borrowed from the outside, FALSE if we used to create it	WITHOUT_CLASSIFICATION	0.9999999985964536	WITHOUT_CLASSIFICATION	1.4035463217003238E-9	DEFECT
// get a connection from the pool (thru DriverManager, cfr. Proxool doc)	WITHOUT_CLASSIFICATION	0.999999420021208	WITHOUT_CLASSIFICATION	5.799787919544493E-7	DEFECT
// set the Transaction Isolation if defined	WITHOUT_CLASSIFICATION	0.9999999927710632	WITHOUT_CLASSIFICATION	7.22893680334681E-9	DEFECT
// toggle autoCommit to false if set	WITHOUT_CLASSIFICATION	0.9999995468786504	WITHOUT_CLASSIFICATION	4.531213496612322E-7	DEFECT
// return the connection	WITHOUT_CLASSIFICATION	0.9999936437521281	WITHOUT_CLASSIFICATION	6.356247871973547E-6	DEFECT
// Get the configurator files (if available)	WITHOUT_CLASSIFICATION	0.9999999908516009	WITHOUT_CLASSIFICATION	9.148399176590974E-9	DEFECT
// Default the Proxool alias setting	WITHOUT_CLASSIFICATION	0.9999999670171107	WITHOUT_CLASSIFICATION	3.298288921089811E-8	DEFECT
// Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999999929420517	WITHOUT_CLASSIFICATION	7.057948367210384E-9	DEFECT
// Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999999929420517	WITHOUT_CLASSIFICATION	7.057948367210384E-9	DEFECT
// Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9999811921255632	WITHOUT_CLASSIFICATION	1.8807874436831417E-5	DEFECT
// Set the existing pool flag to true	WITHOUT_CLASSIFICATION	0.9999978393845149	WITHOUT_CLASSIFICATION	2.1606154849435146E-6	DEFECT
// Configured using the JAXP Configurator	WITHOUT_CLASSIFICATION	0.9999999055034022	WITHOUT_CLASSIFICATION	9.449659780364985E-8	DEFECT
// Validate that an alias name was provided to determine which pool to use	WITHOUT_CLASSIFICATION	0.9999999929420517	WITHOUT_CLASSIFICATION	7.057948367210384E-9	DEFECT
// Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9999811921255632	WITHOUT_CLASSIFICATION	1.8807874436831417E-5	DEFECT
// Append the stem to the proxool pool alias	WITHOUT_CLASSIFICATION	0.9999811921255632	WITHOUT_CLASSIFICATION	1.8807874436831417E-5	DEFECT
// Configured using the Properties File Configurator	WITHOUT_CLASSIFICATION	0.9999999924783396	WITHOUT_CLASSIFICATION	7.521660368839159E-9	DEFECT
// Remember Isolation level	WITHOUT_CLASSIFICATION	0.9999976417635034	WITHOUT_CLASSIFICATION	2.3582364966313012E-6	DEFECT
// If the provider was leeching off an existing pool don't close it	WITHOUT_CLASSIFICATION	0.9999986725260284	WITHOUT_CLASSIFICATION	1.3274739716057193E-6	DEFECT
// We have created the pool ourselves, so shut it down	WITHOUT_CLASSIFICATION	0.999999991404708	WITHOUT_CLASSIFICATION	8.595292066433273E-9	DEFECT
// not really a many-to-one association *necessarily*	WITHOUT_CLASSIFICATION	0.999997259151364	WITHOUT_CLASSIFICATION	2.7408486359989415E-6	DEFECT
// not really a many-to-one association *necessarily*	WITHOUT_CLASSIFICATION	0.999997259151364	WITHOUT_CLASSIFICATION	2.7408486359989415E-6	DEFECT
//always overwrite nonversioned data	WITHOUT_CLASSIFICATION	0.9999999318414791	WITHOUT_CLASSIFICATION	6.81585209565175E-8	DEFECT
//public Currency getCurrency(int col) throws HibernateException;	WITHOUT_CLASSIFICATION	0.9999976649360719	WITHOUT_CLASSIFICATION	2.3350639279995146E-6	DEFECT
// default is POJO	WITHOUT_CLASSIFICATION	0.9999985485145982	WITHOUT_CLASSIFICATION	1.4514854017441278E-6	DEFECT
// use setParameter for null values	WITHOUT_CLASSIFICATION	0.9999988227873874	WITHOUT_CLASSIFICATION	1.1772126127016312E-6	DEFECT
// use setParameter for null values	WITHOUT_CLASSIFICATION	0.9999988227873874	WITHOUT_CLASSIFICATION	1.1772126127016312E-6	DEFECT
//private CacheEntry cacheEntry;	WITHOUT_CLASSIFICATION	0.999997720370014	WITHOUT_CLASSIFICATION	2.2796299860228473E-6	DEFECT
// Don't need to lock the cache here, since if someone // else inserted the same pk first, the insert would fail	WITHOUT_CLASSIFICATION	0.9999532301903759	WITHOUT_CLASSIFICATION	4.676980962417627E-5	DEFECT
//Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!	WITHOUT_CLASSIFICATION	0.9999279010421285	WITHOUT_CLASSIFICATION	7.20989578714954E-5	DEFECT
// get the updated snapshot of the entity state by cloning current state; // it is safe to copy in place, since by this time no-one else (should have) // has a reference  to the array	WITHOUT_CLASSIFICATION	0.9999999914977574	WITHOUT_CLASSIFICATION	8.5022426057491E-9	DEFECT
// this entity defines proeprty generation, so process those generated // values...	WITHOUT_CLASSIFICATION	0.9999999812273842	WITHOUT_CLASSIFICATION	1.877261584849849E-8	DEFECT
// have the entity entry perform post-update processing, passing it the // update state and the new version (if one).	WITHOUT_CLASSIFICATION	0.9999999106077565	WITHOUT_CLASSIFICATION	8.939224353212925E-8	DEFECT
/*!persister.isCacheInvalidationRequired()*/	WITHOUT_CLASSIFICATION	0.999971129365876	WITHOUT_CLASSIFICATION	2.8870634124070466E-5	DEFECT
// need to look it up from the persistence-context	WITHOUT_CLASSIFICATION	0.9999998472287125	WITHOUT_CLASSIFICATION	1.5277128743658327E-7	DEFECT
//sort first by role name	WITHOUT_CLASSIFICATION	0.999999323551872	WITHOUT_CLASSIFICATION	6.764481280820854E-7	DEFECT
//Make 100% certain that this is called before any subsequent ScheduledUpdate.afterTransactionCompletion()!!	WITHOUT_CLASSIFICATION	0.9999279010421285	WITHOUT_CLASSIFICATION	7.20989578714954E-5	DEFECT
//then by fk	WITHOUT_CLASSIFICATION	0.9999637537083969	WITHOUT_CLASSIFICATION	3.624629160312677E-5	DEFECT
// nothing to do	WITHOUT_CLASSIFICATION	0.9999959201644073	WITHOUT_CLASSIFICATION	4.079835592713896E-6	DEFECT
// nothing to do	WITHOUT_CLASSIFICATION	0.9999959201644073	WITHOUT_CLASSIFICATION	4.079835592713896E-6	DEFECT
// an existing collection that was either non-empty or uninitialized // is replaced by null or a different collection // (if the collection is uninitialized, hibernate has no way of // knowing if the collection is actually empty without querying the db)	WITHOUT_CLASSIFICATION	0.9999999763487399	WITHOUT_CLASSIFICATION	2.365126008838234E-8	DEFECT
// this method is called when a new non-null collection is persisted // or when an existing (non-null) collection is moved to a new owner	WITHOUT_CLASSIFICATION	0.9999996642465987	WITHOUT_CLASSIFICATION	3.357534012358111E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flush	WITHOUT_CLASSIFICATION	0.9999833357043038	WITHOUT_CLASSIFICATION	1.6664295696288508E-5	DEFECT
//do nothing - we only need to notify the cache...	WITHOUT_CLASSIFICATION	0.9999486150057293	WITHOUT_CLASSIFICATION	5.13849942705892E-5	DEFECT
//sort first by entity name	WITHOUT_CLASSIFICATION	0.9999998978484237	WITHOUT_CLASSIFICATION	1.021515763148841E-7	DEFECT
//then by id	WITHOUT_CLASSIFICATION	0.9999823319240597	WITHOUT_CLASSIFICATION	1.7668075940199845E-5	DEFECT
// to be safe...	WITHOUT_CLASSIFICATION	0.9988549958931344	WITHOUT_CLASSIFICATION	0.0011450041068656372	DEFECT
// no transformations took place, so handle it as we would a // non-instrumented class	WITHOUT_CLASSIFICATION	0.9999999995394269	WITHOUT_CLASSIFICATION	4.605731871928705E-10	DEFECT
// see if the entry represents a class file	WITHOUT_CLASSIFICATION	0.9999998677402853	WITHOUT_CLASSIFICATION	1.3225971475967583E-7	DEFECT
// see if the entry represents a class file	WITHOUT_CLASSIFICATION	0.9999998677402853	WITHOUT_CLASSIFICATION	1.3225971475967583E-7	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
//test out the optimizer:	WITHOUT_CLASSIFICATION	0.99999999462809	WITHOUT_CLASSIFICATION	5.37191002517778E-9	DEFECT
// set the name of bulk accessor.	WITHOUT_CLASSIFICATION	0.9999996776024337	WITHOUT_CLASSIFICATION	3.223975663426935E-7	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// invokespecial	WITHOUT_CLASSIFICATION	0.9999998548703145	WITHOUT_CLASSIFICATION	1.4512968537691918E-7	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
// aload_1 // load bean	WITHOUT_CLASSIFICATION	0.9999983526241857	WITHOUT_CLASSIFICATION	1.6473758142063218E-6	DEFECT
// checkcast // cast bean	WITHOUT_CLASSIFICATION	0.9999999318960009	WITHOUT_CLASSIFICATION	6.810399911168447E-8	DEFECT
// astore_3 // store bean	WITHOUT_CLASSIFICATION	0.9999999424494271	WITHOUT_CLASSIFICATION	5.7550572777439926E-8	DEFECT
// aload_2 // args	WITHOUT_CLASSIFICATION	0.9999989572636514	WITHOUT_CLASSIFICATION	1.0427363485779724E-6	DEFECT
// iconst_i // continue to aastore // growing stack is 1	WITHOUT_CLASSIFICATION	0.9999407617511037	WITHOUT_CLASSIFICATION	5.9238248896333005E-5	DEFECT
// new	WITHOUT_CLASSIFICATION	0.9999969402286792	WITHOUT_CLASSIFICATION	3.0597713208022207E-6	DEFECT
// dup	WITHOUT_CLASSIFICATION	0.999990889221058	WITHOUT_CLASSIFICATION	9.110778941995677E-6	DEFECT
// aload_3 // load the raw bean	WITHOUT_CLASSIFICATION	0.999999221594504	WITHOUT_CLASSIFICATION	7.784054959266372E-7	DEFECT
// invokeinterface	WITHOUT_CLASSIFICATION	0.9999997252139589	WITHOUT_CLASSIFICATION	2.747860411221148E-7	DEFECT
// invokevirtual	WITHOUT_CLASSIFICATION	0.9999995293294721	WITHOUT_CLASSIFICATION	4.7067052793547883E-7	DEFECT
// invokevirtual	WITHOUT_CLASSIFICATION	0.9999995293294721	WITHOUT_CLASSIFICATION	4.7067052793547883E-7	DEFECT
// aastore // args	WITHOUT_CLASSIFICATION	0.9999998316962674	WITHOUT_CLASSIFICATION	1.6830373261571423E-7	DEFECT
/* | this | bean | args | i | raw bean | exception | */	WITHOUT_CLASSIFICATION	0.9999936000516403	WITHOUT_CLASSIFICATION	6.399948359707434E-6	DEFECT
// required to exception table // iconst_0 // i	WITHOUT_CLASSIFICATION	0.9999992053785393	WITHOUT_CLASSIFICATION	7.946214607357228E-7	DEFECT
// istore_3 // store i	WITHOUT_CLASSIFICATION	0.9999997330870912	WITHOUT_CLASSIFICATION	2.669129087361969E-7	DEFECT
// aload_1 // load the bean	WITHOUT_CLASSIFICATION	0.9999991702289145	WITHOUT_CLASSIFICATION	8.297710854109808E-7	DEFECT
// checkcast // cast the bean into a raw bean	WITHOUT_CLASSIFICATION	0.9999999571157143	WITHOUT_CLASSIFICATION	4.288428572683053E-8	DEFECT
/* current stack len = 0 */	WITHOUT_CLASSIFICATION	0.999994333513429	WITHOUT_CLASSIFICATION	5.666486570937788E-6	DEFECT
// start region to handling exception (BulkAccessorException)	WITHOUT_CLASSIFICATION	0.9999997377602521	WITHOUT_CLASSIFICATION	2.6223974795030027E-7	DEFECT
// iinc 3, 1	WITHOUT_CLASSIFICATION	0.999998747648282	WITHOUT_CLASSIFICATION	1.2523517179864416E-6	DEFECT
// aload 4 // load the raw bean	WITHOUT_CLASSIFICATION	0.9999987922300118	WITHOUT_CLASSIFICATION	1.2077699882472511E-6	DEFECT
// aload_2 // load the args	WITHOUT_CLASSIFICATION	0.9999995402668906	WITHOUT_CLASSIFICATION	4.597331094585503E-7	DEFECT
// iconst_i	WITHOUT_CLASSIFICATION	0.9999984290531363	WITHOUT_CLASSIFICATION	1.570946863708898E-6	DEFECT
// aaload	WITHOUT_CLASSIFICATION	0.9999967396509736	WITHOUT_CLASSIFICATION	3.260349026494432E-6	DEFECT
// checkcast	WITHOUT_CLASSIFICATION	0.9999999475152762	WITHOUT_CLASSIFICATION	5.2484723692549256E-8	DEFECT
// checkcast (case of primitive type) // invokevirtual (case of primitive type)	WITHOUT_CLASSIFICATION	0.9999998885403746	WITHOUT_CLASSIFICATION	1.1145962531512242E-7	DEFECT
// checkcast (case of reference type)	WITHOUT_CLASSIFICATION	0.9999997304830487	WITHOUT_CLASSIFICATION	2.6951695126579544E-7	DEFECT
/* current stack len = 2 */	WITHOUT_CLASSIFICATION	0.9999893261713824	WITHOUT_CLASSIFICATION	1.067382861763463E-5	DEFECT
// end region to handling exception (BulkAccessorException)	WITHOUT_CLASSIFICATION	0.9999987859961476	WITHOUT_CLASSIFICATION	1.2140038524925462E-6	DEFECT
// register in exception table	WITHOUT_CLASSIFICATION	0.9999999309715725	WITHOUT_CLASSIFICATION	6.902842755698711E-8	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// aload_0	WITHOUT_CLASSIFICATION	0.9999972871247781	WITHOUT_CLASSIFICATION	2.7128752219847356E-6	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
// dup	WITHOUT_CLASSIFICATION	0.999990889221058	WITHOUT_CLASSIFICATION	9.110778941995677E-6	DEFECT
// invokevirtual	WITHOUT_CLASSIFICATION	0.9999995293294721	WITHOUT_CLASSIFICATION	4.7067052793547883E-7	DEFECT
// checkcast	WITHOUT_CLASSIFICATION	0.9999999475152762	WITHOUT_CLASSIFICATION	5.2484723692549256E-8	DEFECT
/* local variables | target obj | each oldvalue | */	WITHOUT_CLASSIFICATION	0.9999999758996918	WITHOUT_CLASSIFICATION	2.410030822152278E-8	DEFECT
// astore 5 // store exception	WITHOUT_CLASSIFICATION	0.9999994983523244	WITHOUT_CLASSIFICATION	5.016476756190433E-7	DEFECT
// new // BulkAccessorException	WITHOUT_CLASSIFICATION	0.9999011277222105	WITHOUT_CLASSIFICATION	9.887227778941111E-5	DEFECT
// aload 5 // load exception	WITHOUT_CLASSIFICATION	0.9999849931729027	WITHOUT_CLASSIFICATION	1.500682709734722E-5	DEFECT
// iload_3 // i	WITHOUT_CLASSIFICATION	0.9999967467602644	WITHOUT_CLASSIFICATION	3.253239735701769E-6	DEFECT
// invokespecial // BulkAccessorException.<init>	WITHOUT_CLASSIFICATION	0.9999961239460102	WITHOUT_CLASSIFICATION	3.87605398976134E-6	DEFECT
// athrow	WITHOUT_CLASSIFICATION	0.9999970241843791	WITHOUT_CLASSIFICATION	2.9758156208806744E-6	DEFECT
// WARNING: classfile only	WITHOUT_CLASSIFICATION	0.9998744892342799	WITHOUT_CLASSIFICATION	1.255107657200799E-4	DEFECT
//swallow	WITHOUT_CLASSIFICATION	0.9999785941468675	WITHOUT_CLASSIFICATION	2.1405853132476257E-5	DEFECT
/* local variable | this | */	WITHOUT_CLASSIFICATION	0.9999999259823176	WITHOUT_CLASSIFICATION	7.401768248318515E-8	DEFECT
// aload_0 // load this	WITHOUT_CLASSIFICATION	0.9999989238343013	WITHOUT_CLASSIFICATION	1.0761656985861824E-6	DEFECT
// aload_0 // load this	WITHOUT_CLASSIFICATION	0.9999989238343013	WITHOUT_CLASSIFICATION	1.0761656985861824E-6	DEFECT
// getfield // get field "$JAVASSIST_CALLBACK" defined already	WITHOUT_CLASSIFICATION	0.9999999970853913	WITHOUT_CLASSIFICATION	2.914608694094584E-9	DEFECT
// areturn // return the value of the field	WITHOUT_CLASSIFICATION	0.9999991992448755	WITHOUT_CLASSIFICATION	8.007551246173136E-7	DEFECT
/* local variables | this | callback | */	WITHOUT_CLASSIFICATION	0.999989392438425	WITHOUT_CLASSIFICATION	1.0607561575013888E-5	DEFECT
// aload_1 // load callback	WITHOUT_CLASSIFICATION	0.999969375412679	WITHOUT_CLASSIFICATION	3.0624587320906024E-5	DEFECT
// putfield // put field "$JAVASSIST_CALLBACK" defined already	WITHOUT_CLASSIFICATION	0.9999999985024569	WITHOUT_CLASSIFICATION	1.49754311973743E-9	DEFECT
// case of non-static field	WITHOUT_CLASSIFICATION	0.9999999166224436	WITHOUT_CLASSIFICATION	8.337755634250551E-8	DEFECT
// getfield // get each field	WITHOUT_CLASSIFICATION	0.9999999211179182	WITHOUT_CLASSIFICATION	7.888208176970815E-8	DEFECT
// invokeinterface // invoke Enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9999990974249233	WITHOUT_CLASSIFICATION	9.025750768072409E-7	DEFECT
// ifnonnull	WITHOUT_CLASSIFICATION	0.9999932854410587	WITHOUT_CLASSIFICATION	6.714558941384327E-6	DEFECT
// *return // each type	WITHOUT_CLASSIFICATION	0.9999995259966602	WITHOUT_CLASSIFICATION	4.74003339905831E-7	DEFECT
// *return // each type	WITHOUT_CLASSIFICATION	0.9999995259966602	WITHOUT_CLASSIFICATION	4.74003339905831E-7	DEFECT
// *store_1 // each type	WITHOUT_CLASSIFICATION	0.9999999466511507	WITHOUT_CLASSIFICATION	5.334884932410389E-8	DEFECT
// ldc // name of the field	WITHOUT_CLASSIFICATION	0.9999995081875384	WITHOUT_CLASSIFICATION	4.918124616171076E-7	DEFECT
// *load_1 // each type	WITHOUT_CLASSIFICATION	0.9999992571419197	WITHOUT_CLASSIFICATION	7.428580801717345E-7	DEFECT
// invokeinterface // invoke Callback.read*() // each type	WITHOUT_CLASSIFICATION	0.9999930977751003	WITHOUT_CLASSIFICATION	6.902224899831052E-6	DEFECT
// int	WITHOUT_CLASSIFICATION	0.9999947018609256	WITHOUT_CLASSIFICATION	5.29813907428964E-6	DEFECT
// return	WITHOUT_CLASSIFICATION	0.9999984346286717	WITHOUT_CLASSIFICATION	1.565371328345249E-6	DEFECT
// dup	WITHOUT_CLASSIFICATION	0.999990889221058	WITHOUT_CLASSIFICATION	9.110778941995677E-6	DEFECT
// invokeinterface	WITHOUT_CLASSIFICATION	0.9999997252139589	WITHOUT_CLASSIFICATION	2.747860411221148E-7	DEFECT
// checkcast	WITHOUT_CLASSIFICATION	0.9999999475152762	WITHOUT_CLASSIFICATION	5.2484723692549256E-8	DEFECT
// checkcast	WITHOUT_CLASSIFICATION	0.9999999475152762	WITHOUT_CLASSIFICATION	5.2484723692549256E-8	DEFECT
// invokeinterface // enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9999995723702438	WITHOUT_CLASSIFICATION	4.27629756062853E-7	DEFECT
// invokeinterface // enabled.getInterceptFieldCallback()	WITHOUT_CLASSIFICATION	0.9999995723702438	WITHOUT_CLASSIFICATION	4.27629756062853E-7	DEFECT
// ifnonnull (label1)	WITHOUT_CLASSIFICATION	0.9999998422705099	WITHOUT_CLASSIFICATION	1.5772949019638803E-7	DEFECT
// *load_1	WITHOUT_CLASSIFICATION	0.9999966694372333	WITHOUT_CLASSIFICATION	3.3305627667878264E-6	DEFECT
// *load_1	WITHOUT_CLASSIFICATION	0.9999966694372333	WITHOUT_CLASSIFICATION	3.3305627667878264E-6	DEFECT
// putfield	WITHOUT_CLASSIFICATION	0.9999997311694387	WITHOUT_CLASSIFICATION	2.6883056127731666E-7	DEFECT
// return ;	WITHOUT_CLASSIFICATION	0.9999989743714518	WITHOUT_CLASSIFICATION	1.0256285482554746E-6	DEFECT
// ldc // field name	WITHOUT_CLASSIFICATION	0.9999997991566955	WITHOUT_CLASSIFICATION	2.0084330444785468E-7	DEFECT
// getfield // old value of the field	WITHOUT_CLASSIFICATION	0.9999976103401201	WITHOUT_CLASSIFICATION	2.389659879825344E-6	DEFECT
// invokeinterface // callback.write*(..)	WITHOUT_CLASSIFICATION	0.9999632923464875	WITHOUT_CLASSIFICATION	3.6707653512468376E-5	DEFECT
// reference type	WITHOUT_CLASSIFICATION	0.9999961103361368	WITHOUT_CLASSIFICATION	3.889663863173932E-6	DEFECT
// reference type	WITHOUT_CLASSIFICATION	0.9999961103361368	WITHOUT_CLASSIFICATION	3.889663863173932E-6	DEFECT
// not array	WITHOUT_CLASSIFICATION	0.9999824723111587	WITHOUT_CLASSIFICATION	1.752768884136007E-5	DEFECT
// array of reference type	WITHOUT_CLASSIFICATION	0.9999913928359262	WITHOUT_CLASSIFICATION	8.607164073825109E-6	DEFECT
// boolean	WITHOUT_CLASSIFICATION	0.9999991111783268	WITHOUT_CLASSIFICATION	8.88821673056443E-7	DEFECT
// byte	WITHOUT_CLASSIFICATION	0.9999966175478578	WITHOUT_CLASSIFICATION	3.3824521421910136E-6	DEFECT
// char	WITHOUT_CLASSIFICATION	0.9999998683111562	WITHOUT_CLASSIFICATION	1.3168884380361297E-7	DEFECT
// short	WITHOUT_CLASSIFICATION	0.9999989746542369	WITHOUT_CLASSIFICATION	1.0253457631352017E-6	DEFECT
// double	WITHOUT_CLASSIFICATION	0.9999928861394599	WITHOUT_CLASSIFICATION	7.1138605402061765E-6	DEFECT
// float	WITHOUT_CLASSIFICATION	0.9999892380209168	WITHOUT_CLASSIFICATION	1.076197908333047E-5	DEFECT
// float	WITHOUT_CLASSIFICATION	0.9999892380209168	WITHOUT_CLASSIFICATION	1.076197908333047E-5	DEFECT
// long	WITHOUT_CLASSIFICATION	0.9999314032376156	WITHOUT_CLASSIFICATION	6.859676238436045E-5	DEFECT
// long	WITHOUT_CLASSIFICATION	0.9999314032376156	WITHOUT_CLASSIFICATION	6.859676238436045E-5	DEFECT
// bad type	WITHOUT_CLASSIFICATION	0.9999953348962756	WITHOUT_CLASSIFICATION	4.6651037243619795E-6	DEFECT
// bad type	WITHOUT_CLASSIFICATION	0.9999953348962756	WITHOUT_CLASSIFICATION	4.6651037243619795E-6	DEFECT
// boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9999999767333653	WITHOUT_CLASSIFICATION	2.326663472627567E-8	DEFECT
// boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9999999767333653	WITHOUT_CLASSIFICATION	2.326663472627567E-8	DEFECT
// reference type	WITHOUT_CLASSIFICATION	0.9999961103361368	WITHOUT_CLASSIFICATION	3.889663863173932E-6	DEFECT
// double	WITHOUT_CLASSIFICATION	0.9999928861394599	WITHOUT_CLASSIFICATION	7.1138605402061765E-6	DEFECT
// float	WITHOUT_CLASSIFICATION	0.9999892380209168	WITHOUT_CLASSIFICATION	1.076197908333047E-5	DEFECT
// float	WITHOUT_CLASSIFICATION	0.9999892380209168	WITHOUT_CLASSIFICATION	1.076197908333047E-5	DEFECT
// long	WITHOUT_CLASSIFICATION	0.9999314032376156	WITHOUT_CLASSIFICATION	6.859676238436045E-5	DEFECT
// bad type	WITHOUT_CLASSIFICATION	0.9999953348962756	WITHOUT_CLASSIFICATION	4.6651037243619795E-6	DEFECT
// bad type	WITHOUT_CLASSIFICATION	0.9999953348962756	WITHOUT_CLASSIFICATION	4.6651037243619795E-6	DEFECT
// boolean, byte, char, int, short	WITHOUT_CLASSIFICATION	0.9999999767333653	WITHOUT_CLASSIFICATION	2.326663472627567E-8	DEFECT
// skip finalize methods	WITHOUT_CLASSIFICATION	0.9999996462141099	WITHOUT_CLASSIFICATION	3.537858901481901E-7	DEFECT
//Mainly for OSCache	WITHOUT_CLASSIFICATION	0.9999987960015501	WITHOUT_CLASSIFICATION	1.2039984499374927E-6	DEFECT
//decrement the lock	WITHOUT_CLASSIFICATION	0.9999882584257208	WITHOUT_CLASSIFICATION	1.1741574279228451E-5	DEFECT
// create new lock that times out immediately	WITHOUT_CLASSIFICATION	0.999997903409526	WITHOUT_CLASSIFICATION	2.0965904739245018E-6	DEFECT
//recache the updated state	WITHOUT_CLASSIFICATION	0.9999999873397609	WITHOUT_CLASSIFICATION	1.2660239139834986E-8	DEFECT
// noop	WITHOUT_CLASSIFICATION	0.9999953782256491	WITHOUT_CLASSIFICATION	4.621774350914133E-6	DEFECT
//null clientLock is remotely possible but will never happen in practice	WITHOUT_CLASSIFICATION	0.9999090221429986	WITHOUT_CLASSIFICATION	9.097785700146982E-5	DEFECT
// we really could refresh the item if it // is not a lock, but it might be slower //return freshTimestamp < txTimestamp	WITHOUT_CLASSIFICATION	0.9873693462640339	WITHOUT_CLASSIFICATION	0.01263065373596605	DEFECT
//by requiring <, we rely on lock timeout in the case of an unsuccessful update!	WITHOUT_CLASSIFICATION	0.9993719632306393	WITHOUT_CLASSIFICATION	6.280367693607017E-4	DEFECT
// the user provided resulttransformer, not the one used with "select new". Here to avoid mangling // transformed/non-transformed results.	WITHOUT_CLASSIFICATION	0.9999999308628544	WITHOUT_CLASSIFICATION	6.913714556360998E-8	DEFECT
// disassemble positional parameters	WITHOUT_CLASSIFICATION	0.9999931765758826	WITHOUT_CLASSIFICATION	6.823424117393791E-6	DEFECT
// disassemble named parameters	WITHOUT_CLASSIFICATION	0.9999996422718954	WITHOUT_CLASSIFICATION	3.5772810463782695E-7	DEFECT
//ie. 60 seconds	WITHOUT_CLASSIFICATION	0.999988464484154	WITHOUT_CLASSIFICATION	1.1535515845885471E-5	DEFECT
// noop	WITHOUT_CLASSIFICATION	0.9999953782256491	WITHOUT_CLASSIFICATION	4.621774350914133E-6	DEFECT
//noop	WITHOUT_CLASSIFICATION	0.9999060456973579	WITHOUT_CLASSIFICATION	9.395430264206286E-5	DEFECT
//noop	WITHOUT_CLASSIFICATION	0.9999060456973579	WITHOUT_CLASSIFICATION	9.395430264206286E-5	DEFECT
// this is called from SettingsFactory irregardless; trivial to simply disregard	WITHOUT_CLASSIFICATION	0.9999682955296645	WITHOUT_CLASSIFICATION	3.1704470335493175E-5	DEFECT
// Do nothing; subclasses may override.	WITHOUT_CLASSIFICATION	0.9999997492015055	WITHOUT_CLASSIFICATION	2.50798494526313E-7	DEFECT
// Do nothing; subclasses may override.	WITHOUT_CLASSIFICATION	0.9999997492015055	WITHOUT_CLASSIFICATION	2.50798494526313E-7	DEFECT
//throw new UnsupportedOperationException("Can't write to a readonly object");	WITHOUT_CLASSIFICATION	0.9999866527158651	WITHOUT_CLASSIFICATION	1.3347284134816354E-5	DEFECT
//assembled state gets put in a new array (we read from cache by value!)	WITHOUT_CLASSIFICATION	0.9999774082528126	WITHOUT_CLASSIFICATION	2.2591747187518767E-5	DEFECT
//persister.setIdentifier(result, id); //before calling interceptor, for consistency with normal load	WITHOUT_CLASSIFICATION	0.9999844863816756	WITHOUT_CLASSIFICATION	1.5513618324399757E-5	DEFECT
// no-op; CCS did not have such a concept	WITHOUT_CLASSIFICATION	0.999999723522706	WITHOUT_CLASSIFICATION	2.7647729390678294E-7	DEFECT
// no-op; CCS did not have such a concept	WITHOUT_CLASSIFICATION	0.999999723522706	WITHOUT_CLASSIFICATION	2.7647729390678294E-7	DEFECT
// again, CCS did not have such a concept; but a reasonable // proximity is to clear the cache after transaction *as long as* // the underlying cache is not JTA aware.	WITHOUT_CLASSIFICATION	0.9999998637022656	WITHOUT_CLASSIFICATION	1.3629773441609232E-7	DEFECT
// again, CCS did not have such a concept; however a reasonable // proximity is to clear the cache.  For non-transaction aware // caches, we will also do a clear at the end of the transaction	WITHOUT_CLASSIFICATION	0.9999953879470497	WITHOUT_CLASSIFICATION	4.612052950320728E-6	DEFECT
// again, CCS did not have such a concept; however a reasonable // proximity is to clear the cache.  For non-transaction aware // caches, we will also do a clear at the end of the transaction	WITHOUT_CLASSIFICATION	0.9999953879470497	WITHOUT_CLASSIFICATION	4.612052950320728E-6	DEFECT
// classes mentioned in extends not available - so put it in queue	WITHOUT_CLASSIFICATION	0.9999979971492975	WITHOUT_CLASSIFICATION	2.002850702556986E-6	DEFECT
// get meta's from <hibernate-mapping>	WITHOUT_CLASSIFICATION	0.999999796276023	WITHOUT_CLASSIFICATION	2.037239769945857E-7	DEFECT
// get meta's from <class>	WITHOUT_CLASSIFICATION	0.999999128112808	WITHOUT_CLASSIFICATION	8.718871918996065E-7	DEFECT
// DB-OBJECTNAME	WITHOUT_CLASSIFICATION	0.9999985719285607	WITHOUT_CLASSIFICATION	1.428071439363155E-6	DEFECT
// MUTABLE	WITHOUT_CLASSIFICATION	0.9999987831228061	WITHOUT_CLASSIFICATION	1.21687719387918E-6	DEFECT
// WHERE	WITHOUT_CLASSIFICATION	0.9999944029881951	WITHOUT_CLASSIFICATION	5.597011804899984E-6	DEFECT
// CHECK	WITHOUT_CLASSIFICATION	0.9999992197428444	WITHOUT_CLASSIFICATION	7.802571555448704E-7	DEFECT
// POLYMORPHISM	WITHOUT_CLASSIFICATION	0.9999975018559067	WITHOUT_CLASSIFICATION	2.4981440932250575E-6	DEFECT
// TODO:	WITHOUT_CLASSIFICATION	0.9954086174348217	WITHOUT_CLASSIFICATION	0.004591382565178306	DEFECT
// ID	WITHOUT_CLASSIFICATION	0.9999891469294635	WITHOUT_CLASSIFICATION	1.08530705364715E-5	DEFECT
// VERSION / TIMESTAMP	WITHOUT_CLASSIFICATION	0.9999987860835754	WITHOUT_CLASSIFICATION	1.21391642460601E-6	DEFECT
// DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9999982806023665	WITHOUT_CLASSIFICATION	1.7193976335232055E-6	DEFECT
// Primary key constraint	WITHOUT_CLASSIFICATION	0.9999999366578082	WITHOUT_CLASSIFICATION	6.334219181922965E-8	DEFECT
// this is either a <version/> tag with no type attribute, // or a <timestamp/> tag	WITHOUT_CLASSIFICATION	0.9999995404372232	WITHOUT_CLASSIFICATION	4.5956277684107913E-7	DEFECT
// for version properties marked as being generated, make sure they are "always" // generated; aka, "insert" is invalid; this is dis-allowed by the DTD, // but just to make sure...	WITHOUT_CLASSIFICATION	0.9999996033901007	WITHOUT_CLASSIFICATION	3.9660989922044404E-7	DEFECT
// DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9999982806023665	WITHOUT_CLASSIFICATION	1.7193976335232055E-6	DEFECT
// ( (Column) discrim.getColumnIterator().next() ).setType(type);	WITHOUT_CLASSIFICATION	0.9999993902479613	WITHOUT_CLASSIFICATION	6.097520388484988E-7	DEFECT
// go ahead and set the lazy here, since pojo.proxy can override it.	WITHOUT_CLASSIFICATION	0.9999994357536443	WITHOUT_CLASSIFICATION	5.642463556304653E-7	DEFECT
// DYNAMIC UPDATE	WITHOUT_CLASSIFICATION	0.9999998171096613	WITHOUT_CLASSIFICATION	1.8289033864999048E-7	DEFECT
// IMPORT	WITHOUT_CLASSIFICATION	0.9999813016222073	WITHOUT_CLASSIFICATION	1.8698377792708673E-5	DEFECT
// BATCH SIZE	WITHOUT_CLASSIFICATION	0.999991952345482	WITHOUT_CLASSIFICATION	8.047654518060125E-6	DEFECT
// SELECT BEFORE UPDATE	WITHOUT_CLASSIFICATION	0.9999991480117784	WITHOUT_CLASSIFICATION	8.519882216555196E-7	DEFECT
// OPTIMISTIC LOCK MODE	WITHOUT_CLASSIFICATION	0.9999999084587213	WITHOUT_CLASSIFICATION	9.15412787036118E-8	DEFECT
// PERSISTER	WITHOUT_CLASSIFICATION	0.9999993995385631	WITHOUT_CLASSIFICATION	6.004614368767224E-7	DEFECT
// CUSTOM SQL	WITHOUT_CLASSIFICATION	0.9999995234468901	WITHOUT_CLASSIFICATION	4.7655310979449236E-7	DEFECT
// get meta's from <subclass>	WITHOUT_CLASSIFICATION	0.9999993399730408	WITHOUT_CLASSIFICATION	6.600269592692501E-7	DEFECT
// properties	WITHOUT_CLASSIFICATION	0.9999994191362271	WITHOUT_CLASSIFICATION	5.808637727985992E-7	DEFECT
// joined subclasses	WITHOUT_CLASSIFICATION	0.9999999170284886	WITHOUT_CLASSIFICATION	8.297151140711434E-8	DEFECT
// KEY	WITHOUT_CLASSIFICATION	0.9999959093783696	WITHOUT_CLASSIFICATION	4.0906216303977796E-6	DEFECT
// CHECK	WITHOUT_CLASSIFICATION	0.9999992197428444	WITHOUT_CLASSIFICATION	7.802571555448704E-7	DEFECT
// CUSTOM SQL	WITHOUT_CLASSIFICATION	0.9999995234468901	WITHOUT_CLASSIFICATION	4.7655310979449236E-7	DEFECT
// properties	WITHOUT_CLASSIFICATION	0.9999994191362271	WITHOUT_CLASSIFICATION	5.808637727985992E-7	DEFECT
// KEY	WITHOUT_CLASSIFICATION	0.9999959093783696	WITHOUT_CLASSIFICATION	4.0906216303977796E-6	DEFECT
// model.getKey().setType( new Type( model.getIdentifier() ) );	WITHOUT_CLASSIFICATION	0.9999998527765627	WITHOUT_CLASSIFICATION	1.4722343730152524E-7	DEFECT
// TABLENAME	WITHOUT_CLASSIFICATION	0.9999919392135405	WITHOUT_CLASSIFICATION	8.060786459479508E-6	DEFECT
// join.getKey().setType( new Type( lazz.getIdentifier() ) );	WITHOUT_CLASSIFICATION	0.9999999501876271	WITHOUT_CLASSIFICATION	4.9812372895225955E-8	DEFECT
// PROPERTIES	WITHOUT_CLASSIFICATION	0.9999993176881365	WITHOUT_CLASSIFICATION	6.823118634709873E-7	DEFECT
// COLUMN(S)	WITHOUT_CLASSIFICATION	0.9999996243773598	WITHOUT_CLASSIFICATION	3.7562264022127314E-7	DEFECT
// column index	WITHOUT_CLASSIFICATION	0.9999870472959068	WITHOUT_CLASSIFICATION	1.2952704093181254E-5	DEFECT
//column unique-key	WITHOUT_CLASSIFICATION	0.9999954429847473	WITHOUT_CLASSIFICATION	4.557015252771261E-6	DEFECT
// automatically makes a column with the default name if none is specifed by XML	WITHOUT_CLASSIFICATION	0.9999996314743921	WITHOUT_CLASSIFICATION	3.685256079313647E-7	DEFECT
// for an any	WITHOUT_CLASSIFICATION	0.9999983156657888	WITHOUT_CLASSIFICATION	1.6843342111786837E-6	DEFECT
// insertable simply because that is the user did not specify // anything; just override it	WITHOUT_CLASSIFICATION	0.9999999976126991	WITHOUT_CLASSIFICATION	2.3873008429486613E-9	DEFECT
// the user specifically supplied insert="true", // which constitutes an illegal combo	WITHOUT_CLASSIFICATION	0.9999998888146171	WITHOUT_CLASSIFICATION	1.1118538282232062E-7	DEFECT
// properties generated on update can never be updateable...	WITHOUT_CLASSIFICATION	0.9999895532929508	WITHOUT_CLASSIFICATION	1.0446707049187517E-5	DEFECT
// updateable only because the user did not specify  // anything; just override it	WITHOUT_CLASSIFICATION	0.9999999992614315	WITHOUT_CLASSIFICATION	7.385684716809463E-10	DEFECT
// the user specifically supplied update="true", // which constitutes an illegal combo	WITHOUT_CLASSIFICATION	0.9999997240621399	WITHOUT_CLASSIFICATION	2.759378600975973E-7	DEFECT
// ROLENAME	WITHOUT_CLASSIFICATION	0.9999816969260302	WITHOUT_CLASSIFICATION	1.830307396977971E-5	DEFECT
// FETCH STRATEGY	WITHOUT_CLASSIFICATION	0.9999996752655449	WITHOUT_CLASSIFICATION	3.247344551399005E-7	DEFECT
// TABLE	WITHOUT_CLASSIFICATION	0.9999930994006406	WITHOUT_CLASSIFICATION	6.900599359467886E-6	DEFECT
//tableName = mappings.getNamingStrategy().propertyToTableName( className, path );	WITHOUT_CLASSIFICATION	0.9999991936402048	WITHOUT_CLASSIFICATION	8.063597950504656E-7	DEFECT
// SORT	WITHOUT_CLASSIFICATION	0.9999955564011834	WITHOUT_CLASSIFICATION	4.443598816569326E-6	DEFECT
// CUSTOM SQL	WITHOUT_CLASSIFICATION	0.9999995234468901	WITHOUT_CLASSIFICATION	4.7655310979449236E-7	DEFECT
// unsorted, natural, comparator.class.name	WITHOUT_CLASSIFICATION	0.9999999121847188	WITHOUT_CLASSIFICATION	8.781528117777167E-8	DEFECT
// ORPHAN DELETE (used for programmer error detection)	WITHOUT_CLASSIFICATION	0.9999999985367991	WITHOUT_CLASSIFICATION	1.4632008930344586E-9	DEFECT
// set up second pass	WITHOUT_CLASSIFICATION	0.9999999058311264	WITHOUT_CLASSIFICATION	9.416887356642916E-8	DEFECT
// an "embedded" component (composite ids and unique) // note that this does not handle nested components	WITHOUT_CLASSIFICATION	0.9999999965228146	WITHOUT_CLASSIFICATION	3.4771855427681554E-9	DEFECT
// a nested composite element	WITHOUT_CLASSIFICATION	0.9999999842814469	WITHOUT_CLASSIFICATION	1.571855310830093E-8	DEFECT
// for an any // we will have to use reflection	WITHOUT_CLASSIFICATION	0.9999867975871453	WITHOUT_CLASSIFICATION	1.320241285467097E-5	DEFECT
//NOTE SPECIAL CASE: // one-to-one constrained=false cannot be proxied, // so default to join and non-lazy	WITHOUT_CLASSIFICATION	0.9999999886912527	WITHOUT_CLASSIFICATION	1.1308747261733355E-8	DEFECT
// use old (HB 2.1) defaults if outer-join is specified	WITHOUT_CLASSIFICATION	0.9999999974463241	WITHOUT_CLASSIFICATION	2.553676023467865E-9	DEFECT
//lazy = !join;	WITHOUT_CLASSIFICATION	0.9999882839219124	WITHOUT_CLASSIFICATION	1.1716078087592107E-5	DEFECT
// GENERATOR	WITHOUT_CLASSIFICATION	0.999997768266045	WITHOUT_CLASSIFICATION	2.2317339549130167E-6	DEFECT
// ID UNSAVED-VALUE	WITHOUT_CLASSIFICATION	0.9999990430670358	WITHOUT_CLASSIFICATION	9.56932964175217E-7	DEFECT
// VERSION UNSAVED-VALUE	WITHOUT_CLASSIFICATION	0.9999995969602202	WITHOUT_CLASSIFICATION	4.030397797959575E-7	DEFECT
// not necessarily a *unique* property reference	WITHOUT_CLASSIFICATION	0.9999969162387355	WITHOUT_CLASSIFICATION	3.08376126442148E-6	DEFECT
// ( (Column) ( (SimpleValue) ic.getIndex() ).getColumnIterator().next() // ).setNullable(false);	WITHOUT_CLASSIFICATION	0.9999983985398765	WITHOUT_CLASSIFICATION	1.601460123503361E-6	DEFECT
// contained elements:	WITHOUT_CLASSIFICATION	0.9999999568732266	WITHOUT_CLASSIFICATION	4.312677330470234E-8	DEFECT
// for non-inverse one-to-many, with a not-null fk, add a backref!	WITHOUT_CLASSIFICATION	0.9999990366357739	WITHOUT_CLASSIFICATION	9.633642260102502E-7	DEFECT
// Bind the where	WITHOUT_CLASSIFICATION	0.9999917005883957	WITHOUT_CLASSIFICATION	8.299411604344361E-6	DEFECT
// Bind the order-by	WITHOUT_CLASSIFICATION	0.9999976683532853	WITHOUT_CLASSIFICATION	2.3316467146989026E-6	DEFECT
// Bind the filters	WITHOUT_CLASSIFICATION	0.9999991764513745	WITHOUT_CLASSIFICATION	8.235486255487564E-7	DEFECT
// overriding inherited meta attribute. HBX-621 & HBX-793	WITHOUT_CLASSIFICATION	0.9999751620384683	WITHOUT_CLASSIFICATION	2.483796153180185E-5	DEFECT
// first, iterate over all elements capable of defining an extends attribute // collecting all found extends references if they cannot be resolved // against the already processed mappings.	WITHOUT_CLASSIFICATION	0.9999999999982636	WITHOUT_CLASSIFICATION	1.736361032455831E-12	DEFECT
// mappings might contain either the "raw" extends name (in the case of // an entity-name mapping) or a FQN (in the case of a POJO mapping).	WITHOUT_CLASSIFICATION	0.9999930467419442	WITHOUT_CLASSIFICATION	6.953258055845907E-6	DEFECT
//+ "_" + referencedColumnName not used for backward compatibility	WITHOUT_CLASSIFICATION	0.9999999779164457	WITHOUT_CLASSIFICATION	2.2083554322780345E-8	DEFECT
//SessionFactory name:	WITHOUT_CLASSIFICATION	0.9999980449210423	WITHOUT_CLASSIFICATION	1.955078957796834E-6	DEFECT
//JDBC and connection settings:	WITHOUT_CLASSIFICATION	0.9999916508491703	WITHOUT_CLASSIFICATION	8.349150829729251E-6	DEFECT
//JDBC and connection settings:	WITHOUT_CLASSIFICATION	0.9999916508491703	WITHOUT_CLASSIFICATION	8.349150829729251E-6	DEFECT
//Interrogate JDBC metadata	WITHOUT_CLASSIFICATION	0.9999920119949007	WITHOUT_CLASSIFICATION	7.988005099321012E-6	DEFECT
// user supplied JDBC connections	WITHOUT_CLASSIFICATION	0.9999997844021666	WITHOUT_CLASSIFICATION	2.1559783335907931E-7	DEFECT
//use dialect default properties	WITHOUT_CLASSIFICATION	0.9999996713175026	WITHOUT_CLASSIFICATION	3.2868249747478977E-7	DEFECT
// Transaction settings:	WITHOUT_CLASSIFICATION	0.9999990431979828	WITHOUT_CLASSIFICATION	9.568020172210804E-7	DEFECT
//SQL Generation settings:	WITHOUT_CLASSIFICATION	0.9999998503562443	WITHOUT_CLASSIFICATION	1.496437558036192E-7	DEFECT
//Query parser settings:	WITHOUT_CLASSIFICATION	0.999387600884488	WITHOUT_CLASSIFICATION	6.123991155119308E-4	DEFECT
// Second-level / query cache:	WITHOUT_CLASSIFICATION	0.9999889135619681	WITHOUT_CLASSIFICATION	1.1086438032045875E-5	DEFECT
// The cache provider is needed when we either have second-level cache enabled // or query cache enabled.  Note that useSecondLevelCache is enabled by default	WITHOUT_CLASSIFICATION	0.9999999238678476	WITHOUT_CLASSIFICATION	7.613215229754502E-8	DEFECT
//SQL Exception converter:	WITHOUT_CLASSIFICATION	0.9999975662176797	WITHOUT_CLASSIFICATION	2.4337823202589402E-6	DEFECT
//Statistics and logging:	WITHOUT_CLASSIFICATION	0.9999993618925728	WITHOUT_CLASSIFICATION	6.38107427215267E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//Schema export:	WITHOUT_CLASSIFICATION	0.9999970250811379	WITHOUT_CLASSIFICATION	2.9749188621645774E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// legacy behavior, apply the bridge...	WITHOUT_CLASSIFICATION	0.9999695303999103	WITHOUT_CLASSIFICATION	3.046960008970686E-5	DEFECT
// maybe a concrete SQLpropertyresult type, but Map is exactly what is required at the moment	WITHOUT_CLASSIFICATION	0.9986810361724345	WITHOUT_CLASSIFICATION	0.0013189638275654956	DEFECT
//if dotted and not load-collection nor return-join //regular property	WITHOUT_CLASSIFICATION	0.9999906165157819	WITHOUT_CLASSIFICATION	9.383484218139914E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999986335271815	WITHOUT_CLASSIFICATION	1.366472818458156E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999970534181873	WITHOUT_CLASSIFICATION	2.9465818127059706E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// using local since the inheritedMetas at this point is not the correct map since it is always the empty map	WITHOUT_CLASSIFICATION	0.9999865697100764	WITHOUT_CLASSIFICATION	1.343028992356514E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// if doc is null, then for whatever reason, the cached file cannot be used...	WITHOUT_CLASSIFICATION	0.9999955373808008	WITHOUT_CLASSIFICATION	4.462619199157773E-6	DEFECT
// drop them in reverse order in case db needs it done that way...	WITHOUT_CLASSIFICATION	0.9998755939857671	WITHOUT_CLASSIFICATION	1.2440601423282187E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// This method may be called many times!!	WITHOUT_CLASSIFICATION	0.9999466653535334	WITHOUT_CLASSIFICATION	5.3334646466607E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// found	WITHOUT_CLASSIFICATION	0.9999945742470189	WITHOUT_CLASSIFICATION	5.425752981096801E-6	DEFECT
// found	WITHOUT_CLASSIFICATION	0.9999945742470189	WITHOUT_CLASSIFICATION	5.425752981096801E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//<String, String>	WITHOUT_CLASSIFICATION	0.999996465527452	WITHOUT_CLASSIFICATION	3.534472548040139E-6	DEFECT
//<String, String>	WITHOUT_CLASSIFICATION	0.999996465527452	WITHOUT_CLASSIFICATION	3.534472548040139E-6	DEFECT
//+ "_" + referencedColumnName not used for backward compatibility	WITHOUT_CLASSIFICATION	0.9999999779164457	WITHOUT_CLASSIFICATION	2.2083554322780345E-8	DEFECT
//Set USE_REFLECTION_OPTIMIZER to false to fix HHH-227	WITHOUT_CLASSIFICATION	0.9999885819258425	WITHOUT_CLASSIFICATION	1.141807415756949E-5	DEFECT
//orphan delete not supported for EntityMode.DOM4J	WITHOUT_CLASSIFICATION	0.999996862644626	WITHOUT_CLASSIFICATION	3.1373553739965644E-6	DEFECT
//element = XMLHelper.generateDom4jElement( persister.getNodeName() );	WITHOUT_CLASSIFICATION	0.9999992020338019	WITHOUT_CLASSIFICATION	7.979661980592688E-7	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
//orphan delete not supported for EntityMode.DOM4J	WITHOUT_CLASSIFICATION	0.999996862644626	WITHOUT_CLASSIFICATION	3.1373553739965644E-6	DEFECT
//element = XMLHelper.generateDom4jElement( persister.getNodeName() );	WITHOUT_CLASSIFICATION	0.9999992020338019	WITHOUT_CLASSIFICATION	7.979661980592688E-7	DEFECT
//needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999988034450469	WITHOUT_CLASSIFICATION	1.1965549530198677E-6	DEFECT
//maintain correct duplication if loaded in a cartesian product	WITHOUT_CLASSIFICATION	0.9999998474857764	WITHOUT_CLASSIFICATION	1.5251422356635722E-7	DEFECT
// the element has been removed from the set	WITHOUT_CLASSIFICATION	0.9999911019611248	WITHOUT_CLASSIFICATION	8.89803887515582E-6	DEFECT
// the element has changed	WITHOUT_CLASSIFICATION	0.9999999078012651	WITHOUT_CLASSIFICATION	9.219873494413006E-8	DEFECT
//Careful: these methods do not initialize the collection.	WITHOUT_CLASSIFICATION	0.9997263172503326	WITHOUT_CLASSIFICATION	2.7368274966741894E-4	DEFECT
//needed so that we remove this collection from the second-level cache	WITHOUT_CLASSIFICATION	0.9999929254877732	WITHOUT_CLASSIFICATION	7.074512226906317E-6	DEFECT
// override on some subclasses	WITHOUT_CLASSIFICATION	0.9999996686061715	WITHOUT_CLASSIFICATION	3.313938284384907E-7	DEFECT
//override on some subclasses	WITHOUT_CLASSIFICATION	0.9999992504711577	WITHOUT_CLASSIFICATION	7.495288422783868E-7	DEFECT
//do this bit after setting initialized to true or it will recurse	WITHOUT_CLASSIFICATION	0.9999856756383098	WITHOUT_CLASSIFICATION	1.4324361690277623E-5	DEFECT
// short-circuit(s) // no new elements, the old list contains only Orphans // no old elements, so no Orphans neither	WITHOUT_CLASSIFICATION	0.9999999997889361	WITHOUT_CLASSIFICATION	2.1106396474499583E-10	DEFECT
// create the collection holding the Orphans	WITHOUT_CLASSIFICATION	0.999998618962276	WITHOUT_CLASSIFICATION	1.3810377238945802E-6	DEFECT
// collect EntityIdentifier(s) of the *current* elements - add them into a HashSet for fast access	WITHOUT_CLASSIFICATION	0.9999998827711388	WITHOUT_CLASSIFICATION	1.1722886116102141E-7	DEFECT
// iterate over the *old* list	WITHOUT_CLASSIFICATION	0.9999999972652406	WITHOUT_CLASSIFICATION	2.734759447438773E-9	DEFECT
/*(array==null) ? tempList.size() :*/	WITHOUT_CLASSIFICATION	0.999989438523716	WITHOUT_CLASSIFICATION	1.0561476283929818E-5	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
/*(array==null) ? tempList.get(i) :*/	WITHOUT_CLASSIFICATION	0.9999738012916228	WITHOUT_CLASSIFICATION	2.6198708377198986E-5	DEFECT
//write(); -- doesn't	WITHOUT_CLASSIFICATION	0.9999922773238528	WITHOUT_CLASSIFICATION	7.722676147259106E-6	DEFECT
//write(); -- doesn't	WITHOUT_CLASSIFICATION	0.9999922773238528	WITHOUT_CLASSIFICATION	7.722676147259106E-6	DEFECT
// amazingly, these two will work because AbstractCollection // uses iterator() to fill the array	WITHOUT_CLASSIFICATION	0.99999164096109	WITHOUT_CLASSIFICATION	8.359038910082486E-6	DEFECT
//needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999988034450469	WITHOUT_CLASSIFICATION	1.1965549530198677E-6	DEFECT
// finally, what it's all about...	WITHOUT_CLASSIFICATION	0.9997879079151114	WITHOUT_CLASSIFICATION	2.120920848886824E-4	DEFECT
// note that if we load this collection from a cartesian product // the multiplicity would be broken ... so use an idbag instead	WITHOUT_CLASSIFICATION	0.9988481563150472	WITHOUT_CLASSIFICATION	0.0011518436849528844	DEFECT
// Anyway, here we implement <set> semantics for a // <one-to-many> <bag>!	WITHOUT_CLASSIFICATION	0.9999282094852856	WITHOUT_CLASSIFICATION	7.179051471443756E-5	DEFECT
//a shortcut if its location didn't change!	WITHOUT_CLASSIFICATION	0.999999204111093	WITHOUT_CLASSIFICATION	7.958889070370922E-7	DEFECT
//search for it //note that this code is incorrect for other than one-to-many	WITHOUT_CLASSIFICATION	0.9998541632456557	WITHOUT_CLASSIFICATION	1.4583675434433677E-4	DEFECT
//needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999988034450469	WITHOUT_CLASSIFICATION	1.1965549530198677E-6	DEFECT
//a shortcut if its location didn't change!	WITHOUT_CLASSIFICATION	0.999999204111093	WITHOUT_CLASSIFICATION	7.958889070370922E-7	DEFECT
//search for it //note that this code is incorrect for other than one-to-many	WITHOUT_CLASSIFICATION	0.9998541632456557	WITHOUT_CLASSIFICATION	1.4583675434433677E-4	DEFECT
/*public boolean equals(Object other) {	WITHOUT_CLASSIFICATION	0.9999986851869477	WITHOUT_CLASSIFICATION	1.3148130522894386E-6	DEFECT
// List OPERATIONS:	WITHOUT_CLASSIFICATION	0.9999998811802034	WITHOUT_CLASSIFICATION	1.1881979655741709E-7	DEFECT
//pad with nulls from the current last element up to the new index	WITHOUT_CLASSIFICATION	0.9999048443153358	WITHOUT_CLASSIFICATION	9.515568466420019E-5	DEFECT
//needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999988034450469	WITHOUT_CLASSIFICATION	1.1965549530198677E-6	DEFECT
//needed for SOAP libraries, etc	WITHOUT_CLASSIFICATION	0.9999988034450469	WITHOUT_CLASSIFICATION	1.1965549530198677E-6	DEFECT
// from Map	WITHOUT_CLASSIFICATION	0.9999990899162173	WITHOUT_CLASSIFICATION	9.100837826594249E-7	DEFECT
// from SortedMap	WITHOUT_CLASSIFICATION	0.9999994231278029	WITHOUT_CLASSIFICATION	5.768721971263406E-7	DEFECT
//inject the data	WITHOUT_CLASSIFICATION	0.9999985322014099	WITHOUT_CLASSIFICATION	1.467798590184746E-6	DEFECT
// cannot be instantiated	WITHOUT_CLASSIFICATION	0.9999989771995972	WITHOUT_CLASSIFICATION	1.0228004028444569E-6	DEFECT
//default pool size 20	WITHOUT_CLASSIFICATION	0.9999977062099584	WITHOUT_CLASSIFICATION	2.2937900415471233E-6	DEFECT
// trying via forName() first to be as close to DriverManager's semantics	WITHOUT_CLASSIFICATION	0.9999999694395842	WITHOUT_CLASSIFICATION	3.056041582782314E-8	DEFECT
// if debug level is enabled, then log the password, otherwise mask it	WITHOUT_CLASSIFICATION	0.9999999377669819	WITHOUT_CLASSIFICATION	6.223301813212569E-8	DEFECT
// register a cleanup synch	WITHOUT_CLASSIFICATION	0.9999999870391608	WITHOUT_CLASSIFICATION	1.2960839291969044E-8	DEFECT
// wrap the session in the transaction-protection proxy	WITHOUT_CLASSIFICATION	0.9999992212228223	WITHOUT_CLASSIFICATION	7.787771777210474E-7	DEFECT
// then bind it	WITHOUT_CLASSIFICATION	0.9999964111631391	WITHOUT_CLASSIFICATION	3.588836861025071E-6	DEFECT
// try to make sure we don't wrap and already wrapped session	WITHOUT_CLASSIFICATION	0.9999506591205962	WITHOUT_CLASSIFICATION	4.934087940365735E-5	DEFECT
// allow these to go through the the real session no matter what	WITHOUT_CLASSIFICATION	0.9999986636622964	WITHOUT_CLASSIFICATION	1.3363377036369655E-6	DEFECT
// limit the methods available if no transaction is active	WITHOUT_CLASSIFICATION	0.999999751950171	WITHOUT_CLASSIFICATION	2.480498290847454E-7	DEFECT
// allow these (deprecated) methods to pass through	WITHOUT_CLASSIFICATION	0.9999994148732049	WITHOUT_CLASSIFICATION	5.851267951564381E-7	DEFECT
// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999980308291153	WITHOUT_CLASSIFICATION	1.969170884694351E-6	DEFECT
// We could register the session against the transaction even though it is // not started, but we'd have no guarentee of ever getting the map // entries cleaned up (aside from spawning threads).	WITHOUT_CLASSIFICATION	0.9999960096536992	WITHOUT_CLASSIFICATION	3.990346300920696E-6	DEFECT
//cannot be instantiated	WITHOUT_CLASSIFICATION	0.9999988920392295	WITHOUT_CLASSIFICATION	1.1079607705184335E-6	DEFECT
//private String propertyName;	WITHOUT_CLASSIFICATION	0.9999706778163143	WITHOUT_CLASSIFICATION	2.932218368564236E-5	DEFECT
/*public PropertyProjection project() {	WITHOUT_CLASSIFICATION	0.999404653839	WITHOUT_CLASSIFICATION	5.953461609999484E-4	DEFECT
//String[] fk = StringHelper.qualify( "collection_", cp.getKeyColumnNames() );	WITHOUT_CLASSIFICATION	0.9999999823579078	WITHOUT_CLASSIFICATION	1.7642092222121228E-8	DEFECT
//" collection_ where " +	WITHOUT_CLASSIFICATION	0.9999991376207246	WITHOUT_CLASSIFICATION	8.623792754041134E-7	DEFECT
//unsupported	WITHOUT_CLASSIFICATION	0.9999858535089412	WITHOUT_CLASSIFICATION	1.4146491058785025E-5	DEFECT
//unsupported	WITHOUT_CLASSIFICATION	0.9999858535089412	WITHOUT_CLASSIFICATION	1.4146491058785025E-5	DEFECT
//cannot be instantiated	WITHOUT_CLASSIFICATION	0.9999988920392295	WITHOUT_CLASSIFICATION	1.1079607705184335E-6	DEFECT
//the following two lines were added to ensure that this.params is not null, which //can happen with two-deep nested subqueries	WITHOUT_CLASSIFICATION	0.999842799513212	WITHOUT_CLASSIFICATION	1.572004867880155E-4	DEFECT
//with two-deep subqueries, the same alias would get generated for //both using the old method (criteriaQuery.generateSQLAlias()), so //that is now used as a fallback if the main criteria alias isn't set	WITHOUT_CLASSIFICATION	0.9999791036197619	WITHOUT_CLASSIFICATION	2.0896380238130005E-5	DEFECT
//implicit polymorphism not supported (would need a union)	WITHOUT_CLASSIFICATION	0.9999779429150846	WITHOUT_CLASSIFICATION	2.205708491537893E-5	DEFECT
//pull off the last ", "	WITHOUT_CLASSIFICATION	0.999999412355913	WITHOUT_CLASSIFICATION	5.876440869204088E-7	DEFECT
//$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999904037695596	WITHOUT_CLASSIFICATION	9.59623044033645E-6	DEFECT
// we have the form: trim(trimSource) //      so we trim leading and trailing spaces	WITHOUT_CLASSIFICATION	0.9999996087617745	WITHOUT_CLASSIFICATION	3.912382254088708E-7	DEFECT
// we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource)	WITHOUT_CLASSIFICATION	0.99984093856961	WITHOUT_CLASSIFICATION	1.590614303900853E-4	DEFECT
// NOT_SUPPORTED_SHOULD_USE_JDBC3_PreparedStatement.getGeneratedKeys_method	WITHOUT_CLASSIFICATION	0.9999999787871507	WITHOUT_CLASSIFICATION	2.1212849271196115E-8	DEFECT
// potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitly	WITHOUT_CLASSIFICATION	0.9999999999769179	WITHOUT_CLASSIFICATION	2.3082072487717357E-11	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// Oracle did add support for ANSI CASE statements in 9i	WITHOUT_CLASSIFICATION	0.99999995031299	WITHOUT_CLASSIFICATION	4.9687009861719625E-8	DEFECT
// the standard SQL function name is current_timestamp...	WITHOUT_CLASSIFICATION	0.9997720547702388	WITHOUT_CLASSIFICATION	2.2794522976114716E-4	DEFECT
// Informix doesn't have a bit type	WITHOUT_CLASSIFICATION	0.9990519086802628	WITHOUT_CLASSIFICATION	9.480913197372561E-4	DEFECT
// or BYTE // or TEXT? // or MONEY	WITHOUT_CLASSIFICATION	0.9999707747956398	WITHOUT_CLASSIFICATION	2.9225204360128086E-5	DEFECT
// strip table-owner because Informix always returns constraint names as "<table-owner>.<constraint-name>"	WITHOUT_CLASSIFICATION	0.9999999991323709	WITHOUT_CLASSIFICATION	8.676291814554596E-10	DEFECT
// build the map of standard ANSI SQL aggregation functions ~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993391916209	WITHOUT_CLASSIFICATION	6.608083790529761E-7	DEFECT
//pre H3.2 behavior: super.getReturnType(ct, m);	WITHOUT_CLASSIFICATION	0.9999306240896537	WITHOUT_CLASSIFICATION	6.937591034617113E-5	DEFECT
// finally use the sqltype if == on Hibernate types did not find a match.	WITHOUT_CLASSIFICATION	0.9999992590904639	WITHOUT_CLASSIFICATION	7.409095360148451E-7	DEFECT
//because numeric can be anything	WITHOUT_CLASSIFICATION	0.9999960567675686	WITHOUT_CLASSIFICATION	3.943232431353363E-6	DEFECT
// constructors and factory methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999991727739601	WITHOUT_CLASSIFICATION	8.272260399765588E-7	DEFECT
// standard sql92 functions (can be overridden by subclasses)	WITHOUT_CLASSIFICATION	0.9999960754892634	WITHOUT_CLASSIFICATION	3.924510736617886E-6	DEFECT
//map second/minute/hour/day/month/year to ANSI extract(), override on subclasses	WITHOUT_CLASSIFICATION	0.9999998834792199	WITHOUT_CLASSIFICATION	1.1652078014277268E-7	DEFECT
// register hibernate types for default use in scalar sqlquery type auto detection	WITHOUT_CLASSIFICATION	0.9999994986940673	WITHOUT_CLASSIFICATION	5.013059326094754E-7	DEFECT
// database type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999294891688897	WITHOUT_CLASSIFICATION	7.051083111026142E-5	DEFECT
// hibernate type mapping support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999957533092365	WITHOUT_CLASSIFICATION	4.246690763412849E-6	DEFECT
// keyword support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999975530327931	WITHOUT_CLASSIFICATION	2.4469672069150746E-6	DEFECT
// native identifier generatiion ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999968764333527	WITHOUT_CLASSIFICATION	3.123566647280642E-6	DEFECT
// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999984142055821	WITHOUT_CLASSIFICATION	1.585794417843566E-6	DEFECT
// SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999991099223802	WITHOUT_CLASSIFICATION	8.900776199143064E-7	DEFECT
// GUID support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999989063570937	WITHOUT_CLASSIFICATION	1.093642906405655E-6	DEFECT
// limit/offset support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999987072480327	WITHOUT_CLASSIFICATION	1.2927519671839403E-6	DEFECT
// by default we report no support	WITHOUT_CLASSIFICATION	0.9999998169840248	WITHOUT_CLASSIFICATION	1.8301597514924074E-7	DEFECT
// by default we report no support for NOWAIT lock semantics	WITHOUT_CLASSIFICATION	0.9999998658009112	WITHOUT_CLASSIFICATION	1.3419908880802957E-7	DEFECT
// table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993906852862	WITHOUT_CLASSIFICATION	6.093147137357408E-7	DEFECT
// temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998478704665	WITHOUT_CLASSIFICATION	1.521295336348063E-7	DEFECT
// callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993715562583	WITHOUT_CLASSIFICATION	6.28443741656761E-7	DEFECT
// current timestamp support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999984012747012	WITHOUT_CLASSIFICATION	1.5987252987712747E-6	DEFECT
// SQLException support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999973038466936	WITHOUT_CLASSIFICATION	2.6961533063272075E-6	DEFECT
// miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998045228287	WITHOUT_CLASSIFICATION	1.9547717124141996E-7	DEFECT
// identifier quoting support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997847414344	WITHOUT_CLASSIFICATION	2.1525856571731612E-7	DEFECT
// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999974026476375	WITHOUT_CLASSIFICATION	2.597352362441292E-6	DEFECT
// grrr... for differentiation of mysql storage engines	WITHOUT_CLASSIFICATION	0.9999840187696819	WITHOUT_CLASSIFICATION	1.598123031815394E-5	DEFECT
// Informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999993101898805	WITHOUT_CLASSIFICATION	6.89810119495176E-6	DEFECT
// return false here, as most databases do not properly support this construct...	WITHOUT_CLASSIFICATION	0.924818767420552	WITHOUT_CLASSIFICATION	0.07518123257944796	DEFECT
// Mckoi has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999920930612703	WITHOUT_CLASSIFICATION	7.90693872971149E-6	DEFECT
// Oracle8 and previous define only a "DATE" type which //      is used to represent all aspects of date/time	WITHOUT_CLASSIFICATION	0.9999999999919604	WITHOUT_CLASSIFICATION	8.039593245026719E-12	DEFECT
//starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999999005667757	WITHOUT_CLASSIFICATION	9.943322428657399E-8	DEFECT
//" cascade";	WITHOUT_CLASSIFICATION	0.9999993985677895	WITHOUT_CLASSIFICATION	6.014322104808678E-7	DEFECT
//trim off the length/precision/scale	WITHOUT_CLASSIFICATION	0.9999992652524049	WITHOUT_CLASSIFICATION	7.347475952303258E-7	DEFECT
/*public boolean dropTemporaryTableAfterUse() {	WITHOUT_CLASSIFICATION	0.99999781181151	WITHOUT_CLASSIFICATION	2.188188489903518E-6	DEFECT
// CHECK VIOLATION	WITHOUT_CLASSIFICATION	0.9999998241631097	WITHOUT_CLASSIFICATION	1.7583689022559924E-7	DEFECT
// UNIQUE VIOLATION	WITHOUT_CLASSIFICATION	0.9999982914287265	WITHOUT_CLASSIFICATION	1.7085712734632333E-6	DEFECT
// FOREIGN KEY VIOLATION	WITHOUT_CLASSIFICATION	0.9999988851673142	WITHOUT_CLASSIFICATION	1.1148326858315644E-6	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// NOT NULL VIOLATION	WITHOUT_CLASSIFICATION	0.999999686294033	WITHOUT_CLASSIFICATION	3.1370596698561405E-7	DEFECT
// ALL OTHER	WITHOUT_CLASSIFICATION	0.9999985228109542	WITHOUT_CLASSIFICATION	1.4771890457544275E-6	DEFECT
// Register the type of the out param - PostgreSQL uses Types.OTHER	WITHOUT_CLASSIFICATION	0.9999994077544059	WITHOUT_CLASSIFICATION	5.922455942392031E-7	DEFECT
// seems to not really... //	WITHOUT_CLASSIFICATION	0.9960500110490571	WITHOUT_CLASSIFICATION	0.00394998895094283	DEFECT
// seems to have spotty LOB suppport	WITHOUT_CLASSIFICATION	0.9999734359592539	WITHOUT_CLASSIFICATION	2.6564040746143244E-5	DEFECT
// HHH-2300	WITHOUT_CLASSIFICATION	0.9999957747596296	WITHOUT_CLASSIFICATION	4.225240370407935E-6	DEFECT
// ignore (probably H2 not in the classpath)	WITHOUT_CLASSIFICATION	0.9999680382534087	WITHOUT_CLASSIFICATION	3.1961746591285865E-5	DEFECT
// Numeric Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999998986468473	WITHOUT_CLASSIFICATION	1.0135315270737916E-6	DEFECT
// String Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999911708499049	WITHOUT_CLASSIFICATION	8.829150095125273E-6	DEFECT
// Time and Date Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999989562509884	WITHOUT_CLASSIFICATION	1.043749011513225E-6	DEFECT
// System Functions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999944838979402	WITHOUT_CLASSIFICATION	5.5161020597004255E-6	DEFECT
// not null is implicit	WITHOUT_CLASSIFICATION	0.999983337252001	WITHOUT_CLASSIFICATION	1.6662747999073566E-5	DEFECT
// 23000: Check constraint violation: {0} // 23001: Unique index or primary key violation: {0}	WITHOUT_CLASSIFICATION	0.9999998941887674	WITHOUT_CLASSIFICATION	1.058112326054676E-7	DEFECT
// Display the dialect version.	WITHOUT_CLASSIFICATION	0.9999977964715285	WITHOUT_CLASSIFICATION	2.2035284714409385E-6	DEFECT
// The RDMS concat() function only supports 2 parameters	WITHOUT_CLASSIFICATION	0.9999849636733797	WITHOUT_CLASSIFICATION	1.5036326620231973E-5	DEFECT
// Dialect method overrides ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999373799305	WITHOUT_CLASSIFICATION	6.262006944563528E-8	DEFECT
// Original Dialect.java returns " for update";	WITHOUT_CLASSIFICATION	0.9999997049462442	WITHOUT_CLASSIFICATION	2.950537557383158E-7	DEFECT
// Verify the state of this new method in Hibernate 3.0 Dialect.java	WITHOUT_CLASSIFICATION	0.9999949249318469	WITHOUT_CLASSIFICATION	5.07506815301686E-6	DEFECT
// Origial Dialect.java returns true;	WITHOUT_CLASSIFICATION	0.9999991046976653	WITHOUT_CLASSIFICATION	8.953023346788916E-7	DEFECT
// The keyword used to specify a nullable column.	WITHOUT_CLASSIFICATION	0.99999999472648	WITHOUT_CLASSIFICATION	5.273519973049795E-9	DEFECT
// *** Sequence methods - start. The RDMS dialect needs these	WITHOUT_CLASSIFICATION	0.9999863101564996	WITHOUT_CLASSIFICATION	1.3689843500386111E-5	DEFECT
// methods to make it possible to use the Native Id generator	WITHOUT_CLASSIFICATION	0.9999992139474218	WITHOUT_CLASSIFICATION	7.860525782632293E-7	DEFECT
// The where clause was added to eliminate this statement from Brute Force Searches.	WITHOUT_CLASSIFICATION	0.9999993849605123	WITHOUT_CLASSIFICATION	6.150394876764905E-7	DEFECT
// *** Sequence methods - end	WITHOUT_CLASSIFICATION	0.9999880213581767	WITHOUT_CLASSIFICATION	1.1978641823240228E-5	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
//starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999999005667757	WITHOUT_CLASSIFICATION	9.943322428657399E-8	DEFECT
// We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400	WITHOUT_CLASSIFICATION	0.9999780404440924	WITHOUT_CLASSIFICATION	2.1959555907510974E-5	DEFECT
// Used with DROP TABLE to delete all records in the table.	WITHOUT_CLASSIFICATION	0.9999999718056214	WITHOUT_CLASSIFICATION	2.8194378633633345E-8	DEFECT
// RDMS supports the UNION ALL clause.	WITHOUT_CLASSIFICATION	0.9999984210917948	WITHOUT_CLASSIFICATION	1.578908205127271E-6	DEFECT
// RDMS has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999169622545897	WITHOUT_CLASSIFICATION	8.303774541039005E-5	DEFECT
// Multi-param dialect functions...	WITHOUT_CLASSIFICATION	0.999988586732986	WITHOUT_CLASSIFICATION	1.1413267013972555E-5	DEFECT
// function templates	WITHOUT_CLASSIFICATION	0.999999881387176	WITHOUT_CLASSIFICATION	1.1861282398570582E-7	DEFECT
//not null is implicit	WITHOUT_CLASSIFICATION	0.9999371695142025	WITHOUT_CLASSIFICATION	6.283048579743474E-5	DEFECT
// this assumes schema support, which is present in 1.8.0 and later...	WITHOUT_CLASSIFICATION	0.9993671335708056	WITHOUT_CLASSIFICATION	6.328664291942888E-4	DEFECT
// HSQLDB only supports READ_UNCOMMITTED transaction isolation	WITHOUT_CLASSIFICATION	0.9999985749191573	WITHOUT_CLASSIFICATION	1.4250808426616004E-6	DEFECT
// Multi-param string dialect functions...	WITHOUT_CLASSIFICATION	0.9999859430824559	WITHOUT_CLASSIFICATION	1.4056917544194102E-5	DEFECT
// Multi-param numeric dialect functions...	WITHOUT_CLASSIFICATION	0.9999833041057152	WITHOUT_CLASSIFICATION	1.6695894284756333E-5	DEFECT
// Multi-param date dialect functions...	WITHOUT_CLASSIFICATION	0.9999904476592181	WITHOUT_CLASSIFICATION	9.552340781828034E-6	DEFECT
// simple nullability constraint	WITHOUT_CLASSIFICATION	0.9999999353491166	WITHOUT_CLASSIFICATION	6.46508833997868E-8	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// not final-static to avoid possible classcast exceptions if using different oracle drivers.	WITHOUT_CLASSIFICATION	0.9999996619745695	WITHOUT_CLASSIFICATION	3.380254304927664E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// TimesTen has no BLOB/CLOB support, but these types may be suitable  // for some applications. The length is limited to 4 million bytes.	WITHOUT_CLASSIFICATION	0.999994068506087	WITHOUT_CLASSIFICATION	5.931493913044604E-6	DEFECT
// new methods in dialect3	WITHOUT_CLASSIFICATION	0.9999972592134302	WITHOUT_CLASSIFICATION	2.740786569815128E-6	DEFECT
/*public boolean supportsForUpdateNowait() {	WITHOUT_CLASSIFICATION	0.9999924934204553	WITHOUT_CLASSIFICATION	7.506579544810464E-6	DEFECT
// TimesTen has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999676814006857	WITHOUT_CLASSIFICATION	3.231859931435967E-5	DEFECT
// iterate entries ordered by capacity to find first fit	WITHOUT_CLASSIFICATION	0.9999999896759331	WITHOUT_CLASSIFICATION	1.0324066966722518E-8	DEFECT
// add new ordered map	WITHOUT_CLASSIFICATION	0.9999998016190799	WITHOUT_CLASSIFICATION	1.9838092014669235E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// sql server just returns automatically	WITHOUT_CLASSIFICATION	0.9999999950831747	WITHOUT_CLASSIFICATION	4.916825356281141E-9	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//registerColumnType data types	WITHOUT_CLASSIFICATION	0.9999996225857835	WITHOUT_CLASSIFICATION	3.774142165986366E-7	DEFECT
// hibernate seems to ignore this type...	WITHOUT_CLASSIFICATION	0.9999731102063175	WITHOUT_CLASSIFICATION	2.6889793682476064E-5	DEFECT
// IBID for current_time and current_date	WITHOUT_CLASSIFICATION	0.9999950561173876	WITHOUT_CLASSIFICATION	4.943882612405639E-6	DEFECT
// Tell hibernate to use getBytes instead of getBinaryStream	WITHOUT_CLASSIFICATION	0.9999917413937233	WITHOUT_CLASSIFICATION	8.258606276714143E-6	DEFECT
// No batch statements	WITHOUT_CLASSIFICATION	0.9999999934101247	WITHOUT_CLASSIFICATION	6.5898753923851835E-9	DEFECT
/*	WITHOUT_CLASSIFICATION	0.9935009427489204	WITHOUT_CLASSIFICATION	0.006499057251079584	DEFECT
//no pointbase BIT	WITHOUT_CLASSIFICATION	0.999998520394473	WITHOUT_CLASSIFICATION	1.4796055269329483E-6	DEFECT
//no pointbase TINYINT	WITHOUT_CLASSIFICATION	0.999999891951187	WITHOUT_CLASSIFICATION	1.0804881300327599E-7	DEFECT
// Pointbase has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999929020422282	WITHOUT_CLASSIFICATION	7.097957771801657E-6	DEFECT
//starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999999005667757	WITHOUT_CLASSIFICATION	9.943322428657399E-8	DEFECT
// The current_timestamp is more accurate, but only known to be supported // in SQL Server 7.0 and later (i.e., Sybase not known to support it at all)	WITHOUT_CLASSIFICATION	0.9968625154061778	WITHOUT_CLASSIFICATION	0.003137484593822295	DEFECT
// SQL Server (at least up through 2005) does not support defining // cascade delete constraints which can circel back to the mutating // table	WITHOUT_CLASSIFICATION	0.9999999273106045	WITHOUT_CLASSIFICATION	7.268939556569946E-8	DEFECT
// here assume SQLServer2005 using snapshot isolation, which does not have this problem	WITHOUT_CLASSIFICATION	0.9996213456791114	WITHOUT_CLASSIFICATION	3.7865432088867487E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999999005667757	WITHOUT_CLASSIFICATION	9.943322428657399E-8	DEFECT
/* package-private */	WITHOUT_CLASSIFICATION	0.9999995651599553	WITHOUT_CLASSIFICATION	4.3484004480809293E-7	DEFECT
// sql server just returns automatically	WITHOUT_CLASSIFICATION	0.9999999950831747	WITHOUT_CLASSIFICATION	4.916825356281141E-9	DEFECT
//Sybase BIT type does not support null values	WITHOUT_CLASSIFICATION	0.9988682675596652	WITHOUT_CLASSIFICATION	0.0011317324403347523	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//not null ... (start with 1) is implicit	WITHOUT_CLASSIFICATION	0.9998728681606364	WITHOUT_CLASSIFICATION	1.2713183936362204E-4	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// Oracle driver reports to support getGeneratedKeys(), but they only // support the version taking an array of the names of the columns to // be returned (via its RETURNING clause).  No other driver seems to // support this overloaded version.	WITHOUT_CLASSIFICATION	0.9999999694904468	WITHOUT_CLASSIFICATION	3.050955324738457E-8	DEFECT
// Multi-param string dialect functions...	WITHOUT_CLASSIFICATION	0.9999859430824559	WITHOUT_CLASSIFICATION	1.4056917544194102E-5	DEFECT
// Multi-param numeric dialect functions...	WITHOUT_CLASSIFICATION	0.9999833041057152	WITHOUT_CLASSIFICATION	1.6695894284756333E-5	DEFECT
// Multi-param date dialect functions...	WITHOUT_CLASSIFICATION	0.9999904476592181	WITHOUT_CLASSIFICATION	9.552340781828034E-6	DEFECT
// add another (inner) nested select // add the main query // close off the inner nested select	WITHOUT_CLASSIFICATION	0.999999984969123	WITHOUT_CLASSIFICATION	1.5030876987259193E-8	DEFECT
// add the main query	WITHOUT_CLASSIFICATION	0.9999993172635845	WITHOUT_CLASSIFICATION	6.827364155181904E-7	DEFECT
//add the restriction to the outer select	WITHOUT_CLASSIFICATION	0.9999998050857368	WITHOUT_CLASSIFICATION	1.9491426316891454E-7	DEFECT
// This assumes you will want to ignore any update counts 	WITHOUT_CLASSIFICATION	0.9999970382058284	WITHOUT_CLASSIFICATION	2.9617941716389744E-6	DEFECT
// You may still have other ResultSets or update counts left to process here  // but you can't do it now or the ResultSet you just got will be closed 	WITHOUT_CLASSIFICATION	0.9999999433372896	WITHOUT_CLASSIFICATION	5.666271031681839E-8	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
//starts with 1, implicitly	WITHOUT_CLASSIFICATION	0.9999999005667757	WITHOUT_CLASSIFICATION	9.943322428657399E-8	DEFECT
// simple nullability constraint	WITHOUT_CLASSIFICATION	0.9999999353491166	WITHOUT_CLASSIFICATION	6.46508833997868E-8	DEFECT
// not final-static to avoid possible classcast exceptions if using different oracle drivers.	WITHOUT_CLASSIFICATION	0.9999996619745695	WITHOUT_CLASSIFICATION	3.380254304927664E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// features which change between 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999204522939	WITHOUT_CLASSIFICATION	7.954770602379892E-8	DEFECT
// features which remain constant across 8i, 9i, and 10g ~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999905252228437	WITHOUT_CLASSIFICATION	9.474777156258209E-6	DEFECT
// binary %Stream // character %Stream	WITHOUT_CLASSIFICATION	0.9999999128567975	WITHOUT_CLASSIFICATION	8.714320245829065E-8	DEFECT
//getDefaultProperties().setProperty(Environment.STATEMENT_BATCH_SIZE, NO_BATCH);	WITHOUT_CLASSIFICATION	0.9999999818032761	WITHOUT_CLASSIFICATION	1.819672396666226E-8	DEFECT
// hibernate impelemnts cast in Dialect.java	WITHOUT_CLASSIFICATION	0.9999996960337539	WITHOUT_CLASSIFICATION	3.039662459858857E-7	DEFECT
// aggregate functions shouldn't be registered, right? //registerFunction( "list", new StandardSQLFunction("list",Hibernate.STRING) ); // stopped on $list	WITHOUT_CLASSIFICATION	0.9999996275612646	WITHOUT_CLASSIFICATION	3.724387354244028E-7	DEFECT
// DDL support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999974026476375	WITHOUT_CLASSIFICATION	2.597352362441292E-6	DEFECT
// below is for Cache' that don't have str in 2007.1 there is str and we register str directly	WITHOUT_CLASSIFICATION	0.9999890911786247	WITHOUT_CLASSIFICATION	1.0908821375200151E-5	DEFECT
// note that %string is deprecated	WITHOUT_CLASSIFICATION	0.9999998887620146	WITHOUT_CLASSIFICATION	1.1123798525675805E-7	DEFECT
// %upper is deprecated	WITHOUT_CLASSIFICATION	0.999999919409369	WITHOUT_CLASSIFICATION	8.05906309708396E-8	DEFECT
// The syntax used to add a foreign key constraint to a table.	WITHOUT_CLASSIFICATION	0.9999999080229985	WITHOUT_CLASSIFICATION	9.1977001435748E-8	DEFECT
// identifier-commalist	WITHOUT_CLASSIFICATION	0.999999997343345	WITHOUT_CLASSIFICATION	2.656654999989754E-9	DEFECT
// IDENTITY support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999984142055821	WITHOUT_CLASSIFICATION	1.585794417843566E-6	DEFECT
// SEQUENCE support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999991099223802	WITHOUT_CLASSIFICATION	8.900776199143064E-7	DEFECT
// temporary table support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998478704665	WITHOUT_CLASSIFICATION	1.521295336348063E-7	DEFECT
// identifier-commalist	WITHOUT_CLASSIFICATION	0.999999997343345	WITHOUT_CLASSIFICATION	2.656654999989754E-9	DEFECT
// The syntax used to add a column to a table	WITHOUT_CLASSIFICATION	0.9999999420791457	WITHOUT_CLASSIFICATION	5.792085447673312E-8	DEFECT
// Completely optional cascading drop clause.	WITHOUT_CLASSIFICATION	0.999999129030034	WITHOUT_CLASSIFICATION	8.709699660961591E-7	DEFECT
// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999842011315511	WITHOUT_CLASSIFICATION	1.579886844897213E-5	DEFECT
// LIMIT support (ala TOP) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999928008552488	WITHOUT_CLASSIFICATION	7.199144751266666E-6	DEFECT
// InterSystems Cache' does not current support "SELECT ... FOR UPDATE" syntax... // Set your transaction mode to READ_COMMITTED before using	WITHOUT_CLASSIFICATION	0.9999437687643704	WITHOUT_CLASSIFICATION	5.623123562953909E-5	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
/*<String>*/	WITHOUT_CLASSIFICATION	0.999939390656986	WITHOUT_CLASSIFICATION	6.06093430141136E-5	DEFECT
// callable statement support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993715562583	WITHOUT_CLASSIFICATION	6.28443741656761E-7	DEFECT
// miscellaneous support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998045228287	WITHOUT_CLASSIFICATION	1.9547717124141996E-7	DEFECT
// The keyword used to specify a nullable column.	WITHOUT_CLASSIFICATION	0.99999999472648	WITHOUT_CLASSIFICATION	5.273519973049795E-9	DEFECT
// Does the LIMIT clause come at the start of the SELECT statement, rather than at the end?	WITHOUT_CLASSIFICATION	0.9999997126287554	WITHOUT_CLASSIFICATION	2.8737124466566956E-7	DEFECT
// Does the LIMIT clause take a "maximum" row number instead of a total number of returned rows?	WITHOUT_CLASSIFICATION	0.99999891857501	WITHOUT_CLASSIFICATION	1.0814249899493942E-6	DEFECT
// The name of the SQL function that transforms a string to lowercase	WITHOUT_CLASSIFICATION	0.9999998489138937	WITHOUT_CLASSIFICATION	1.510861062822855E-7	DEFECT
// Create an OuterJoinGenerator for this dialect.	WITHOUT_CLASSIFICATION	0.9999999752217998	WITHOUT_CLASSIFICATION	2.4778200171776385E-8	DEFECT
// The keyword used to insert a row without specifying // any column values	WITHOUT_CLASSIFICATION	0.999999867325322	WITHOUT_CLASSIFICATION	1.326746780090505E-7	DEFECT
//registerFunction( "trim", new StandardSQLFunction( "trim", Hibernate.STRING ) );	WITHOUT_CLASSIFICATION	0.9999999876413516	WITHOUT_CLASSIFICATION	1.2358648373709716E-8	DEFECT
//skip the FROM keyword in params	WITHOUT_CLASSIFICATION	0.9999949463959974	WITHOUT_CLASSIFICATION	5.05360400253349E-6	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
// potentialTrimCharacterArgIndex = 1 assumes that a // trim-specification has been specified.  we handle the // exception to that explicitly	WITHOUT_CLASSIFICATION	0.9999999999769179	WITHOUT_CLASSIFICATION	2.3082072487717357E-11	DEFECT
// SQLFunction implementation	WITHOUT_CLASSIFICATION	0.9999951174468208	WITHOUT_CLASSIFICATION	4.882553179254387E-6	DEFECT
// conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrap	WITHOUT_CLASSIFICATION	0.999999977064055	WITHOUT_CLASSIFICATION	2.2935944971814257E-8	DEFECT
// register the standard dialect resolver	WITHOUT_CLASSIFICATION	0.9999958428133745	WITHOUT_CLASSIFICATION	4.1571866255317095E-6	DEFECT
// register resolvers set via Environment property	WITHOUT_CLASSIFICATION	0.999999617190315	WITHOUT_CLASSIFICATION	3.8280968493238305E-7	DEFECT
// kept for backward compatibility until after the 3.1beta5 release of HA	WITHOUT_CLASSIFICATION	0.9999999145986215	WITHOUT_CLASSIFICATION	8.540137845573894E-8	DEFECT
//cache the hashcode	WITHOUT_CLASSIFICATION	0.9999987879091209	WITHOUT_CLASSIFICATION	1.212090879130215E-6	DEFECT
// the CascadingAction contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993489546883	WITHOUT_CLASSIFICATION	6.510453117697319E-7	DEFECT
// the CascadingAction implementations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999876813925377	WITHOUT_CLASSIFICATION	1.2318607462291118E-5	DEFECT
// delete does cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999580711969	WITHOUT_CLASSIFICATION	4.1928803045764586E-8	DEFECT
// orphans should be deleted during delete	WITHOUT_CLASSIFICATION	0.9999985139006415	WITHOUT_CLASSIFICATION	1.4860993585456644E-6	DEFECT
/*(LockMode) anything*/	WITHOUT_CLASSIFICATION	0.999785586602481	WITHOUT_CLASSIFICATION	2.14413397519119E-4	DEFECT
// lock doesn't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999996580000755	WITHOUT_CLASSIFICATION	3.419999245239842E-7	DEFECT
// refresh doesn't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999335901857	WITHOUT_CLASSIFICATION	6.640981430700644E-8	DEFECT
// evicts don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999187169093	WITHOUT_CLASSIFICATION	8.128309076015698E-8	DEFECT
// saves / updates don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999998944534986	WITHOUT_CLASSIFICATION	1.0554650139539461E-7	DEFECT
// orphans should be deleted during save/update	WITHOUT_CLASSIFICATION	0.9999996498012523	WITHOUT_CLASSIFICATION	3.501987477491431E-7	DEFECT
// for deprecated saveOrUpdateCopy()	WITHOUT_CLASSIFICATION	0.999999990884977	WITHOUT_CLASSIFICATION	9.115022953761997E-9	DEFECT
// persists don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999260326397	WITHOUT_CLASSIFICATION	7.396736034067316E-8	DEFECT
//a proxy cannot be transient and it breaks ForeignKeys.isTransient	WITHOUT_CLASSIFICATION	0.9999136118674995	WITHOUT_CLASSIFICATION	8.638813250052586E-5	DEFECT
// replicate does cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999943144157	WITHOUT_CLASSIFICATION	5.685584291770804E-9	DEFECT
// static helper methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999981806751372	WITHOUT_CLASSIFICATION	1.8193248628760227E-6	DEFECT
// handles arrays and newly instantiated collections	WITHOUT_CLASSIFICATION	0.9999999596406379	WITHOUT_CLASSIFICATION	4.035936209300997E-8	DEFECT
// Actually the semantics of the next three are really "Bag" // Note that, unlike objects, collection insertions, updates, // deletions are not really remembered between flushes. We // just re-use the same Lists for convenience.	WITHOUT_CLASSIFICATION	0.9999994569509895	WITHOUT_CLASSIFICATION	5.430490105151772E-7	DEFECT
// Add these directly to the executions queue	WITHOUT_CLASSIFICATION	0.999998266384383	WITHOUT_CLASSIFICATION	1.733615616907082E-6	DEFECT
// continue loop	WITHOUT_CLASSIFICATION	0.9999910384871395	WITHOUT_CLASSIFICATION	8.961512860399686E-6	DEFECT
//sort the updates by fk	WITHOUT_CLASSIFICATION	0.9999951135836846	WITHOUT_CLASSIFICATION	4.886416315250684E-6	DEFECT
//sort the updates by pk	WITHOUT_CLASSIFICATION	0.9999978986073985	WITHOUT_CLASSIFICATION	2.1013926015191372E-6	DEFECT
// the mapping of entity names to their latest batch numbers.	WITHOUT_CLASSIFICATION	0.9999993799613294	WITHOUT_CLASSIFICATION	6.20038670578441E-7	DEFECT
// the map of batch numbers to EntityInsertAction lists	WITHOUT_CLASSIFICATION	0.9999976199232632	WITHOUT_CLASSIFICATION	2.3800767369269465E-6	DEFECT
//optimize the hash size to eliminate a rehash.	WITHOUT_CLASSIFICATION	0.9999998818800749	WITHOUT_CLASSIFICATION	1.1811992513270463E-7	DEFECT
// the list of entity names that indicate the batch number	WITHOUT_CLASSIFICATION	0.9999997643244863	WITHOUT_CLASSIFICATION	2.3567551366093767E-7	DEFECT
// remove the current element from insertions. It will be added back later.	WITHOUT_CLASSIFICATION	0.9996592766596096	WITHOUT_CLASSIFICATION	3.4072334039028385E-4	DEFECT
// the entity associated with the current action.	WITHOUT_CLASSIFICATION	0.9999979950340045	WITHOUT_CLASSIFICATION	2.0049659954147686E-6	DEFECT
// There is already an existing batch for this type of entity. // Check to see if the latest batch is acceptable.	WITHOUT_CLASSIFICATION	0.9999999925507753	WITHOUT_CLASSIFICATION	7.449224712730586E-9	DEFECT
// now rebuild the insertions list. There is a batch for each entry in the name list.	WITHOUT_CLASSIFICATION	0.9999999430821288	WITHOUT_CLASSIFICATION	5.6917871203744884E-8	DEFECT
// the current batch number is the latest batch for this entity type.	WITHOUT_CLASSIFICATION	0.9999983879553546	WITHOUT_CLASSIFICATION	1.6120446453762982E-6	DEFECT
// loop through all the associations of the current entity and make sure that they are processed // before the current batch number	WITHOUT_CLASSIFICATION	0.9999999551480034	WITHOUT_CLASSIFICATION	4.485199648195438E-8	DEFECT
// find the batch number associated with the current association, if any.	WITHOUT_CLASSIFICATION	0.9999999422009855	WITHOUT_CLASSIFICATION	5.779901450386781E-8	DEFECT
// create a new batch for this type. The batch number is the number of current batches.	WITHOUT_CLASSIFICATION	0.9999989112587663	WITHOUT_CLASSIFICATION	1.0887412336287886E-6	DEFECT
// loop through all the associated entities and make sure they have been // processed before the latest // batch associated with this entity type.	WITHOUT_CLASSIFICATION	0.9999999927119186	WITHOUT_CLASSIFICATION	7.28808137143292E-9	DEFECT
// since this entity will now be processed in the latest possible batch, // we can be assured that it will come after all other associations, // there's not need to continue checking.	WITHOUT_CLASSIFICATION	0.9999999664520204	WITHOUT_CLASSIFICATION	3.354797966698151E-8	DEFECT
//cascade to current collection elements	WITHOUT_CLASSIFICATION	0.9999995863808762	WITHOUT_CLASSIFICATION	4.136191237949473E-7	DEFECT
//not really necessary, but good for consistency...	WITHOUT_CLASSIFICATION	0.9966670132302524	WITHOUT_CLASSIFICATION	0.0033329867697476077	DEFECT
// we can't cascade to non-embedded elements	WITHOUT_CLASSIFICATION	0.999999887218293	WITHOUT_CLASSIFICATION	1.1278170688096419E-7	DEFECT
//a newly instantiated collection can't have orphans	WITHOUT_CLASSIFICATION	0.9999885704886977	WITHOUT_CLASSIFICATION	1.1429511302282023E-5	DEFECT
// handle orphaned entities!!	WITHOUT_CLASSIFICATION	0.9999999892603736	WITHOUT_CLASSIFICATION	1.0739626476666992E-8	DEFECT
// Loaded entity instances, by EntityUniqueKey	WITHOUT_CLASSIFICATION	0.9999998561558594	WITHOUT_CLASSIFICATION	1.4384414063247718E-7	DEFECT
// Identity map of EntityEntry instances, by the entity instance	WITHOUT_CLASSIFICATION	0.9999994345837513	WITHOUT_CLASSIFICATION	5.654162487189889E-7	DEFECT
// Entity proxies, by EntityKey	WITHOUT_CLASSIFICATION	0.9999974618780268	WITHOUT_CLASSIFICATION	2.538121973127246E-6	DEFECT
// Snapshots of current database state for entities // that have *not* been loaded	WITHOUT_CLASSIFICATION	0.9999950979752812	WITHOUT_CLASSIFICATION	4.902024718904022E-6	DEFECT
// Identity map of array holder ArrayHolder instances, by the array instance	WITHOUT_CLASSIFICATION	0.9999988447251837	WITHOUT_CLASSIFICATION	1.155274816289301E-6	DEFECT
// Collection wrappers, by the CollectionKey //key=CollectionKey, value=PersistentCollection	WITHOUT_CLASSIFICATION	0.9999987110913112	WITHOUT_CLASSIFICATION	1.2889086887486124E-6	DEFECT
// Set of EntityKeys of deleted objects	WITHOUT_CLASSIFICATION	0.9999996827767744	WITHOUT_CLASSIFICATION	3.172232256482529E-7	DEFECT
// properties that we have tried to load, and not found in the database	WITHOUT_CLASSIFICATION	0.9999972033844081	WITHOUT_CLASSIFICATION	2.7966155918764317E-6	DEFECT
// A list of collection wrappers that were instantiating during result set // processing, that we will need to initialize at the end of the query	WITHOUT_CLASSIFICATION	0.9999973867230812	WITHOUT_CLASSIFICATION	2.613276918662472E-6	DEFECT
// A container for collections we load up when the owning entity is not // yet loaded ... for now, this is purely transient!	WITHOUT_CLASSIFICATION	0.9998653411506658	WITHOUT_CLASSIFICATION	1.3465884933416144E-4	DEFECT
// Downgrade locks	WITHOUT_CLASSIFICATION	0.9999980744909592	WITHOUT_CLASSIFICATION	1.92550904074268E-6	DEFECT
// any earlier proxy takes precedence	WITHOUT_CLASSIFICATION	0.9999984281886767	WITHOUT_CLASSIFICATION	1.5718113234284445E-6	DEFECT
//unwrap the object	WITHOUT_CLASSIFICATION	0.9999980510652821	WITHOUT_CLASSIFICATION	1.948934717891178E-6	DEFECT
//initialize + unwrap the object	WITHOUT_CLASSIFICATION	0.9999997527244959	WITHOUT_CLASSIFICATION	2.472755040851392E-7	DEFECT
//return the proxied object	WITHOUT_CLASSIFICATION	0.9999946612712133	WITHOUT_CLASSIFICATION	5.338728786679693E-6	DEFECT
//overwrite old proxy	WITHOUT_CLASSIFICATION	0.9999992293325382	WITHOUT_CLASSIFICATION	7.70667461796773E-7	DEFECT
// early exit...	WITHOUT_CLASSIFICATION	0.9997243641338949	WITHOUT_CLASSIFICATION	2.756358661051643E-4	DEFECT
// or should it actually throw an exception?	WITHOUT_CLASSIFICATION	0.9996503498745197	WITHOUT_CLASSIFICATION	3.4965012548031674E-4	DEFECT
//treat it just like a new collection	WITHOUT_CLASSIFICATION	0.9999974876609137	WITHOUT_CLASSIFICATION	2.5123390863304853E-6	DEFECT
//do this work only at the very highest level of the load //don't let this method be called recursively	WITHOUT_CLASSIFICATION	0.9884168679209842	WITHOUT_CLASSIFICATION	0.011583132079015913	DEFECT
//note that each iteration of the loop may add new elements	WITHOUT_CLASSIFICATION	0.9999999926406785	WITHOUT_CLASSIFICATION	7.359321441084019E-9	DEFECT
//it might be an unwrapped collection reference! //try to find a wrapper (slowish)	WITHOUT_CLASSIFICATION	0.9995241301377987	WITHOUT_CLASSIFICATION	4.7586986220132224E-4	DEFECT
/*public boolean isNonExistant(EntityKey key) {	WITHOUT_CLASSIFICATION	0.9999663008855352	WITHOUT_CLASSIFICATION	3.36991144647927E-5	DEFECT
/*public boolean isNonExistant(EntityUniqueKey key) {	WITHOUT_CLASSIFICATION	0.9999834943614866	WITHOUT_CLASSIFICATION	1.650563851342947E-5	DEFECT
// iterate all the entities currently associated with the persistence context.	WITHOUT_CLASSIFICATION	0.9999967994423382	WITHOUT_CLASSIFICATION	3.200557661899915E-6	DEFECT
// does this entity entry pertain to the entity persister in which we are interested (owner)?	WITHOUT_CLASSIFICATION	0.9999999587671936	WITHOUT_CLASSIFICATION	4.123280646162143E-8	DEFECT
//check if the managed object is the parent	WITHOUT_CLASSIFICATION	0.9999947396513605	WITHOUT_CLASSIFICATION	5.260348639425851E-6	DEFECT
// otherwise, the proxy was pruned during the serialization process	WITHOUT_CLASSIFICATION	0.9999991926089036	WITHOUT_CLASSIFICATION	8.073910963141949E-7	DEFECT
// adds remove as a sort-of alias for delete...	WITHOUT_CLASSIFICATION	0.999972886379178	WITHOUT_CLASSIFICATION	2.7113620821943505E-5	DEFECT
//bad cast	WITHOUT_CLASSIFICATION	0.999996114013893	WITHOUT_CLASSIFICATION	3.88598610696344E-6	DEFECT
//return lhsPersister.getSubclassPropertyColumnNames(property);	WITHOUT_CLASSIFICATION	0.9999984911398263	WITHOUT_CLASSIFICATION	1.508860173745261E-6	DEFECT
//property-refs for associations defined on a //component are not supported, so no need to slice	WITHOUT_CLASSIFICATION	0.9999999874329888	WITHOUT_CLASSIFICATION	1.256701116622165E-8	DEFECT
//if there is no property-ref, assume the join //is to the subclass table (ie. the table of the //subclass that the association belongs to)	WITHOUT_CLASSIFICATION	0.9999999975879873	WITHOUT_CLASSIFICATION	2.412012705036406E-9	DEFECT
//handle a property-ref	WITHOUT_CLASSIFICATION	0.9999996181388687	WITHOUT_CLASSIFICATION	3.818611313537097E-7	DEFECT
/*NativeSQLQueryReturn*/	WITHOUT_CLASSIFICATION	0.9999825512653132	WITHOUT_CLASSIFICATION	1.744873468670025E-5	DEFECT
//final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9999997507530155	WITHOUT_CLASSIFICATION	2.492469844776843E-7	DEFECT
// why is all others non final ?	WITHOUT_CLASSIFICATION	0.999999745405168	WITHOUT_CLASSIFICATION	2.5459483197501725E-7	DEFECT
//this.forceCacheRefresh = forceCacheRefresh;	WITHOUT_CLASSIFICATION	0.9999997577434959	WITHOUT_CLASSIFICATION	2.422565040841921E-7	DEFECT
// HELLA IMPORTANT OPTIMIZATION!!!	WITHOUT_CLASSIFICATION	0.9999793439424848	WITHOUT_CLASSIFICATION	2.0656057515246885E-5	DEFECT
/*return that.type.equals(type) && 	WITHOUT_CLASSIFICATION	0.9997107142729644	WITHOUT_CLASSIFICATION	2.8928572703564725E-4	DEFECT
//Must occur after resolving identifiers!	WITHOUT_CLASSIFICATION	0.9999990399593193	WITHOUT_CLASSIFICATION	9.600406807071805E-7	DEFECT
//take a snapshot	WITHOUT_CLASSIFICATION	0.9999851933825799	WITHOUT_CLASSIFICATION	1.4806617420178054E-5	DEFECT
// do a check	WITHOUT_CLASSIFICATION	0.999999255503125	WITHOUT_CLASSIFICATION	7.444968750044032E-7	DEFECT
// the owning entity may have been deleted and its identifier unset due to // identifier-rollback; in which case, try to look up its identifier from // the persistence context	WITHOUT_CLASSIFICATION	0.9999998089146699	WITHOUT_CLASSIFICATION	1.9108533012309485E-7	DEFECT
// do the work	WITHOUT_CLASSIFICATION	0.9993453324937487	WITHOUT_CLASSIFICATION	6.546675062514268E-4	DEFECT
// We've been here before	WITHOUT_CLASSIFICATION	0.999987708715702	WITHOUT_CLASSIFICATION	1.2291284298134145E-5	DEFECT
// it is or was referenced _somewhere_	WITHOUT_CLASSIFICATION	0.9999998988056741	WITHOUT_CLASSIFICATION	1.0119432594812036E-7	DEFECT
// do the work	WITHOUT_CLASSIFICATION	0.9993453324937487	WITHOUT_CLASSIFICATION	6.546675062514268E-4	DEFECT
// if either its role changed,	WITHOUT_CLASSIFICATION	0.9999999973092868	WITHOUT_CLASSIFICATION	2.690713304492563E-9	DEFECT
// or its key changed	WITHOUT_CLASSIFICATION	0.9999997809078051	WITHOUT_CLASSIFICATION	2.1909219496243375E-7	DEFECT
// we will need to create new entries	WITHOUT_CLASSIFICATION	0.9999997831280942	WITHOUT_CLASSIFICATION	2.1687190585539844E-7	DEFECT
// we will need to remove ye olde entries	WITHOUT_CLASSIFICATION	0.9999817646061832	WITHOUT_CLASSIFICATION	1.823539381677706E-5	DEFECT
// force initialize!	WITHOUT_CLASSIFICATION	0.9999999269054048	WITHOUT_CLASSIFICATION	7.309459523248155E-8	DEFECT
// else if it's elements changed	WITHOUT_CLASSIFICATION	0.9999999983533402	WITHOUT_CLASSIFICATION	1.6466597696404876E-9	DEFECT
//ATTRIBUTES MAINTAINED BETWEEN FLUSH CYCLES	WITHOUT_CLASSIFICATION	0.9999970814578122	WITHOUT_CLASSIFICATION	2.918542187831985E-6	DEFECT
// session-start/post-flush persistent state	WITHOUT_CLASSIFICATION	0.9999999834119268	WITHOUT_CLASSIFICATION	1.6588073191209743E-8	DEFECT
// allow the CollectionSnapshot to be serialized	WITHOUT_CLASSIFICATION	0.99999992447402	WITHOUT_CLASSIFICATION	7.552597995690289E-8	DEFECT
// ATTRIBUTES USED ONLY DURING FLUSH CYCLE	WITHOUT_CLASSIFICATION	0.9999996104827753	WITHOUT_CLASSIFICATION	3.895172246309795E-7	DEFECT
// "current" means the reference that was found during flush() 	WITHOUT_CLASSIFICATION	0.9999968192000124	WITHOUT_CLASSIFICATION	3.180799987684941E-6	DEFECT
// "loaded" means the reference that is consistent  // with the current database state	WITHOUT_CLASSIFICATION	0.9999962845408257	WITHOUT_CLASSIFICATION	3.7154591742653917E-6	DEFECT
// during flush, we navigate the object graph to // collections and decide what to do with them	WITHOUT_CLASSIFICATION	0.9999999550020954	WITHOUT_CLASSIFICATION	4.499790459526728E-8	DEFECT
// if we instantiate a collection during the flush() process, // we must ignore it for the rest of the flush()	WITHOUT_CLASSIFICATION	0.9999999993518943	WITHOUT_CLASSIFICATION	6.481057067505696E-10	DEFECT
// new collections that get found + wrapped // during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9999992657887523	WITHOUT_CLASSIFICATION	7.342112476922221E-7	DEFECT
//a newly wrapped collection is NOT dirty (or we get unnecessary version updates)	WITHOUT_CLASSIFICATION	0.9999983163968372	WITHOUT_CLASSIFICATION	1.683603162774894E-6	DEFECT
//collection.clearDirty()	WITHOUT_CLASSIFICATION	0.9999823889085785	WITHOUT_CLASSIFICATION	1.7611091421541793E-5	DEFECT
//collection.clearDirty()	WITHOUT_CLASSIFICATION	0.9999823889085785	WITHOUT_CLASSIFICATION	1.7611091421541793E-5	DEFECT
// detached collections that get found + reattached // during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9999990899632455	WITHOUT_CLASSIFICATION	9.100367545698391E-7	DEFECT
//optimization	WITHOUT_CLASSIFICATION	0.9999340477545691	WITHOUT_CLASSIFICATION	6.595224543091154E-5	DEFECT
//optimization //optimization	WITHOUT_CLASSIFICATION	0.9999488602699128	WITHOUT_CLASSIFICATION	5.113973008708515E-5	DEFECT
//re-snapshot	WITHOUT_CLASSIFICATION	0.9999971605477713	WITHOUT_CLASSIFICATION	2.839452228659654E-6	DEFECT
// for convenience to save some lookups	WITHOUT_CLASSIFICATION	0.999999376466343	WITHOUT_CLASSIFICATION	6.235336570891752E-7	DEFECT
//NOTE: this is not updated when properties are fetched lazily!	WITHOUT_CLASSIFICATION	0.9459086167496199	WITHOUT_CLASSIFICATION	0.054091383250379974	DEFECT
//memory optimization	WITHOUT_CLASSIFICATION	0.99993111636301	WITHOUT_CLASSIFICATION	6.888363699007534E-5	DEFECT
// use the id value of a newly instantiated instance as the unsaved-value	WITHOUT_CLASSIFICATION	0.9999999459336952	WITHOUT_CLASSIFICATION	5.406630466531487E-8	DEFECT
// copied from Session:	WITHOUT_CLASSIFICATION	0.9999992698665552	WITHOUT_CLASSIFICATION	7.301334448359506E-7	DEFECT
// this should not happen since the DTD prevents it	WITHOUT_CLASSIFICATION	0.999933541845941	WITHOUT_CLASSIFICATION	6.645815405900035E-5	DEFECT
// JoinProcessor needs to know if the where clause fragment came from a dynamic filter or not so it // can put the where clause fragment in the right place in the SQL AST.   'hasFilterCondition' keeps track // of that fact.	WITHOUT_CLASSIFICATION	0.9999813395836102	WITHOUT_CLASSIFICATION	1.8660416389807892E-5	DEFECT
// the current join represents the join between a many-to-many association table // and its "target" table.  Here we need to apply any additional filters // defined specifically on the many-to-many	WITHOUT_CLASSIFICATION	0.9999999983465613	WITHOUT_CLASSIFICATION	1.6534387498412227E-9	DEFECT
//check basic level one nullablilty	WITHOUT_CLASSIFICATION	0.9999999215214125	WITHOUT_CLASSIFICATION	7.847858749489036E-8	DEFECT
//values is not null and is checkable, we'll look deeper	WITHOUT_CLASSIFICATION	0.9999979896851262	WITHOUT_CLASSIFICATION	2.0103148737804825E-6	DEFECT
//for non null args, check for components and elements containing components	WITHOUT_CLASSIFICATION	0.9999999978909558	WITHOUT_CLASSIFICATION	2.109044141183125E-9	DEFECT
//cache the hashcode	WITHOUT_CLASSIFICATION	0.9999987879091209	WITHOUT_CLASSIFICATION	1.212090879130215E-6	DEFECT
//persistent collections may have components	WITHOUT_CLASSIFICATION	0.9999997202872974	WITHOUT_CLASSIFICATION	2.797127025555553E-7	DEFECT
//check for all components values in the collection	WITHOUT_CLASSIFICATION	0.9999997746628213	WITHOUT_CLASSIFICATION	2.2533717876595158E-7	DEFECT
/* will check current level if some of them are not null	WITHOUT_CLASSIFICATION	0.9990907811040363	WITHOUT_CLASSIFICATION	9.092188959636651E-4	DEFECT
//do the test	WITHOUT_CLASSIFICATION	0.9999993240621206	WITHOUT_CLASSIFICATION	6.759378793882015E-7	DEFECT
// if its an uninitialized proxy it can't be transient	WITHOUT_CLASSIFICATION	0.9999999445926979	WITHOUT_CLASSIFICATION	5.540730206376085E-8	DEFECT
//unwrap it	WITHOUT_CLASSIFICATION	0.9999956278230402	WITHOUT_CLASSIFICATION	4.372176959803011E-6	DEFECT
// See if the entity is already bound to this session, if not look at the // entity identifier and assume that the entity is persistent if the // id is not "unsaved" (that is, we rely on foreign keys to keep // database integrity)	WITHOUT_CLASSIFICATION	0.99999995240185	WITHOUT_CLASSIFICATION	4.7598149962657456E-8	DEFECT
// an unfetched association can only point to // an entity that already exists in the db	WITHOUT_CLASSIFICATION	0.9999998996215672	WITHOUT_CLASSIFICATION	1.0037843273626475E-7	DEFECT
// let the interceptor inspect the instance to decide	WITHOUT_CLASSIFICATION	0.9999999497691987	WITHOUT_CLASSIFICATION	5.0230801259024456E-8	DEFECT
// let the persister inspect the instance to decide	WITHOUT_CLASSIFICATION	0.9999998568884245	WITHOUT_CLASSIFICATION	1.4311157542851464E-7	DEFECT
// we use the assumed value, if there is one, to avoid hitting // the database	WITHOUT_CLASSIFICATION	0.9999999989847099	WITHOUT_CLASSIFICATION	1.015290106808603E-9	DEFECT
// hit the database, after checking the session cache for a snapshot	WITHOUT_CLASSIFICATION	0.9999957288102026	WITHOUT_CLASSIFICATION	4.271189797415811E-6	DEFECT
// context-entity-identifier returns null explicitly if the entity // is not associated with the persistence context; so make some // deeper checks...	WITHOUT_CLASSIFICATION	0.9999952845142396	WITHOUT_CLASSIFICATION	4.7154857604486285E-6	DEFECT
//int count = 0;	WITHOUT_CLASSIFICATION	0.9999906621837508	WITHOUT_CLASSIFICATION	9.337816249238257E-6	DEFECT
//the first key found after the given key	WITHOUT_CLASSIFICATION	0.9999966061331528	WITHOUT_CLASSIFICATION	3.3938668472364064E-6	DEFECT
//checkForEnd = false;	WITHOUT_CLASSIFICATION	0.9999995351941966	WITHOUT_CLASSIFICATION	4.6480580348173465E-7	DEFECT
//count++;	WITHOUT_CLASSIFICATION	0.9999295591964894	WITHOUT_CLASSIFICATION	7.044080351051128E-5	DEFECT
//end of array, start filling again from start	WITHOUT_CLASSIFICATION	0.9999990980102186	WITHOUT_CLASSIFICATION	9.019897814393201E-7	DEFECT
//we ran out of keys to try	WITHOUT_CLASSIFICATION	0.9999972265241525	WITHOUT_CLASSIFICATION	2.773475847617296E-6	DEFECT
//first element of array is reserved for the actual instance we are loading!	WITHOUT_CLASSIFICATION	0.9999981798781277	WITHOUT_CLASSIFICATION	1.8201218722570543E-6	DEFECT
//the first id found after the given id	WITHOUT_CLASSIFICATION	0.9999975580509438	WITHOUT_CLASSIFICATION	2.4419490562479087E-6	DEFECT
//we ran out of ids to try	WITHOUT_CLASSIFICATION	0.999991047631623	WITHOUT_CLASSIFICATION	8.95236837697704E-6	DEFECT
// look for existing collection as part of the persistence context	WITHOUT_CLASSIFICATION	0.9999995456372958	WITHOUT_CLASSIFICATION	4.5436270423424406E-7	DEFECT
// ignore this row of results! Note the early exit	WITHOUT_CLASSIFICATION	0.9999618663453098	WITHOUT_CLASSIFICATION	3.813365469004851E-5	DEFECT
// initialize this collection	WITHOUT_CLASSIFICATION	0.9999997367111138	WITHOUT_CLASSIFICATION	2.6328888634361734E-7	DEFECT
// create one	WITHOUT_CLASSIFICATION	0.9999997458147566	WITHOUT_CLASSIFICATION	2.5418524334158317E-7	DEFECT
// warning: can cause a recursive calls! (proxy initialization)	WITHOUT_CLASSIFICATION	0.9963338707601616	WITHOUT_CLASSIFICATION	0.0036661292398384748	DEFECT
// there were no queued additions // and the role has a cache	WITHOUT_CLASSIFICATION	0.9999997627599914	WITHOUT_CLASSIFICATION	2.3724000873582705E-7	DEFECT
// and this is not a forced initialization during flush	WITHOUT_CLASSIFICATION	0.9999984689375757	WITHOUT_CLASSIFICATION	1.5310624243619583E-6	DEFECT
// some filters affecting the collection are enabled on the session, so do not do the put into the cache.	WITHOUT_CLASSIFICATION	0.999999712454761	WITHOUT_CLASSIFICATION	2.8754523890186424E-7	DEFECT
// cleanup code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999918072140662	WITHOUT_CLASSIFICATION	8.192785933687997E-6	DEFECT
// loading collection xrefs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999899276427222	WITHOUT_CLASSIFICATION	1.0072357277784803E-5	DEFECT
// Collection load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999961796035207	WITHOUT_CLASSIFICATION	3.820396479242269E-6	DEFECT
// simple cache of param metadata based on query string.  Ideally, the // original "user-supplied query" string should be used to retreive this // metadata (i.e., not the para-list-expanded query string) to avoid // unnecessary cache entries. // Used solely for caching param metadata for native-sql queries, see // getSQLParameterMetadata() for a discussion as to why...	WITHOUT_CLASSIFICATION	0.9982387970249481	WITHOUT_CLASSIFICATION	0.0017612029750519206	DEFECT
// the cache of the actual plans...	WITHOUT_CLASSIFICATION	0.9999852084061068	WITHOUT_CLASSIFICATION	1.479159389311718E-5	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
// assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.9999996721186791	WITHOUT_CLASSIFICATION	3.278813209065632E-7	DEFECT
// for native-sql queries, the param metadata is determined outside // any relation to a query plan, because query plan creation and/or // retreival for a native-sql query depends on all of the return // types having been set, which might not be the case up-front when // param metadata would be most useful	WITHOUT_CLASSIFICATION	0.9999981350398885	WITHOUT_CLASSIFICATION	1.8649601114346524E-6	DEFECT
// don't care...	WITHOUT_CLASSIFICATION	0.9965369009207132	WITHOUT_CLASSIFICATION	0.0034630990792866986	DEFECT
// Recognition code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999825436805173	WITHOUT_CLASSIFICATION	1.745631948269624E-4	DEFECT
// don't care...	WITHOUT_CLASSIFICATION	0.9965369009207132	WITHOUT_CLASSIFICATION	0.0034630990792866986	DEFECT
// NOTE : firstRow is zero-based	WITHOUT_CLASSIFICATION	0.9999983849166201	WITHOUT_CLASSIFICATION	1.6150833799085493E-6	DEFECT
// break the outer loop !!!	WITHOUT_CLASSIFICATION	0.9999995382353073	WITHOUT_CLASSIFICATION	4.6176469275884697E-7	DEFECT
// named parameter	WITHOUT_CLASSIFICATION	0.9999998670103211	WITHOUT_CLASSIFICATION	1.329896789301302E-7	DEFECT
// could be either an ordinal or JPA-positional parameter	WITHOUT_CLASSIFICATION	0.9999996627835234	WITHOUT_CLASSIFICATION	3.372164766973801E-7	DEFECT
// a peek ahead showed this as an JPA-positional parameter	WITHOUT_CLASSIFICATION	0.9999999448056898	WITHOUT_CLASSIFICATION	5.5194310301230205E-8	DEFECT
// make sure this "name" is an integral	WITHOUT_CLASSIFICATION	0.9999996693362876	WITHOUT_CLASSIFICATION	3.306637123494235E-7	DEFECT
// pre-determine and cache the hashcode	WITHOUT_CLASSIFICATION	0.9999999705514127	WITHOUT_CLASSIFICATION	2.9448587391972413E-8	DEFECT
// perform the actual work	WITHOUT_CLASSIFICATION	0.9999825447553243	WITHOUT_CLASSIFICATION	1.7455244675641975E-5	DEFECT
// if everything went ok, commit the transaction and close the obtained // connection handle...	WITHOUT_CLASSIFICATION	0.9999999274318773	WITHOUT_CLASSIFICATION	7.256812277377547E-8	DEFECT
// at some point the processing went bad, so we need to: //      1) make sure the connection handle gets released //      2) try to cleanup the JTA context as much as possible	WITHOUT_CLASSIFICATION	0.9999992396458732	WITHOUT_CLASSIFICATION	7.60354126812166E-7	DEFECT
// finally handle the exception	WITHOUT_CLASSIFICATION	0.9999978303616297	WITHOUT_CLASSIFICATION	2.1696383702669602E-6	DEFECT
// a "detached" collection that belonged to a different entity	WITHOUT_CLASSIFICATION	0.9999998589148167	WITHOUT_CLASSIFICATION	1.4108518342910488E-7	DEFECT
//saveOrUpdateCopy() is deprecated!	WITHOUT_CLASSIFICATION	0.9999992861810687	WITHOUT_CLASSIFICATION	7.138189312339232E-7	DEFECT
// collectionPersister should not be null, but we don't want to throw // an exception if it is null	WITHOUT_CLASSIFICATION	0.9994362134066204	WITHOUT_CLASSIFICATION	5.637865933795525E-4	DEFECT
// otherwise a null or brand new collection // this will also (inefficiently) handle arrays, which // have no snapshot, so we can't do any better //processArrayOrNewCollection(collection, type);	WITHOUT_CLASSIFICATION	0.9999999521816162	WITHOUT_CLASSIFICATION	4.7818383855342597E-8	DEFECT
// a "detached" collection that originally belonged to the same entity	WITHOUT_CLASSIFICATION	0.9999998587401894	WITHOUT_CLASSIFICATION	1.412598106639822E-7	DEFECT
//do nothing	WITHOUT_CLASSIFICATION	0.9999964384690594	WITHOUT_CLASSIFICATION	3.5615309407163037E-6	DEFECT
//do nothing	WITHOUT_CLASSIFICATION	0.9999964384690594	WITHOUT_CLASSIFICATION	3.5615309407163037E-6	DEFECT
//Force a substitution!	WITHOUT_CLASSIFICATION	0.999998264841771	WITHOUT_CLASSIFICATION	1.7351582289990707E-6	DEFECT
// The user requested a "greater" (i.e. more restrictive) form of // pessimistic lock	WITHOUT_CLASSIFICATION	0.9999995717359348	WITHOUT_CLASSIFICATION	4.282640651799454E-7	DEFECT
// the database now holds a lock + the object is flushed from the cache, // so release the soft lock	WITHOUT_CLASSIFICATION	0.9999931666073872	WITHOUT_CLASSIFICATION	6.833392612733443E-6	DEFECT
// now update the object .. has to be outside the main if block above (because of collections)	WITHOUT_CLASSIFICATION	0.9999999462212755	WITHOUT_CLASSIFICATION	5.3778724480269196E-8	DEFECT
// Search for collections by reachability, updating their role. // We don't want to touch collections reachable from a deleted object	WITHOUT_CLASSIFICATION	0.9999997133913854	WITHOUT_CLASSIFICATION	2.8660861459225057E-7	DEFECT
// this is a situation where the entity id is assigned by a post-insert generator // and was saved outside the transaction forcing it to be delayed	WITHOUT_CLASSIFICATION	0.9999992792077224	WITHOUT_CLASSIFICATION	7.207922776321844E-7	DEFECT
// NOTE: we need to do the wrap here even if its not "dirty", // because collections need wrapping but changes to _them_ // don't dirty the container. Also, for versioned data, we // need to wrap before calling searchForDirtyCollections	WITHOUT_CLASSIFICATION	0.9999981501227598	WITHOUT_CLASSIFICATION	1.8498772400905723E-6	DEFECT
//grab its state saved at deletion	WITHOUT_CLASSIFICATION	0.9999990805149512	WITHOUT_CLASSIFICATION	9.19485048732914E-7	DEFECT
// grab its current state	WITHOUT_CLASSIFICATION	0.9999999425416382	WITHOUT_CLASSIFICATION	5.7458361944156865E-8	DEFECT
// schedule the update // note that we intentionally do _not_ pass in currentPersistentState!	WITHOUT_CLASSIFICATION	0.9999993597559472	WITHOUT_CLASSIFICATION	6.402440528551101E-7	DEFECT
// substitutes into values by side-effect	WITHOUT_CLASSIFICATION	0.9999994290981425	WITHOUT_CLASSIFICATION	5.709018574266467E-7	DEFECT
// give the Interceptor a chance to process property values, if the properties // were modified by the Interceptor, we need to set them back to the object	WITHOUT_CLASSIFICATION	0.9999999980395324	WITHOUT_CLASSIFICATION	1.960467635399022E-9	DEFECT
// compare to cached state (ignoring collections unless versioned)	WITHOUT_CLASSIFICATION	0.9999999691805421	WITHOUT_CLASSIFICATION	3.0819457889856984E-8	DEFECT
// if it was dirtied by a collection only	WITHOUT_CLASSIFICATION	0.999999507773387	WITHOUT_CLASSIFICATION	4.922266130500031E-7	DEFECT
// increment the version number (if necessary)	WITHOUT_CLASSIFICATION	0.9999997977488093	WITHOUT_CLASSIFICATION	2.0225119060978196E-7	DEFECT
// check nullability but do not perform command execute // we'll use scheduled updates for that.	WITHOUT_CLASSIFICATION	0.9999998975744311	WITHOUT_CLASSIFICATION	1.024255688408367E-7	DEFECT
//give the Interceptor a chance to modify property values	WITHOUT_CLASSIFICATION	0.999999655106427	WITHOUT_CLASSIFICATION	3.448935730967628E-7	DEFECT
//now we might need to recalculate the dirtyProperties array	WITHOUT_CLASSIFICATION	0.9999991633854681	WITHOUT_CLASSIFICATION	8.366145317808127E-7	DEFECT
//use the current version	WITHOUT_CLASSIFICATION	0.9999984102337041	WITHOUT_CLASSIFICATION	1.5897662959884074E-6	DEFECT
// Interceptor returned null, so do the dirtycheck ourself, if possible	WITHOUT_CLASSIFICATION	0.9999999966854597	WITHOUT_CLASSIFICATION	3.3145403823878633E-9	DEFECT
// object loaded by update()	WITHOUT_CLASSIFICATION	0.9999989894382854	WITHOUT_CLASSIFICATION	1.0105617146741668E-6	DEFECT
// dirty check against the usual snapshot of the entity	WITHOUT_CLASSIFICATION	0.9999999645095479	WITHOUT_CLASSIFICATION	3.549045218183905E-8	DEFECT
// dirty check against the database snapshot, if possible/necessary	WITHOUT_CLASSIFICATION	0.9999997716549155	WITHOUT_CLASSIFICATION	2.283450845344121E-7	DEFECT
// the Interceptor handled the dirty checking	WITHOUT_CLASSIFICATION	0.9999999984375892	WITHOUT_CLASSIFICATION	1.562410754549516E-9	DEFECT
//even process null collections	WITHOUT_CLASSIFICATION	0.9999993370125235	WITHOUT_CLASSIFICATION	6.629874764018899E-7	DEFECT
// get the id from the object	WITHOUT_CLASSIFICATION	0.9999989763067437	WITHOUT_CLASSIFICATION	1.023693256255335E-6	DEFECT
//always do an INSERT, and let it fail by constraint violation	WITHOUT_CLASSIFICATION	0.9999949401428487	WITHOUT_CLASSIFICATION	5.0598571513231945E-6	DEFECT
//what is the version on the database?	WITHOUT_CLASSIFICATION	0.9999309555690018	WITHOUT_CLASSIFICATION	6.904443099821604E-5	DEFECT
/// HHH-2378	WITHOUT_CLASSIFICATION	0.9999955359718736	WITHOUT_CLASSIFICATION	4.4640281263861264E-6	DEFECT
//will result in a SQL UPDATE:	WITHOUT_CLASSIFICATION	0.9999690610570513	WITHOUT_CLASSIFICATION	3.093894294871874E-5	DEFECT
//else do nothing (don't even reassociate object!)	WITHOUT_CLASSIFICATION	0.999999246957699	WITHOUT_CLASSIFICATION	7.530423009773321E-7	DEFECT
// no existing row - do an insert	WITHOUT_CLASSIFICATION	0.9999997993274592	WITHOUT_CLASSIFICATION	2.0067254070559537E-7	DEFECT
//refresh() does not pass an entityName	WITHOUT_CLASSIFICATION	0.9999670006312413	WITHOUT_CLASSIFICATION	3.2999368758600296E-5	DEFECT
//do not return a proxy! //(this option indicates we are initializing a proxy)	WITHOUT_CLASSIFICATION	0.9999998828566536	WITHOUT_CLASSIFICATION	1.1714334636543717E-7	DEFECT
//return a proxy if appropriate	WITHOUT_CLASSIFICATION	0.9999923613686568	WITHOUT_CLASSIFICATION	7.638631343316514E-6	DEFECT
// return existing object or initialized proxy (unless deleted)	WITHOUT_CLASSIFICATION	0.9999999968023624	WITHOUT_CLASSIFICATION	3.197637577257074E-9	DEFECT
// return new uninitialized proxy	WITHOUT_CLASSIFICATION	0.9999999447748931	WITHOUT_CLASSIFICATION	5.522510691723055E-8	DEFECT
// this object was already loaded	WITHOUT_CLASSIFICATION	0.9999983135572812	WITHOUT_CLASSIFICATION	1.686442718818088E-6	DEFECT
// Entity was found in second-level cache...	WITHOUT_CLASSIFICATION	0.999959675276157	WITHOUT_CLASSIFICATION	4.032472384300492E-5	DEFECT
// make it circular-reference safe	WITHOUT_CLASSIFICATION	0.9999955682106779	WITHOUT_CLASSIFICATION	4.4317893220365695E-6	DEFECT
// intializes result by side-effect	WITHOUT_CLASSIFICATION	0.9999987939228153	WITHOUT_CLASSIFICATION	1.2060771846668477E-6	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Pre-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999983619738231	WITHOUT_CLASSIFICATION	1.6380261769215923E-6	DEFECT
//some statistics	WITHOUT_CLASSIFICATION	0.9999982948233939	WITHOUT_CLASSIFICATION	1.705176606161238E-6	DEFECT
//safe from concurrent modification because of how entryList() is implemented on IdentityMap	WITHOUT_CLASSIFICATION	0.9997864901745847	WITHOUT_CLASSIFICATION	2.1350982541536103E-4	DEFECT
// Initialize dirty flags for arrays + collections with composite elements // and reset reached, doupdate, etc.	WITHOUT_CLASSIFICATION	0.9999998497803849	WITHOUT_CLASSIFICATION	1.5021961510212728E-7	DEFECT
// Among other things, updateReachables() will recursively load all // collections that are moving roles. This might cause entities to // be loaded.	WITHOUT_CLASSIFICATION	0.9997102071695697	WITHOUT_CLASSIFICATION	2.8979283043022863E-4	DEFECT
// So this needs to be safe from concurrent modification problems. // It is safe because of how IdentityMap implements entrySet()	WITHOUT_CLASSIFICATION	0.9873650577851538	WITHOUT_CLASSIFICATION	0.012634942214846233	DEFECT
// Update the status of the object and if necessary, schedule an update	WITHOUT_CLASSIFICATION	0.999999997598051	WITHOUT_CLASSIFICATION	2.4019489784020884E-9	DEFECT
// Schedule updates to collections:	WITHOUT_CLASSIFICATION	0.9999996887353911	WITHOUT_CLASSIFICATION	3.1126460890581834E-7	DEFECT
// we need to lock the collection caches before // executing entity inserts/updates in order to // account for bidi associations	WITHOUT_CLASSIFICATION	0.9999989715952033	WITHOUT_CLASSIFICATION	1.0284047966486405E-6	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // Post-flushing section // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999989789590936	WITHOUT_CLASSIFICATION	1.0210409064210037E-6	DEFECT
//the database has changed now, so the subselect results need to be invalidated	WITHOUT_CLASSIFICATION	0.9999999887846719	WITHOUT_CLASSIFICATION	1.1215328203053678E-8	DEFECT
//if the collection is dereferenced, remove from the session cache //iter.remove(); //does not work, since the entrySet is not backed by the set	WITHOUT_CLASSIFICATION	0.9992142019141945	WITHOUT_CLASSIFICATION	7.857980858054353E-4	DEFECT
//otherwise recreate the mapping between the collection and its key	WITHOUT_CLASSIFICATION	0.9999999263213055	WITHOUT_CLASSIFICATION	7.367869448377503E-8	DEFECT
//get a snapshot	WITHOUT_CLASSIFICATION	0.9999979797060295	WITHOUT_CLASSIFICATION	2.020293970493013E-6	DEFECT
/* package-private */	WITHOUT_CLASSIFICATION	0.9999995651599553	WITHOUT_CLASSIFICATION	4.3484004480809293E-7	DEFECT
/* package-private */	WITHOUT_CLASSIFICATION	0.9999995651599553	WITHOUT_CLASSIFICATION	4.3484004480809293E-7	DEFECT
// key is an entity involved with the operation performed by the listener; // value is a flag indicating if the listener explicitly operates on the entity	WITHOUT_CLASSIFICATION	0.9999996734600487	WITHOUT_CLASSIFICATION	3.265399512594195E-7	DEFECT
// EARLY EXIT!!!	WITHOUT_CLASSIFICATION	0.9999770782883297	WITHOUT_CLASSIFICATION	2.292171167032409E-5	DEFECT
//ie. the entity came in from update()	WITHOUT_CLASSIFICATION	0.9999932820808171	WITHOUT_CLASSIFICATION	6.717919183000433E-6	DEFECT
// before any callbacks, etc, so subdeletions see that this deletion happened first	WITHOUT_CLASSIFICATION	0.9999755033082335	WITHOUT_CLASSIFICATION	2.449669176661195E-5	DEFECT
// Ensures that containing deletions happen before sub-deletions	WITHOUT_CLASSIFICATION	0.9999994520901346	WITHOUT_CLASSIFICATION	5.479098654540338E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// cascade-delete to collections BEFORE the collection owner is deleted	WITHOUT_CLASSIFICATION	0.9999965794937384	WITHOUT_CLASSIFICATION	3.420506261455937E-6	DEFECT
// cascade-delete to many-to-one AFTER the parent was deleted	WITHOUT_CLASSIFICATION	0.9999994611923543	WITHOUT_CLASSIFICATION	5.38807645713677E-7	DEFECT
// if it is an initialized proxy, let cascade // handle it later on	WITHOUT_CLASSIFICATION	0.999999994382746	WITHOUT_CLASSIFICATION	5.6172539696797946E-9	DEFECT
//assign the requested id to the proxy, *before* //reassociating the proxy	WITHOUT_CLASSIFICATION	0.9999975979590493	WITHOUT_CLASSIFICATION	2.402040950657003E-6	DEFECT
// an uninitialized proxy, noop, don't even need to // return an id, since it is never a save()	WITHOUT_CLASSIFICATION	0.9999999966941447	WITHOUT_CLASSIFICATION	3.3058552147848485E-9	DEFECT
//initialize properties of the event:	WITHOUT_CLASSIFICATION	0.9999959344885548	WITHOUT_CLASSIFICATION	4.065511445147234E-6	DEFECT
//return the id in the event object	WITHOUT_CLASSIFICATION	0.9999838116378424	WITHOUT_CLASSIFICATION	1.6188362157563722E-5	DEFECT
//TRANSIENT or DELETED	WITHOUT_CLASSIFICATION	0.9999991540306934	WITHOUT_CLASSIFICATION	8.459693066318876E-7	DEFECT
// use the id assigned to the instance	WITHOUT_CLASSIFICATION	0.9999999740720288	WITHOUT_CLASSIFICATION	2.59279712568499E-8	DEFECT
// assume this is a newly instantiated transient object // which should be saved rather than updated	WITHOUT_CLASSIFICATION	0.9999992367803904	WITHOUT_CLASSIFICATION	7.632196096869758E-7	DEFECT
// this is a transient object with existing persistent state not loaded by the session	WITHOUT_CLASSIFICATION	0.9998287204171947	WITHOUT_CLASSIFICATION	1.7127958280532956E-4	DEFECT
// a collection loaded in the current session // can not possibly be the collection belonging // to the entity passed to update()	WITHOUT_CLASSIFICATION	0.999997579584961	WITHOUT_CLASSIFICATION	2.420415038836016E-6	DEFECT
//cachedState,	WITHOUT_CLASSIFICATION	0.9999981525181266	WITHOUT_CLASSIFICATION	1.8474818734303854E-6	DEFECT
//assume true, since we don't really know, and it doesn't matter	WITHOUT_CLASSIFICATION	0.9998625009089736	WITHOUT_CLASSIFICATION	1.3749909102636648E-4	DEFECT
//a "detached" collection!	WITHOUT_CLASSIFICATION	0.999984392234227	WITHOUT_CLASSIFICATION	1.5607765772983325E-5	DEFECT
// if the collection belonged to a different entity, // clean up the existing state of the collection	WITHOUT_CLASSIFICATION	0.9999999906617341	WITHOUT_CLASSIFICATION	9.338265966687893E-9	DEFECT
//log.debug( "calling onLoad()" );	WITHOUT_CLASSIFICATION	0.9999847937656418	WITHOUT_CLASSIFICATION	1.5206234358288069E-5	DEFECT
//EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999655062189466	WITHOUT_CLASSIFICATION	3.449378105341125E-5	DEFECT
// note: performExecutions() clears all collectionXxxxtion  // collections (the collection actions) in the session	WITHOUT_CLASSIFICATION	0.9994149588180453	WITHOUT_CLASSIFICATION	5.850411819547103E-4	DEFECT
// if no array holder we found an unwrappered array (this can't occur, // because we now always call wrap() before getting to here) // return (ah==null) ? true : searchForDirtyCollections(ah, type);	WITHOUT_CLASSIFICATION	0.9995811213041986	WITHOUT_CLASSIFICATION	4.1887869580135254E-4	DEFECT
// if not wrappered yet, its dirty (this can't occur, because // we now always call wrap() before getting to here) // return ( ! (obj instanceof PersistentCollection) ) ? //true : searchForDirtyCollections( (PersistentCollection) obj, type );	WITHOUT_CLASSIFICATION	0.9950771728493315	WITHOUT_CLASSIFICATION	0.004922827150668452	DEFECT
//we need to check even if it was not initialized, because of delayed adds!	WITHOUT_CLASSIFICATION	0.9999989993170776	WITHOUT_CLASSIFICATION	1.0006829224237E-6	DEFECT
//NOTE: EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9996427553748141	WITHOUT_CLASSIFICATION	3.572446251858308E-4	DEFECT
// find any entities that are still transient after retry	WITHOUT_CLASSIFICATION	0.9999980478769508	WITHOUT_CLASSIFICATION	1.9521230491771434E-6	DEFECT
//EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999655062189466	WITHOUT_CLASSIFICATION	3.449378105341125E-5	DEFECT
// Check the persistence context for an entry relating to this // entity to be merged...	WITHOUT_CLASSIFICATION	0.9999982968587342	WITHOUT_CLASSIFICATION	1.7031412657128967E-6	DEFECT
// we have specialized case of a detached entity from the // perspective of the merge operation.  Specifically, we // have an incoming entity instance which has a corresponding // entry in the current persistence context, but registered // under a different entity instance	WITHOUT_CLASSIFICATION	0.9999937942408947	WITHOUT_CLASSIFICATION	6.205759105228947E-6	DEFECT
//DELETED	WITHOUT_CLASSIFICATION	0.9999821965689557	WITHOUT_CLASSIFICATION	1.7803431044262623E-5	DEFECT
//before cascade!	WITHOUT_CLASSIFICATION	0.9999953872653785	WITHOUT_CLASSIFICATION	4.612734621528118E-6	DEFECT
// cascade first, so that all unsaved objects get their // copy created before we actually copy //cascadeOnMerge(event, persister, entity, copyCache, Cascades.CASCADE_BEFORE_MERGE);	WITHOUT_CLASSIFICATION	0.9999999921656961	WITHOUT_CLASSIFICATION	7.834303832276488E-9	DEFECT
//this bit is only *really* absolutely necessary for handling //requestedId, but is also good if we merge multiple object //graphs, since it helps ensure uniqueness	WITHOUT_CLASSIFICATION	0.9999999153040121	WITHOUT_CLASSIFICATION	8.469598787205315E-8	DEFECT
// continue...; we'll find out if it ends up not getting saved later	WITHOUT_CLASSIFICATION	0.9999944102341944	WITHOUT_CLASSIFICATION	5.5897658055772875E-6	DEFECT
// cascade first, so that all unsaved objects get their // copy created before we actually copy	WITHOUT_CLASSIFICATION	0.9999997882841837	WITHOUT_CLASSIFICATION	2.117158163051614E-7	DEFECT
// check that entity id = requestedId	WITHOUT_CLASSIFICATION	0.9999997595456961	WITHOUT_CLASSIFICATION	2.404543039865865E-7	DEFECT
//before cascade!	WITHOUT_CLASSIFICATION	0.9999953872653785	WITHOUT_CLASSIFICATION	4.612734621528118E-6	DEFECT
// we got here because we assumed that an instance // with an assigned id was detached, when it was // really persistent	WITHOUT_CLASSIFICATION	0.9999999759445475	WITHOUT_CLASSIFICATION	2.4055452464984776E-8	DEFECT
// cascade first, so that all unsaved objects get their  // copy created before we actually copy	WITHOUT_CLASSIFICATION	0.9999997703540033	WITHOUT_CLASSIFICATION	2.2964599662055953E-7	DEFECT
//copyValues works by reflection, so explicitly mark the entity instance dirty	WITHOUT_CLASSIFICATION	0.999903256252388	WITHOUT_CLASSIFICATION	9.67437476121245E-5	DEFECT
//EARLY EXIT	WITHOUT_CLASSIFICATION	0.999989177895297	WITHOUT_CLASSIFICATION	1.0822104702944368E-5	DEFECT
//source.getBatcher().executeBatch(); //found another way to ensure that all batched joined inserts have been executed	WITHOUT_CLASSIFICATION	0.9999998625604307	WITHOUT_CLASSIFICATION	1.3743956932963914E-7	DEFECT
// substitutes into values by side-effect	WITHOUT_CLASSIFICATION	0.9999994290981425	WITHOUT_CLASSIFICATION	5.709018574266467E-7	DEFECT
//now done in EntityIdentityInsertAction //persister.setIdentifier( entity, id, source.getEntityMode() );	WITHOUT_CLASSIFICATION	0.9999999383689017	WITHOUT_CLASSIFICATION	6.16310982774586E-8	DEFECT
//source.getPersistenceContext().removeNonExist( new EntityKey( id, persister, source.getEntityMode() ) );	WITHOUT_CLASSIFICATION	0.9999996274817223	WITHOUT_CLASSIFICATION	3.725182776364206E-7	DEFECT
//keep the existing version number in the case of replicate!	WITHOUT_CLASSIFICATION	0.9999997063308058	WITHOUT_CLASSIFICATION	2.9366919410225625E-7	DEFECT
// cascade-save to many-to-one BEFORE the parent is saved	WITHOUT_CLASSIFICATION	0.9996321095974853	WITHOUT_CLASSIFICATION	3.678904025147027E-4	DEFECT
//pass this as an argument only to avoid double looking	WITHOUT_CLASSIFICATION	0.999999985673852	WITHOUT_CLASSIFICATION	1.4326148054463763E-8	DEFECT
// the object is persistent	WITHOUT_CLASSIFICATION	0.9999986002029118	WITHOUT_CLASSIFICATION	1.3997970882551142E-6	DEFECT
//the entity is associated with the session, so check its status	WITHOUT_CLASSIFICATION	0.9999999969873535	WITHOUT_CLASSIFICATION	3.012646475648857E-9	DEFECT
// do nothing for persistent instances	WITHOUT_CLASSIFICATION	0.9999995419919977	WITHOUT_CLASSIFICATION	4.5800800230733057E-7	DEFECT
//ie. e.status==DELETED	WITHOUT_CLASSIFICATION	0.9999999264497816	WITHOUT_CLASSIFICATION	7.355021834966218E-8	DEFECT
// the object is transient or detached	WITHOUT_CLASSIFICATION	0.9999990470557489	WITHOUT_CLASSIFICATION	9.529442510841591E-7	DEFECT
//NOTE EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999788427922038	WITHOUT_CLASSIFICATION	2.115720779612896E-5	DEFECT
// Private constructor - stops checkstyle from complaining.	WITHOUT_CLASSIFICATION	0.9999999956380143	WITHOUT_CLASSIFICATION	4.361985699719327E-9	DEFECT
// First, try to find a matching constructor accepting a ViolatedConstraintNameExtracter param...	WITHOUT_CLASSIFICATION	0.999999759217913	WITHOUT_CLASSIFICATION	2.4078208714817557E-7	DEFECT
// eat it and try next	WITHOUT_CLASSIFICATION	0.9999783903683094	WITHOUT_CLASSIFICATION	2.1609631690585717E-5	DEFECT
// Otherwise, try to use the no-arg constructor	WITHOUT_CLASSIFICATION	0.9999999989070048	WITHOUT_CLASSIFICATION	1.092995324544481E-9	DEFECT
// oracle sql-state code for deadlock	WITHOUT_CLASSIFICATION	0.9999992944786634	WITHOUT_CLASSIFICATION	7.055213364877268E-7	DEFECT
// CollectionPropertyMapping processes everything except 'index'.	WITHOUT_CLASSIFICATION	0.9999994651134352	WITHOUT_CLASSIFICATION	5.348865648456767E-7	DEFECT
// remove initial ", "	WITHOUT_CLASSIFICATION	0.9999990046950367	WITHOUT_CLASSIFICATION	9.95304963372608E-7	DEFECT
// remove initial " and "	WITHOUT_CLASSIFICATION	0.9999996012586433	WITHOUT_CLASSIFICATION	3.9874135674445205E-7	DEFECT
//beforeClassTokens.add("new"); DEFINITELY DON'T HAVE THIS!!	WITHOUT_CLASSIFICATION	0.999981579488116	WITHOUT_CLASSIFICATION	1.8420511884087946E-5	DEFECT
//notAfterClassTokens.add(",");	WITHOUT_CLASSIFICATION	0.9999872707922168	WITHOUT_CLASSIFICATION	1.272920778307805E-5	DEFECT
// just especially for the trivial collection filter	WITHOUT_CLASSIFICATION	0.9999999843612052	WITHOUT_CLASSIFICATION	1.5638794808314197E-8	DEFECT
//update last non-whitespace token, if necessary	WITHOUT_CLASSIFICATION	0.9999965204743196	WITHOUT_CLASSIFICATION	3.4795256803914587E-6	DEFECT
// select-range is terminated by declaration of "from"	WITHOUT_CLASSIFICATION	0.9999998665610695	WITHOUT_CLASSIFICATION	1.334389304072245E-7	DEFECT
//scan for next non-whitespace token	WITHOUT_CLASSIFICATION	0.9999785414687701	WITHOUT_CLASSIFICATION	2.1458531229839472E-5	DEFECT
// Note this!!	WITHOUT_CLASSIFICATION	0.9999995321638231	WITHOUT_CLASSIFICATION	4.678361769046289E-7	DEFECT
// Error message constants.	WITHOUT_CLASSIFICATION	0.9999957018843182	WITHOUT_CLASSIFICATION	4.298115681803851E-6	DEFECT
// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997355197221	WITHOUT_CLASSIFICATION	2.644802778996805E-7	DEFECT
// semantic action handling ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999963404789721	WITHOUT_CLASSIFICATION	3.6595210277794457E-6	DEFECT
// Handle collection-fiter compilation. // IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!	WITHOUT_CLASSIFICATION	0.9990453903039178	WITHOUT_CLASSIFICATION	9.54609696082168E-4	DEFECT
// Show the modified AST.	WITHOUT_CLASSIFICATION	0.9999987261111501	WITHOUT_CLASSIFICATION	1.2738888498227996E-6	DEFECT
// Create a parameter specification for the collection filter...	WITHOUT_CLASSIFICATION	0.9999952640790147	WITHOUT_CLASSIFICATION	4.735920985159164E-6	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// Get the names of the columns used to link between the collection // owner and the collection elements.	WITHOUT_CLASSIFICATION	0.999999999575596	WITHOUT_CLASSIFICATION	4.2440395095935453E-10	DEFECT
// The path AST should be a DotNode, and it should have been evaluated already.	WITHOUT_CLASSIFICATION	0.9999783433646322	WITHOUT_CLASSIFICATION	2.1656635367694788E-5	DEFECT
// Tell the dot node about the join type.	WITHOUT_CLASSIFICATION	0.9999992670339265	WITHOUT_CLASSIFICATION	7.329660734539094E-7	DEFECT
// Re-arrange the tree so that the collection function is the root and the lhs is the path.	WITHOUT_CLASSIFICATION	0.9999867547241619	WITHOUT_CLASSIFICATION	1.3245275838095047E-5	DEFECT
// Don't forget to resolve the argument! // Resolve the collection function now.	WITHOUT_CLASSIFICATION	0.9999977783649581	WITHOUT_CLASSIFICATION	2.221635041970217E-6	DEFECT
// Resolve everything up to this dot, but don't resolve the placeholders yet.	WITHOUT_CLASSIFICATION	0.999130912046123	WITHOUT_CLASSIFICATION	8.69087953877034E-4	DEFECT
// Should mean that no such property was found	WITHOUT_CLASSIFICATION	0.9999968313773542	WITHOUT_CLASSIFICATION	3.1686226458845814E-6	DEFECT
// Was there an explicit select expression?	WITHOUT_CLASSIFICATION	0.9999985230032503	WITHOUT_CLASSIFICATION	1.4769967496155689E-6	DEFECT
// Attach any mapping-defined "ORDER BY" fragments	WITHOUT_CLASSIFICATION	0.999999927313134	WITHOUT_CLASSIFICATION	7.268686595083633E-8	DEFECT
// Use the explicitly declared select expression; determine the // return types indicated by each select token	WITHOUT_CLASSIFICATION	0.999999784340196	WITHOUT_CLASSIFICATION	2.1565980391885278E-7	DEFECT
// After that, process the JOINs. // Invoke a delegate to do the work, as this is farily complex.	WITHOUT_CLASSIFICATION	0.991665209337698	WITHOUT_CLASSIFICATION	0.008334790662302083	DEFECT
// Make #@%$^#^&# sure no alias is applied to the table name	WITHOUT_CLASSIFICATION	0.9999999950449129	WITHOUT_CLASSIFICATION	4.955087147605652E-9	DEFECT
// We need to generate ids as part of this bulk insert. // // Note that this is only supported for sequence-style generators and // post-insert-style generators; basically, only in-db generators	WITHOUT_CLASSIFICATION	0.9999794542429012	WITHOUT_CLASSIFICATION	2.0545757098808973E-5	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// We need to seed the version value as part of this bulk insert	WITHOUT_CLASSIFICATION	0.9999964019795053	WITHOUT_CLASSIFICATION	3.5980204945850297E-6	DEFECT
// we need to wrtap the param in a cast()	WITHOUT_CLASSIFICATION	0.9999964733178387	WITHOUT_CLASSIFICATION	3.5266821612612826E-6	DEFECT
// This is called when it's time to fully resolve a path expression.	WITHOUT_CLASSIFICATION	0.997687719437876	WITHOUT_CLASSIFICATION	0.002312280562123945	DEFECT
// Generate implicit joins, only if necessary.	WITHOUT_CLASSIFICATION	0.9999999703431992	WITHOUT_CLASSIFICATION	2.9656800802470396E-8	DEFECT
// Notify the FROM element that it is being referenced by the select.	WITHOUT_CLASSIFICATION	0.999998106413976	WITHOUT_CLASSIFICATION	1.8935860239772371E-6	DEFECT
// Turn off includeSubclasses on all FromElements.	WITHOUT_CLASSIFICATION	0.9999968832181703	WITHOUT_CLASSIFICATION	3.1167818296289732E-6	DEFECT
// create the node initially with the param name so that it shows // appropriately in the "original text" attribute	WITHOUT_CLASSIFICATION	0.9999869803171133	WITHOUT_CLASSIFICATION	1.301968288657874E-5	DEFECT
// Use the delegate, resolve identifiers as FROM element aliases.	WITHOUT_CLASSIFICATION	0.99999999774173	WITHOUT_CLASSIFICATION	2.2582700824309633E-9	DEFECT
// select clauses for insert statements should alwasy be treated as shallow	WITHOUT_CLASSIFICATION	0.9999990613290203	WITHOUT_CLASSIFICATION	9.386709797637472E-7	DEFECT
// no need to even collect this information if the persister is considered multi-table	WITHOUT_CLASSIFICATION	0.9999999734452025	WITHOUT_CLASSIFICATION	2.655479752914648E-8	DEFECT
// Make sure that the persister is versioned	WITHOUT_CLASSIFICATION	0.9999994448418409	WITHOUT_CLASSIFICATION	5.551581590901904E-7	DEFECT
// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997355197221	WITHOUT_CLASSIFICATION	2.644802778996805E-7	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// --Commented out by Inspection (12/11/04 10:56 AM): int getWarningCount();	WITHOUT_CLASSIFICATION	0.9999943205287138	WITHOUT_CLASSIFICATION	5.679471286135285E-6	DEFECT
// Alias references and identifiers use the same node class.	WITHOUT_CLASSIFICATION	0.999999968624323	WITHOUT_CLASSIFICATION	3.1375676946748927E-8	DEFECT
// switch	WITHOUT_CLASSIFICATION	0.9999996300129426	WITHOUT_CLASSIFICATION	3.699870575241982E-7	DEFECT
// make a new one	WITHOUT_CLASSIFICATION	0.9999938427136871	WITHOUT_CLASSIFICATION	6.157286312938201E-6	DEFECT
// just do the regular thing if you can't find the ctor // Your AST must have default ctor to use this.	WITHOUT_CLASSIFICATION	0.9999999986858785	WITHOUT_CLASSIFICATION	1.3141214668206012E-9	DEFECT
// Initialize SQL nodes here.	WITHOUT_CLASSIFICATION	0.9999929937216674	WITHOUT_CLASSIFICATION	7.006278332494451E-6	DEFECT
// semantic action processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999996209882939	WITHOUT_CLASSIFICATION	3.790117061567245E-7	DEFECT
// if template is null we just write the function out as it appears in the hql statement	WITHOUT_CLASSIFICATION	0.9999998270910462	WITHOUT_CLASSIFICATION	1.729089537953184E-7	DEFECT
// this function has a template -> redirect output and catch the arguments	WITHOUT_CLASSIFICATION	0.999999975281303	WITHOUT_CLASSIFICATION	2.4718696958262862E-8	DEFECT
// --- Inner classes (moved here from sql-gen.g) ---	WITHOUT_CLASSIFICATION	0.9999814932865507	WITHOUT_CLASSIFICATION	1.8506713449235517E-5	DEFECT
// check two "adjecent" nodes at the top of the from-clause tree	WITHOUT_CLASSIFICATION	0.9999988067578844	WITHOUT_CLASSIFICATION	1.1932421156501933E-6	DEFECT
///////////////////////////////////////////////////////////////////////	WITHOUT_CLASSIFICATION	0.9999716818625526	WITHOUT_CLASSIFICATION	2.831813744743344E-5	DEFECT
// these are just two unrelated table references	WITHOUT_CLASSIFICATION	0.9999999993481754	WITHOUT_CLASSIFICATION	6.518246445549417E-10	DEFECT
// again, both should be FromElements	WITHOUT_CLASSIFICATION	0.9999998562746559	WITHOUT_CLASSIFICATION	1.4372534401504272E-7	DEFECT
// NOTE : firstRow is zero-based	WITHOUT_CLASSIFICATION	0.9999983849166201	WITHOUT_CLASSIFICATION	1.6150833799085493E-6	DEFECT
// right represents a joins originating from left; or // both right and left reprersent joins originating from the same FromElement	WITHOUT_CLASSIFICATION	0.9999996707001884	WITHOUT_CLASSIFICATION	3.292998116480674E-7	DEFECT
// check a set of parent/child nodes in the from-clause tree // to determine if a comma is required between them	WITHOUT_CLASSIFICATION	0.999999822702476	WITHOUT_CLASSIFICATION	1.7729752401090917E-7	DEFECT
// right represents a joins originating from left...	WITHOUT_CLASSIFICATION	0.9999577624522461	WITHOUT_CLASSIFICATION	4.223754775379817E-5	DEFECT
// all clear	WITHOUT_CLASSIFICATION	0.9999997840822874	WITHOUT_CLASSIFICATION	2.1591771270720345E-7	DEFECT
// Ignore the token class name parameter, and use a specific token class.	WITHOUT_CLASSIFICATION	0.9999983810367103	WITHOUT_CLASSIFICATION	1.6189632897374853E-6	DEFECT
//overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999992482724217	WITHOUT_CLASSIFICATION	7.517275783606613E-7	DEFECT
//overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999992482724217	WITHOUT_CLASSIFICATION	7.517275783606613E-7	DEFECT
// remember that ordinal parameters numbers are 1-based!!!	WITHOUT_CLASSIFICATION	0.9999966933710405	WITHOUT_CLASSIFICATION	3.3066289595565074E-6	DEFECT
// don't care about other param types here, just those explicitly user-defined...	WITHOUT_CLASSIFICATION	0.9999998531669143	WITHOUT_CLASSIFICATION	1.468330857106542E-7	DEFECT
// If the query is already compiled, skip the compilation.	WITHOUT_CLASSIFICATION	0.9999911215033772	WITHOUT_CLASSIFICATION	8.878496622892262E-6	DEFECT
// Remember the parameters for the compilation.	WITHOUT_CLASSIFICATION	0.9999291131309682	WITHOUT_CLASSIFICATION	7.08868690318298E-5	DEFECT
// PHASE 1 : Parse the HQL into an AST.	WITHOUT_CLASSIFICATION	0.9999970244619569	WITHOUT_CLASSIFICATION	2.9755380431167717E-6	DEFECT
// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.	WITHOUT_CLASSIFICATION	0.9999968887361056	WITHOUT_CLASSIFICATION	3.1112638944219637E-6	DEFECT
// PHASE 3 : Generate the SQL.	WITHOUT_CLASSIFICATION	0.9999995693875715	WITHOUT_CLASSIFICATION	4.3061242840490047E-7	DEFECT
// we do not actually propogate ANTLRExceptions as a cause, so // log it here for diagnostic purposes	WITHOUT_CLASSIFICATION	0.9998965535888736	WITHOUT_CLASSIFICATION	1.0344641112631422E-4	DEFECT
// we do not actually propogate ANTLRExceptions as a cause, so // log it here for diagnostic purposes	WITHOUT_CLASSIFICATION	0.9998965535888736	WITHOUT_CLASSIFICATION	1.0344641112631422E-4	DEFECT
//only needed during compilation phase...	WITHOUT_CLASSIFICATION	0.9999905252006066	WITHOUT_CLASSIFICATION	9.474799393324655E-6	DEFECT
// Transform the tree.	WITHOUT_CLASSIFICATION	0.9999997079158411	WITHOUT_CLASSIFICATION	2.920841589590031E-7	DEFECT
// Parse the query string into an HQL AST.	WITHOUT_CLASSIFICATION	0.999988048714126	WITHOUT_CLASSIFICATION	1.1951285873996724E-5	DEFECT
// Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9999663951285284	WITHOUT_CLASSIFICATION	3.360487147168096E-5	DEFECT
// Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9999663951285284	WITHOUT_CLASSIFICATION	3.360487147168096E-5	DEFECT
// Delegate to the QueryLoader...	WITHOUT_CLASSIFICATION	0.9999663951285284	WITHOUT_CLASSIFICATION	3.360487147168096E-5	DEFECT
// NOTE : ( max - 1 ) because first is zero-based while max is not...	WITHOUT_CLASSIFICATION	0.9999621661535728	WITHOUT_CLASSIFICATION	3.7833846427189265E-5	DEFECT
// -- Package local methods for the QueryLoader delegate --	WITHOUT_CLASSIFICATION	0.9999996031903012	WITHOUT_CLASSIFICATION	3.968096986906314E-7	DEFECT
// If there are no collection fetches, then no further checks are needed	WITHOUT_CLASSIFICATION	0.999999911991518	WITHOUT_CLASSIFICATION	8.800848200229885E-8	DEFECT
// A shallow query is ok (although technically there should be no fetching here...)	WITHOUT_CLASSIFICATION	0.7907345158312272	WITHOUT_CLASSIFICATION	0.20926548416877266	DEFECT
// should be the first, but just to be safe...	WITHOUT_CLASSIFICATION	0.999966468581708	WITHOUT_CLASSIFICATION	3.353141829193921E-5	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// Impl Note: allows multiple collection fetches as long as the // entire fecthed graph still "points back" to a single // root entity for return	WITHOUT_CLASSIFICATION	0.9999907973683748	WITHOUT_CLASSIFICATION	9.202631625228475E-6	DEFECT
// Otherwise, we have a non-scalar select with defined collection fetch(es). // Make sure that there is only a single root entity in the return (no tuples)	WITHOUT_CLASSIFICATION	0.9999999989675254	WITHOUT_CLASSIFICATION	1.0324744894746983E-9	DEFECT
// This is not strictly true.  We actually just need to make sure that // it is ordered by root-entity PK and that that order-by comes before // any non-root-entity ordering...	WITHOUT_CLASSIFICATION	0.999585807869131	WITHOUT_CLASSIFICATION	4.141921308690513E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// we are already processing a dot-structure	WITHOUT_CLASSIFICATION	0.9999999773902334	WITHOUT_CLASSIFICATION	2.2609766583377872E-8	DEFECT
// igndore it...	WITHOUT_CLASSIFICATION	0.9996516094309069	WITHOUT_CLASSIFICATION	3.483905690930589E-4	DEFECT
// we are now at a new tree level	WITHOUT_CLASSIFICATION	0.9999965959011557	WITHOUT_CLASSIFICATION	3.404098844405146E-6	DEFECT
// [jsd] The fix for HHH-558...	WITHOUT_CLASSIFICATION	0.998169052004716	WITHOUT_CLASSIFICATION	0.0018309479952839849	DEFECT
// If the token can tell us if it could be an identifier...	WITHOUT_CLASSIFICATION	0.999980408093491	WITHOUT_CLASSIFICATION	1.959190650905191E-5	DEFECT
// ... and the expected token type was an identifier, then:	WITHOUT_CLASSIFICATION	0.9999978131214917	WITHOUT_CLASSIFICATION	2.1868785083846607E-6	DEFECT
// Use the token as an identifier.	WITHOUT_CLASSIFICATION	0.9999998318403832	WITHOUT_CLASSIFICATION	1.6815961667748565E-7	DEFECT
// Add the token to the AST.	WITHOUT_CLASSIFICATION	0.9999861978205058	WITHOUT_CLASSIFICATION	1.3802179494236006E-5	DEFECT
// (NOT (EQ a b) ) => (NE a b)	WITHOUT_CLASSIFICATION	0.9999998425835236	WITHOUT_CLASSIFICATION	1.574164764223503E-7	DEFECT
// (NOT (NE a b) ) => (EQ a b)	WITHOUT_CLASSIFICATION	0.9999998425835236	WITHOUT_CLASSIFICATION	1.574164764223503E-7	DEFECT
// (NOT (LT a b) ) => (GE a b)	WITHOUT_CLASSIFICATION	0.9999998882541317	WITHOUT_CLASSIFICATION	1.117458684257495E-7	DEFECT
// (NOT (GE a b) ) => (LT a b)	WITHOUT_CLASSIFICATION	0.9999998882541317	WITHOUT_CLASSIFICATION	1.117458684257495E-7	DEFECT
// (NOT (LE a b) ) => (GT a b)	WITHOUT_CLASSIFICATION	0.9999999160269294	WITHOUT_CLASSIFICATION	8.397307058650702E-8	DEFECT
// (NOT (LIKE a b) ) => (NOT_LIKE a b)	WITHOUT_CLASSIFICATION	0.9999997487076102	WITHOUT_CLASSIFICATION	2.512923898172918E-7	DEFECT
// (NOT (NOT_LIKE a b) ) => (LIKE a b)	WITHOUT_CLASSIFICATION	0.9999997487076102	WITHOUT_CLASSIFICATION	2.512923898172918E-7	DEFECT
// (NOT (IS_NOT_NULL a b) ) => (IS_NULL a b)	WITHOUT_CLASSIFICATION	0.9999999117316799	WITHOUT_CLASSIFICATION	8.826832009736218E-8	DEFECT
// (NOT (BETWEEN a b) ) => (NOT_BETWEEN a b)	WITHOUT_CLASSIFICATION	0.9999996940988902	WITHOUT_CLASSIFICATION	3.0590110977848004E-7	DEFECT
// Initialize the error handling delegate.	WITHOUT_CLASSIFICATION	0.9999999440670514	WITHOUT_CLASSIFICATION	5.593294853997471E-8	DEFECT
//overriden to avoid System.exit	WITHOUT_CLASSIFICATION	0.9999992482724217	WITHOUT_CLASSIFICATION	7.517275783606613E-7	DEFECT
// if // if // Otherwise, handle the error normally.	WITHOUT_CLASSIFICATION	0.9999999579288901	WITHOUT_CLASSIFICATION	4.207111003930825E-8	DEFECT
// (NOT (NOT_BETWEEN a b) ) => (BETWEEN a b)	WITHOUT_CLASSIFICATION	0.9999996940988902	WITHOUT_CLASSIFICATION	3.0590110977848004E-7	DEFECT
/* This can never happen because this rule will always eliminate the child NOT.	WITHOUT_CLASSIFICATION	0.9999987122627865	WITHOUT_CLASSIFICATION	1.2877372134365648E-6	DEFECT
// Just add a 'not' parent.	WITHOUT_CLASSIFICATION	0.9999961163767016	WITHOUT_CLASSIFICATION	3.8836232984820354E-6	DEFECT
// (EQ NULL b) => (IS_NULL b)	WITHOUT_CLASSIFICATION	0.9999999685741517	WITHOUT_CLASSIFICATION	3.1425848291534934E-8	DEFECT
// (EQ a NULL) => (IS_NULL a)	WITHOUT_CLASSIFICATION	0.9999999791119428	WITHOUT_CLASSIFICATION	2.088805708812724E-8	DEFECT
// NOTE: Because we're using ASTUtil.createParent(), the tree must be created from the bottom up. // IS EMPTY x => (EXISTS (QUERY (SELECT_FROM (FROM x) ) ) )	WITHOUT_CLASSIFICATION	0.9999999988130042	WITHOUT_CLASSIFICATION	1.1869958558375021E-9	DEFECT
// Add NOT if it's negated.	WITHOUT_CLASSIFICATION	0.9999999663774625	WITHOUT_CLASSIFICATION	3.362253743096141E-8	DEFECT
// Create nodes that track line and column number.	WITHOUT_CLASSIFICATION	0.9999996364411505	WITHOUT_CLASSIFICATION	3.63558849535891E-7	DEFECT
// Case 1: Multi token keywords GROUP BY and ORDER BY // The next token ( LT(2) ) should be 'by'... otherwise, this is just an ident.	WITHOUT_CLASSIFICATION	0.9994038109860568	WITHOUT_CLASSIFICATION	5.961890139431631E-4	DEFECT
// Case 2: The current token is after FROM and before '.'.	WITHOUT_CLASSIFICATION	0.9984310787673236	WITHOUT_CLASSIFICATION	0.0015689212326763843	DEFECT
// This handles HHH-354, where there is a strange property name in a where clause. // If the lookahead contains a DOT then something that isn't an IDENT...	WITHOUT_CLASSIFICATION	0.9997353307701631	WITHOUT_CLASSIFICATION	2.6466922983690313E-4	DEFECT
// See if the second lookahed token can be an identifier.	WITHOUT_CLASSIFICATION	0.9999998078058782	WITHOUT_CLASSIFICATION	1.9219412178086863E-7	DEFECT
// Set it!	WITHOUT_CLASSIFICATION	0.9999586868464011	WITHOUT_CLASSIFICATION	4.131315359876645E-5	DEFECT
// ignore	WITHOUT_CLASSIFICATION	0.9999996022307994	WITHOUT_CLASSIFICATION	3.977692004945396E-7	DEFECT
// strip the " where "	WITHOUT_CLASSIFICATION	0.9999999714633153	WITHOUT_CLASSIFICATION	2.853668472336569E-8	DEFECT
// Don't really know all the codes required to adequately decipher returned jdbc exceptions here. // simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail	WITHOUT_CLASSIFICATION	0.8666891752301487	WITHOUT_CLASSIFICATION	0.13331082476985132	DEFECT
// at the very least cleanup the data :)	WITHOUT_CLASSIFICATION	0.999996663906492	WITHOUT_CLASSIFICATION	3.3360935078728145E-6	DEFECT
// First, save off the pertinent ids, as the return value	WITHOUT_CLASSIFICATION	0.999999959500443	WITHOUT_CLASSIFICATION	4.049955712095731E-8	DEFECT
// jdbc params are 1-based	WITHOUT_CLASSIFICATION	0.9999998597131816	WITHOUT_CLASSIFICATION	1.4028681837530107E-7	DEFECT
// jdbc params are 1-based	WITHOUT_CLASSIFICATION	0.9999998597131816	WITHOUT_CLASSIFICATION	1.4028681837530107E-7	DEFECT
// Start performing the updates	WITHOUT_CLASSIFICATION	0.9999998314570526	WITHOUT_CLASSIFICATION	1.6854294737248038E-7	DEFECT
// First, save off the pertinent ids, saving the number of pertinent ids for return	WITHOUT_CLASSIFICATION	0.9999994490003759	WITHOUT_CLASSIFICATION	5.509996242297125E-7	DEFECT
// Start performing the deletes	WITHOUT_CLASSIFICATION	0.999999975615443	WITHOUT_CLASSIFICATION	2.438455707142922E-8	DEFECT
// otherwise, everything ok.	WITHOUT_CLASSIFICATION	0.9999996186388471	WITHOUT_CLASSIFICATION	3.8136115279187286E-7	DEFECT
// visit width-first, then depth	WITHOUT_CLASSIFICATION	0.9999996814020946	WITHOUT_CLASSIFICATION	3.1859790547276035E-7	DEFECT
// if the types report logical equivalence, return true...	WITHOUT_CLASSIFICATION	0.999911954801984	WITHOUT_CLASSIFICATION	8.804519801594459E-5	DEFECT
// otherwise, perform a "deep equivalence" check...	WITHOUT_CLASSIFICATION	0.9999999676338198	WITHOUT_CLASSIFICATION	3.236618020825773E-8	DEFECT
// If there is no WHERE node, make one.	WITHOUT_CLASSIFICATION	0.999997977926198	WITHOUT_CLASSIFICATION	2.022073801824157E-6	DEFECT
// inject the WHERE after the parent	WITHOUT_CLASSIFICATION	0.9999976694424426	WITHOUT_CLASSIFICATION	2.3305575573312782E-6	DEFECT
// Never include subclasses for implied from elements.	WITHOUT_CLASSIFICATION	0.9999999895064523	WITHOUT_CLASSIFICATION	1.0493547737087378E-8	DEFECT
// Moved here from SelectClause [jsd]	WITHOUT_CLASSIFICATION	0.9999999302653103	WITHOUT_CLASSIFICATION	6.973468974746783E-8	DEFECT
///////////////////////////////////////////////////////////////////////////	WITHOUT_CLASSIFICATION	0.9999716818625526	WITHOUT_CLASSIFICATION	2.831813744743344E-5	DEFECT
// Use the table fromElement and the property name to get the array of column names.	WITHOUT_CLASSIFICATION	0.9999999616674589	WITHOUT_CLASSIFICATION	3.833254121611305E-8	DEFECT
// Set the attributes of the property reference expression.	WITHOUT_CLASSIFICATION	0.9998818304846725	WITHOUT_CLASSIFICATION	1.1816951532755769E-4	DEFECT
// If the uresolved property path isn't set yet, just use the property name.	WITHOUT_CLASSIFICATION	0.9999962313147116	WITHOUT_CLASSIFICATION	3.7686852883412166E-6	DEFECT
// The 'from element' that the property is in.	WITHOUT_CLASSIFICATION	0.9999924007442413	WITHOUT_CLASSIFICATION	7.5992557586527745E-6	DEFECT
// Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999998051382791	WITHOUT_CLASSIFICATION	1.9486172083603312E-7	DEFECT
// Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999998051382791	WITHOUT_CLASSIFICATION	1.9486172083603312E-7	DEFECT
// If this dot has already been resolved, stop now.	WITHOUT_CLASSIFICATION	0.999997477178922	WITHOUT_CLASSIFICATION	2.5228210781177196E-6	DEFECT
// If there is no data type for this node, and we're at the end of the path (top most dot node), then // this might be a Java constant.	WITHOUT_CLASSIFICATION	0.9996488231157761	WITHOUT_CLASSIFICATION	3.511768842239129E-4	DEFECT
// The property is a collection...	WITHOUT_CLASSIFICATION	0.998019189340726	WITHOUT_CLASSIFICATION	0.001980810659273971	DEFECT
// The property is a component...	WITHOUT_CLASSIFICATION	0.9986625590066177	WITHOUT_CLASSIFICATION	0.001337440993382319	DEFECT
// The property is another class..	WITHOUT_CLASSIFICATION	0.9998819713253156	WITHOUT_CLASSIFICATION	1.1802867468442668E-4	DEFECT
// Otherwise, this is a primitive type.	WITHOUT_CLASSIFICATION	0.9999958299062344	WITHOUT_CLASSIFICATION	4.1700937657066705E-6	DEFECT
//foo.bars.size (also handles deprecated stuff like foo.bars.maxelement for backwardness)	WITHOUT_CLASSIFICATION	0.9999999268038776	WITHOUT_CLASSIFICATION	7.319612241830405E-8	DEFECT
// This 'dot' expression now refers to the resulting from element.	WITHOUT_CLASSIFICATION	0.9999941612885277	WITHOUT_CLASSIFICATION	5.838711472318263E-6	DEFECT
// Always add the collection's query spaces.	WITHOUT_CLASSIFICATION	0.9999922485209123	WITHOUT_CLASSIFICATION	7.751479087617452E-6	DEFECT
// in non-select queries, the only time we should need to join is if we are in a subquery from clause	WITHOUT_CLASSIFICATION	0.9999993915359308	WITHOUT_CLASSIFICATION	6.084640692842882E-7	DEFECT
// this is the regression style determination which matches the logic of the classic translator	WITHOUT_CLASSIFICATION	0.9999991797944462	WITHOUT_CLASSIFICATION	8.202055538817054E-7	DEFECT
// This 'dot' expression now refers to the resulting from element.	WITHOUT_CLASSIFICATION	0.9999941612885277	WITHOUT_CLASSIFICATION	5.838711472318263E-6	DEFECT
// even though we might find a pre-existing element by join path, we may not be able to reuse it...	WITHOUT_CLASSIFICATION	0.9999634113015672	WITHOUT_CLASSIFICATION	3.658869843280015E-5	DEFECT
// NOTE : addDuplicateAlias() already performs nullness checks on the alias.	WITHOUT_CLASSIFICATION	0.9999998117179041	WITHOUT_CLASSIFICATION	1.8828209583382208E-7	DEFECT
// if the from-clauses are the same, we can be a little more aggressive in terms of what we reuse	WITHOUT_CLASSIFICATION	0.9999995099385928	WITHOUT_CLASSIFICATION	4.900614072041707E-7	DEFECT
// again, null != null here	WITHOUT_CLASSIFICATION	0.9999957034865278	WITHOUT_CLASSIFICATION	4.296513472159858E-6	DEFECT
// If this is an implied join in a from element, then use the impled join type which is part of the // tree parser's state (set by the gramamar actions).	WITHOUT_CLASSIFICATION	0.9999996428306855	WITHOUT_CLASSIFICATION	3.571693145251593E-7	DEFECT
// otherwise (subquery case) dont reuse the fromElement if we are processing the from-clause of the subquery	WITHOUT_CLASSIFICATION	0.9999999480918037	WITHOUT_CLASSIFICATION	5.190819621513462E-8	DEFECT
// we know only the lhs-hand type, so use that	WITHOUT_CLASSIFICATION	0.999999993284204	WITHOUT_CLASSIFICATION	6.715796081090464E-9	DEFECT
// the referenced node text is the special 'id'	WITHOUT_CLASSIFICATION	0.999999757868919	WITHOUT_CLASSIFICATION	2.4213108097690614E-7	DEFECT
// only the identifier property field name can be a reference to the associated entity's PK...	WITHOUT_CLASSIFICATION	0.9999996232417244	WITHOUT_CLASSIFICATION	3.767582756111309E-7	DEFECT
// special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expression	WITHOUT_CLASSIFICATION	0.9999510455945925	WITHOUT_CLASSIFICATION	4.895440540741533E-5	DEFECT
// Append the new property name onto the unresolved path.	WITHOUT_CLASSIFICATION	0.9999065439301936	WITHOUT_CLASSIFICATION	9.34560698063786E-5	DEFECT
// If the lhs is a collection, use CollectionPropertyMapping	WITHOUT_CLASSIFICATION	0.9999941851905602	WITHOUT_CLASSIFICATION	5.814809439723733E-6	DEFECT
// Tell the destination fromElement to 'includeSubclasses'.	WITHOUT_CLASSIFICATION	0.9999999560834765	WITHOUT_CLASSIFICATION	4.391652350684148E-8	DEFECT
// Use theta style (for regression) // Move the node up, after the origin node.	WITHOUT_CLASSIFICATION	0.9999990761140906	WITHOUT_CLASSIFICATION	9.238859094398359E-7	DEFECT
// Don't resolve the node again.	WITHOUT_CLASSIFICATION	0.9999831235494523	WITHOUT_CLASSIFICATION	1.687645054764766E-5	DEFECT
// for expected parameter type injection, we expect that the lhs represents // some form of property ref and that the children of the in-list represent // one-or-more params.	WITHOUT_CLASSIFICATION	0.9999999915105129	WITHOUT_CLASSIFICATION	8.489487159122123E-9	DEFECT
// we need to strip off the embedded parens so that sql-gen does not double these up	WITHOUT_CLASSIFICATION	0.9999999777339733	WITHOUT_CLASSIFICATION	2.226602667554103E-8	DEFECT
// we have something like : "? [op] rhs"	WITHOUT_CLASSIFICATION	0.9999827937856723	WITHOUT_CLASSIFICATION	1.7206214327607028E-5	DEFECT
// we have something like : "lhs [op] ?"	WITHOUT_CLASSIFICATION	0.9999418983623546	WITHOUT_CLASSIFICATION	5.810163764550557E-5	DEFECT
// we know only the rhs-hand type, so use that	WITHOUT_CLASSIFICATION	0.9999999967025418	WITHOUT_CLASSIFICATION	3.2974581795585813E-9	DEFECT
// handle the (assumed) valid cases: // #1 - the only valid datetime addition synatx is one or the other is a datetime (but not both)	WITHOUT_CLASSIFICATION	0.9999972958244747	WITHOUT_CLASSIFICATION	2.704175525379926E-6	DEFECT
// one or the other needs to be a datetime for us to get into this method in the first place...	WITHOUT_CLASSIFICATION	0.9999976104259402	WITHOUT_CLASSIFICATION	2.3895740597737112E-6	DEFECT
// #3 - note that this is also true of "datetime - :param"...	WITHOUT_CLASSIFICATION	0.9983831965920966	WITHOUT_CLASSIFICATION	0.0016168034079033302	DEFECT
// #2	WITHOUT_CLASSIFICATION	0.9999902262518406	WITHOUT_CLASSIFICATION	9.773748159305336E-6	DEFECT
// Generate the inner join -- The elements need to be joined to the collection they are in.	WITHOUT_CLASSIFICATION	0.9999999969581389	WITHOUT_CLASSIFICATION	3.0418611793837053E-9	DEFECT
// nothing to do	WITHOUT_CLASSIFICATION	0.9999959201644073	WITHOUT_CLASSIFICATION	4.079835592713896E-6	DEFECT
// The 'from element' that represents the elements of the collection.	WITHOUT_CLASSIFICATION	0.999999291189503	WITHOUT_CLASSIFICATION	7.088104968530311E-7	DEFECT
// Add the condition to the join sequence that qualifies the indexed element.	WITHOUT_CLASSIFICATION	0.9999999167245657	WITHOUT_CLASSIFICATION	8.327543427758773E-8	DEFECT
// Sometimes use the element table alias, sometimes use the... umm... collection table alias (many to many)	WITHOUT_CLASSIFICATION	0.999999905420816	WITHOUT_CLASSIFICATION	9.457918400016364E-8	DEFECT
// Now, set the text for this node.  It should be the element columns.	WITHOUT_CLASSIFICATION	0.9999999189320066	WITHOUT_CLASSIFICATION	8.106799349345201E-8	DEFECT
// Get the function return value type, based on the type of the first argument.	WITHOUT_CLASSIFICATION	0.9999999766959111	WITHOUT_CLASSIFICATION	2.330408894135771E-8	DEFECT
// This will call initialize(tok)!	WITHOUT_CLASSIFICATION	0.999957475064328	WITHOUT_CLASSIFICATION	4.252493567200808E-5	DEFECT
// mutation depends on the types of nodes invloved...	WITHOUT_CLASSIFICATION	0.9995266764317869	WITHOUT_CLASSIFICATION	4.7332356821308216E-4	DEFECT
// "pass along" our initial embedded parameter node(s) to the first generated // sql fragment so that it can be handled later for parameter binding...	WITHOUT_CLASSIFICATION	0.9999999893224727	WITHOUT_CLASSIFICATION	1.0677527281267608E-8	DEFECT
// logic operators by definition resolve to booleans	WITHOUT_CLASSIFICATION	0.9999996482902985	WITHOUT_CLASSIFICATION	3.5170970149437866E-7	DEFECT
// Generated select expressions are already resolved, nothing to do.	WITHOUT_CLASSIFICATION	0.9999991596075819	WITHOUT_CLASSIFICATION	8.403924180106631E-7	DEFECT
// The path may be a reference to an alias defined in the parent query.	WITHOUT_CLASSIFICATION	0.9999999017033341	WITHOUT_CLASSIFICATION	9.829666587919166E-8	DEFECT
// The HQL class alias refers to the class name.	WITHOUT_CLASSIFICATION	0.999999638401379	WITHOUT_CLASSIFICATION	3.615986210303281E-7	DEFECT
// Associate the table alias with the element.	WITHOUT_CLASSIFICATION	0.9999999892366888	WITHOUT_CLASSIFICATION	1.07633113647099E-8	DEFECT
// try the parent FromClause...	WITHOUT_CLASSIFICATION	0.9999229859806912	WITHOUT_CLASSIFICATION	7.701401930880357E-5	DEFECT
// Add the new node to the map so that we don't create it twice.	WITHOUT_CLASSIFICATION	0.9999999619263272	WITHOUT_CLASSIFICATION	3.8073672749330326E-8	DEFECT
// Make sure that all from elements registered with this FROM clause are actually in the AST.	WITHOUT_CLASSIFICATION	0.999998737063543	WITHOUT_CLASSIFICATION	1.2629364569791372E-6	DEFECT
// Invoke setScalarColumnText on each constructor argument.	WITHOUT_CLASSIFICATION	0.9999999611374192	WITHOUT_CLASSIFICATION	3.8862580730907933E-8	DEFECT
// Collect the select expressions, skip the first child because it is the class name.	WITHOUT_CLASSIFICATION	0.9999999894068393	WITHOUT_CLASSIFICATION	1.0593160645403212E-8	DEFECT
// return an empty Type array	WITHOUT_CLASSIFICATION	0.9999998997361098	WITHOUT_CLASSIFICATION	1.0026389027390053E-7	DEFECT
// Constructors are always considered scalar results.	WITHOUT_CLASSIFICATION	0.9999996293979415	WITHOUT_CLASSIFICATION	3.7060205852141765E-7	DEFECT
// this is the exception returned by ReflectHelper.getConstructor() if it cannot // locate an appropriate constructor	WITHOUT_CLASSIFICATION	0.9999956417825283	WITHOUT_CLASSIFICATION	4.358217471670533E-6	DEFECT
// if there is no order by, make one	WITHOUT_CLASSIFICATION	0.9999999656582071	WITHOUT_CLASSIFICATION	3.4341792943767145E-8	DEFECT
// Find the WHERE; if there is no WHERE, find the FROM...	WITHOUT_CLASSIFICATION	0.9999968767901086	WITHOUT_CLASSIFICATION	3.123209891367354E-6	DEFECT
// Now, inject the newly built ORDER BY into the tree	WITHOUT_CLASSIFICATION	0.9999938258767699	WITHOUT_CLASSIFICATION	6.174123230045818E-6	DEFECT
// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994756821815	WITHOUT_CLASSIFICATION	5.243178184638496E-7	DEFECT
// logic operators by definition resolve to boolean.	WITHOUT_CLASSIFICATION	0.9999993832186231	WITHOUT_CLASSIFICATION	6.16781376757726E-7	DEFECT
// Render the identifier select fragment using the table alias.	WITHOUT_CLASSIFICATION	0.9999999976290443	WITHOUT_CLASSIFICATION	2.370955689352801E-9	DEFECT
// Class names in the FROM clause result in a JoinSequence (the old FromParser does this).	WITHOUT_CLASSIFICATION	0.9998362907532145	WITHOUT_CLASSIFICATION	1.6370924678553935E-4	DEFECT
// For many-to-many joins, use the tablename from the queryable collection for the default text.	WITHOUT_CLASSIFICATION	0.9999999872919203	WITHOUT_CLASSIFICATION	1.2708079712810162E-8	DEFECT
// Otherwise, use the property mapping.	WITHOUT_CLASSIFICATION	0.999999013223404	WITHOUT_CLASSIFICATION	9.867765959231617E-7	DEFECT
// should be safe to only ever expect EntityPersister references here	WITHOUT_CLASSIFICATION	0.9999370729412621	WITHOUT_CLASSIFICATION	6.292705873796565E-5	DEFECT
// If the property is a special collection property name, return a CollectionPropertyMapping.	WITHOUT_CLASSIFICATION	0.9999854699592892	WITHOUT_CLASSIFICATION	1.4530040710839898E-5	DEFECT
// Collection of components.	WITHOUT_CLASSIFICATION	0.9999999604788932	WITHOUT_CLASSIFICATION	3.952110685219041E-8	DEFECT
// make sure the lhs is "assignable"...	WITHOUT_CLASSIFICATION	0.999979079118083	WITHOUT_CLASSIFICATION	2.092088191700813E-5	DEFECT
// false indicates to not generate parens around the assignment	WITHOUT_CLASSIFICATION	0.999998600659068	WITHOUT_CLASSIFICATION	1.39934093199642E-6	DEFECT
// Register the FromElement with the FROM clause, now that we have the names and aliases.	WITHOUT_CLASSIFICATION	0.9999991169325272	WITHOUT_CLASSIFICATION	8.830674727699161E-7	DEFECT
// currently allowed...	WITHOUT_CLASSIFICATION	0.9991125419474653	WITHOUT_CLASSIFICATION	8.874580525346648E-4	DEFECT
// HHH-276 : implied joins in a subselect where clause - The destination needs to be added // to the destination's from clause. // Not sure if this is will fix everything, but it works.	WITHOUT_CLASSIFICATION	0.9756931073698156	DEFECT	0.024306892630184405	WITHOUT_CLASSIFICATION
//return classAlias == null ? className : classAlias;	WITHOUT_CLASSIFICATION	0.9999519576838213	WITHOUT_CLASSIFICATION	4.804231617865579E-5	DEFECT
// This is an explicit FROM element.	WITHOUT_CLASSIFICATION	0.9999963379202716	WITHOUT_CLASSIFICATION	3.6620797283784634E-6	DEFECT
// ParameterContainer impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994756821815	WITHOUT_CLASSIFICATION	5.243178184638496E-7	DEFECT
// Fetch can't be used with scroll() or iterate().	WITHOUT_CLASSIFICATION	0.9999971106447868	WITHOUT_CLASSIFICATION	2.889355213204152E-6	DEFECT
// If it's not implied or it is implied and it's a many to many join where the target wasn't found.	WITHOUT_CLASSIFICATION	0.9999889056861305	WITHOUT_CLASSIFICATION	1.1094313869490957E-5	DEFECT
// Since this is an explicit FROM element, it can't be implied in the FROM clause.	WITHOUT_CLASSIFICATION	0.9999995269219547	WITHOUT_CLASSIFICATION	4.7307804542521435E-7	DEFECT
// Do nothing, eplicit from elements are *always* in the projection list.	WITHOUT_CLASSIFICATION	0.9999999330805011	WITHOUT_CLASSIFICATION	6.691949892797455E-8	DEFECT
// propertyName refers to something like collection.size...	WITHOUT_CLASSIFICATION	0.999807834842136	WITHOUT_CLASSIFICATION	1.9216515786402537E-4	DEFECT
// property name is a sub-path of a component...	WITHOUT_CLASSIFICATION	0.9999287077344431	WITHOUT_CLASSIFICATION	7.129226555684391E-5	DEFECT
// Always add the collection's query spaces.	WITHOUT_CLASSIFICATION	0.9999922485209123	WITHOUT_CLASSIFICATION	7.751479087617452E-6	DEFECT
// nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type here	WITHOUT_CLASSIFICATION	0.9999996799488625	WITHOUT_CLASSIFICATION	3.200511375641493E-7	DEFECT
// logic operators by definition resolve to booleans	WITHOUT_CLASSIFICATION	0.9999996482902985	WITHOUT_CLASSIFICATION	3.5170970149437866E-7	DEFECT
// DotNode uses null here...	WITHOUT_CLASSIFICATION	0.9893755692194813	WITHOUT_CLASSIFICATION	0.01062443078051867	DEFECT
// We represent a from-clause alias	WITHOUT_CLASSIFICATION	0.9999997659337312	WITHOUT_CLASSIFICATION	2.3406626872448487E-7	DEFECT
// we are the LHS of the DOT representing a naked comp-prop-ref	WITHOUT_CLASSIFICATION	0.9999999801338284	WITHOUT_CLASSIFICATION	1.9866171573568538E-8	DEFECT
// we are the RHS of the DOT representing a naked comp-prop-ref	WITHOUT_CLASSIFICATION	0.9999999804836847	WITHOUT_CLASSIFICATION	1.951631533332856E-8	DEFECT
// we represent a naked (simple) prop-ref	WITHOUT_CLASSIFICATION	0.9999995177254298	WITHOUT_CLASSIFICATION	4.822745702666308E-7	DEFECT
// EARLY EXIT!!!  return so the resolve call explicitly coming from DotNode can // resolve this...	WITHOUT_CLASSIFICATION	0.9997138139086008	WITHOUT_CLASSIFICATION	2.8618609139927054E-4	DEFECT
// assume this ident's text does *not* refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.999999648773875	WITHOUT_CLASSIFICATION	3.5122612487211113E-7	DEFECT
// just ignore it for now, it'll get resolved later...	WITHOUT_CLASSIFICATION	0.9999965239522267	WITHOUT_CLASSIFICATION	3.4760477731631612E-6	DEFECT
// This is not actually a constant, but a reference to FROM element.	WITHOUT_CLASSIFICATION	0.9847771825568579	WITHOUT_CLASSIFICATION	0.015222817443142106	DEFECT
// check to see if our "propPath" actually // represents a property on the persister	WITHOUT_CLASSIFICATION	0.9999992819840429	WITHOUT_CLASSIFICATION	7.18015957052384E-7	DEFECT
// these pieces are needed for usage in select clause	WITHOUT_CLASSIFICATION	0.9999998571735209	WITHOUT_CLASSIFICATION	1.428264789637591E-7	DEFECT
// used to set the type of the parent dot node	WITHOUT_CLASSIFICATION	0.9999998923590262	WITHOUT_CLASSIFICATION	1.076409737841992E-7	DEFECT
// assume we do *not* refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.9999998768405006	WITHOUT_CLASSIFICATION	1.2315949924974248E-7	DEFECT
// assume we do *not* refer to a property on the given persister	WITHOUT_CLASSIFICATION	0.9999998768405006	WITHOUT_CLASSIFICATION	1.2315949924974248E-7	DEFECT
// naked property-refs cannot be used with an aliased from element	WITHOUT_CLASSIFICATION	0.999999960136111	WITHOUT_CLASSIFICATION	3.9863888926436327E-8	DEFECT
// this piece is needed for usage in select clause	WITHOUT_CLASSIFICATION	0.9999999056984293	WITHOUT_CLASSIFICATION	9.430157071859097E-8	DEFECT
// do *not* over-write the column text, as that has already been // "rendered" during resolve	WITHOUT_CLASSIFICATION	0.9999999494029377	WITHOUT_CLASSIFICATION	5.059706223172696E-8	DEFECT
// for some reason the antlr.CommonAST initialization routines force // this method to get called twice.  The first time with an empty string	WITHOUT_CLASSIFICATION	0.9999999995269584	WITHOUT_CLASSIFICATION	4.730416362942895E-10	DEFECT
// Look up class name using the first identifier in the path.	WITHOUT_CLASSIFICATION	0.9999999262696918	WITHOUT_CLASSIFICATION	7.373030814954357E-8	DEFECT
// Add to the query spaces.	WITHOUT_CLASSIFICATION	0.9999994321548764	WITHOUT_CLASSIFICATION	5.678451236063845E-7	DEFECT
// If the from element isn't in the same clause, create a new from element.	WITHOUT_CLASSIFICATION	0.999979842191395	WITHOUT_CLASSIFICATION	2.0157808604917697E-5	DEFECT
// This is the root level node. // Generate an explicit from clause at the root.	WITHOUT_CLASSIFICATION	0.9999979417262398	WITHOUT_CLASSIFICATION	2.0582737602683205E-6	DEFECT
// Correlated subqueries create 'special' implied from nodes // because correlated subselects can't use an ANSI-style join	WITHOUT_CLASSIFICATION	0.999999876929517	WITHOUT_CLASSIFICATION	1.2307048300743275E-7	DEFECT
// super-duper-classic-parser-regression-testing-mojo-magic...	WITHOUT_CLASSIFICATION	0.9999958043186772	WITHOUT_CLASSIFICATION	4.1956813228289235E-6	DEFECT
// A collection of entities...	WITHOUT_CLASSIFICATION	0.9999207424003616	WITHOUT_CLASSIFICATION	7.925759963836688E-5	DEFECT
// A collection of components...	WITHOUT_CLASSIFICATION	0.9999927434903341	WITHOUT_CLASSIFICATION	7.256509665910601E-6	DEFECT
// A collection of scalar elements...	WITHOUT_CLASSIFICATION	0.9999926389467977	WITHOUT_CLASSIFICATION	7.36105320236475E-6	DEFECT
// according to both the ANSI-SQL and EJB3 specs, trim can either take // exactly one parameter or a variable number of parameters between 1 and 4. // from the SQL spec: // // <trim function> ::= //      TRIM <left paren> <trim operands> <right paren> // // <trim operands> ::= //      [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> // // <trim specification> ::= //      LEADING //      | TRAILING //      | BOTH // // If only <trim specification> is omitted, BOTH is assumed; // if <trim character> is omitted, space is assumed	WITHOUT_CLASSIFICATION	0.999999941213018	WITHOUT_CLASSIFICATION	5.8786981996506283E-8	DEFECT
// Don't include sub-classes for implied collection joins or subquery joins.	WITHOUT_CLASSIFICATION	0.9997598898883256	WITHOUT_CLASSIFICATION	2.4011011167428793E-4	DEFECT
// Treat explict from elements in sub-queries properly.	WITHOUT_CLASSIFICATION	0.9999848596198749	WITHOUT_CLASSIFICATION	1.5140380125140417E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// the "root from-element" in correlated subqueries do need this piece	WITHOUT_CLASSIFICATION	0.9999972377943367	WITHOUT_CLASSIFICATION	2.7622056632585618E-6	DEFECT
// Create the FROM element for the target (the elements of the collection).	WITHOUT_CLASSIFICATION	0.9999999994484263	WITHOUT_CLASSIFICATION	5.515736343011971E-10	DEFECT
// If the join is implied, then don't include sub-classes on the element.	WITHOUT_CLASSIFICATION	0.9999824562442392	WITHOUT_CLASSIFICATION	1.7543755760804712E-5	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// The associated entity is implied, but it must be included in the FROM. // The collection alias is the role.	WITHOUT_CLASSIFICATION	0.9999998110802156	WITHOUT_CLASSIFICATION	1.889197843973821E-7	DEFECT
// Tag this node as a JOIN. // Don't include subclasses in the join. // This is a clollection join.	WITHOUT_CLASSIFICATION	0.9990322196927668	WITHOUT_CLASSIFICATION	9.677803072330651E-4	DEFECT
// Get the class name of the associated entity.	WITHOUT_CLASSIFICATION	0.9999999821442175	WITHOUT_CLASSIFICATION	1.7855782556416106E-8	DEFECT
//  origin, path, implied, columns, classAlias,	WITHOUT_CLASSIFICATION	0.9999979222415781	WITHOUT_CLASSIFICATION	2.077758421843093E-6	DEFECT
/*implied*/	WITHOUT_CLASSIFICATION	0.9999860886927461	WITHOUT_CLASSIFICATION	1.3911307253891955E-5	DEFECT
// For implied many-to-many, just add the end join.	WITHOUT_CLASSIFICATION	0.9999999353094916	WITHOUT_CLASSIFICATION	6.469050838304124E-8	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999994645454711	WITHOUT_CLASSIFICATION	5.354545289618775E-7	DEFECT
// the standard SQL function name is current_timestamp...	WITHOUT_CLASSIFICATION	0.9997720547702388	WITHOUT_CLASSIFICATION	2.2794522976114716E-4	DEFECT
// This causes the factory to instantiate the desired class.	WITHOUT_CLASSIFICATION	0.9999960212766017	WITHOUT_CLASSIFICATION	3.97872339830246E-6	DEFECT
//private Type[] sqlResultTypes;	WITHOUT_CLASSIFICATION	0.9999976768798899	WITHOUT_CLASSIFICATION	2.3231201100564867E-6	DEFECT
// Frontbase has no known variation of a "SELECT ... FOR UPDATE" syntax...	WITHOUT_CLASSIFICATION	0.9999221794802218	WITHOUT_CLASSIFICATION	7.782051977819917E-5	DEFECT
/*	WITHOUT_CLASSIFICATION	0.9935009427489204	WITHOUT_CLASSIFICATION	0.006499057251079584	DEFECT
/*public Type[] getSqlResultTypes() {	WITHOUT_CLASSIFICATION	0.9998991973407697	WITHOUT_CLASSIFICATION	1.0080265923028828E-4	DEFECT
// First, collect all of the select expressions. // NOTE: This must be done *before* invoking setScalarColumnText() because setScalarColumnText() // changes the AST!!!	WITHOUT_CLASSIFICATION	0.9999998672226893	WITHOUT_CLASSIFICATION	1.3277731068247209E-7	DEFECT
// First allow the actual type to control the return value. (the actual underlying sqltype could actually be different)	WITHOUT_CLASSIFICATION	0.9999916853615374	WITHOUT_CLASSIFICATION	8.314638462722102E-6	DEFECT
//sqlResultTypeList.addAll( constructorArgumentTypeList );	WITHOUT_CLASSIFICATION	0.9999998273369799	WITHOUT_CLASSIFICATION	1.7266302006100205E-7	DEFECT
// If the data type is not an association type, it could not have been in the FROM clause.	WITHOUT_CLASSIFICATION	0.9999989733747069	WITHOUT_CLASSIFICATION	1.0266252930785718E-6	DEFECT
//sqlResultTypeList.add( type );	WITHOUT_CLASSIFICATION	0.9999946024643732	WITHOUT_CLASSIFICATION	5.397535626751382E-6	DEFECT
// Always add the type to the return type list.	WITHOUT_CLASSIFICATION	0.9999977094982755	WITHOUT_CLASSIFICATION	2.2905017244648934E-6	DEFECT
// add the fetched entities	WITHOUT_CLASSIFICATION	0.9999999270813633	WITHOUT_CLASSIFICATION	7.291863670681836E-8	DEFECT
// Get ready to start adding nodes.	WITHOUT_CLASSIFICATION	0.9999996425880165	WITHOUT_CLASSIFICATION	3.5741198345878837E-7	DEFECT
// function support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999979730567448	WITHOUT_CLASSIFICATION	2.0269432552325863E-6	DEFECT
// If there are any scalars (non-entities) selected, render the select column aliases.	WITHOUT_CLASSIFICATION	0.9999999393192424	WITHOUT_CLASSIFICATION	6.068075766335473E-8	DEFECT
/*sqlResultTypeList,*/	WITHOUT_CLASSIFICATION	0.9999431794855694	WITHOUT_CLASSIFICATION	5.68205144305439E-5	DEFECT
/*ArrayList sqlResultTypeList,*/	WITHOUT_CLASSIFICATION	0.9999860260764682	WITHOUT_CLASSIFICATION	1.3973923531701697E-5	DEFECT
//sqlResultTypes = ( Type[] ) sqlResultTypeList.toArray( new Type[sqlResultTypeList.size()] );	WITHOUT_CLASSIFICATION	0.9999994921835882	WITHOUT_CLASSIFICATION	5.078164118200012E-7	DEFECT
// lock acquisition support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999842011315511	WITHOUT_CLASSIFICATION	1.579886844897213E-5	DEFECT
//TODO:	WITHOUT_CLASSIFICATION	0.9983687723364106	WITHOUT_CLASSIFICATION	0.0016312276635892652	DEFECT
// Add the type to the list of returned sqlResultTypes.	WITHOUT_CLASSIFICATION	0.9999999527720561	WITHOUT_CLASSIFICATION	4.7227943992324075E-8	DEFECT
// Generate an 2d array of column names, the first dimension is parallel with the // return types array.  The second dimension is the list of column names for each // type.	WITHOUT_CLASSIFICATION	0.9999998639539155	WITHOUT_CLASSIFICATION	1.3604608453760645E-7	DEFECT
// Generate the select expression.	WITHOUT_CLASSIFICATION	0.9999995587670903	WITHOUT_CLASSIFICATION	4.412329097081709E-7	DEFECT
// union subclass support ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999892056752958	WITHOUT_CLASSIFICATION	1.0794324704259347E-5	DEFECT
// Skip 'DISTINCT' and 'ALL', so we return the first expression node.	WITHOUT_CLASSIFICATION	0.9999999959397665	WITHOUT_CLASSIFICATION	4.060233492780408E-9	DEFECT
// Create SQL_TOKEN nodes for the columns.	WITHOUT_CLASSIFICATION	0.9999998924648285	WITHOUT_CLASSIFICATION	1.0753517150843693E-7	DEFECT
// Generate the property select tokens.	WITHOUT_CLASSIFICATION	0.9999992138215027	WITHOUT_CLASSIFICATION	7.861784971847436E-7	DEFECT
// Get the function name node.	WITHOUT_CLASSIFICATION	0.9999997572537116	WITHOUT_CLASSIFICATION	2.4274628846045474E-7	DEFECT
// Method expressions in a SELECT should always be considered scalar.	WITHOUT_CLASSIFICATION	0.9999280656308576	WITHOUT_CLASSIFICATION	7.193436914240225E-5	DEFECT
// If this is 'elements' then create a new FROM element.	WITHOUT_CLASSIFICATION	0.9999962206157019	WITHOUT_CLASSIFICATION	3.7793842981348025E-6	DEFECT
// Not elements(x)	WITHOUT_CLASSIFICATION	0.9999998918601435	WITHOUT_CLASSIFICATION	1.0813985649333796E-7	DEFECT
// Dialect function	WITHOUT_CLASSIFICATION	0.9999977333445783	WITHOUT_CLASSIFICATION	2.266655421729798E-6	DEFECT
// Collection 'property function'	WITHOUT_CLASSIFICATION	0.9999752761772496	WITHOUT_CLASSIFICATION	2.4723822750434615E-5	DEFECT
// If the constant is an IDENT, figure out what it means...	WITHOUT_CLASSIFICATION	0.9999667237235981	WITHOUT_CLASSIFICATION	3.3276276401816824E-5	DEFECT
// IDENT is a class alias in the FROM.	WITHOUT_CLASSIFICATION	0.999996196851531	WITHOUT_CLASSIFICATION	3.803148469084947E-6	DEFECT
// Resolve to an identity column.	WITHOUT_CLASSIFICATION	0.9999978757662478	WITHOUT_CLASSIFICATION	2.12423375233821E-6	DEFECT
// Otherwise, it's a literal.	WITHOUT_CLASSIFICATION	0.9999999974295826	WITHOUT_CLASSIFICATION	2.570417360365066E-9	DEFECT
// the name of an entity class	WITHOUT_CLASSIFICATION	0.9999980193994961	WITHOUT_CLASSIFICATION	1.9806005038974165E-6	DEFECT
//the class discriminator value	WITHOUT_CLASSIFICATION	0.9999961426552175	WITHOUT_CLASSIFICATION	3.857344782424621E-6	DEFECT
// Chop off the rest of the tree.	WITHOUT_CLASSIFICATION	0.9999998273483314	WITHOUT_CLASSIFICATION	1.7265166866209452E-7	DEFECT
// Add a space before the display text.	WITHOUT_CLASSIFICATION	0.9999996999444363	WITHOUT_CLASSIFICATION	3.0005556375221174E-7	DEFECT
// Find or create the WHERE clause	WITHOUT_CLASSIFICATION	0.9999998950460117	WITHOUT_CLASSIFICATION	1.0495398827156141E-7	DEFECT
// child == parent.getFirstChild()	WITHOUT_CLASSIFICATION	0.999999917524379	WITHOUT_CLASSIFICATION	8.247562102076524E-8	DEFECT
// Find or create the WHERE clause	WITHOUT_CLASSIFICATION	0.9999998950460117	WITHOUT_CLASSIFICATION	1.0495398827156141E-7	DEFECT
// Filter conditions need to be inserted before the HQL where condition and the // theta join node.  This is because org.hibernate.loader.Loader binds the filter parameters first, // then it binds all the HQL query parameters, see org.hibernate.loader.Loader.processFilterParameters().	WITHOUT_CLASSIFICATION	0.9999896726099486	WITHOUT_CLASSIFICATION	1.0327390051395885E-5	DEFECT
// Put the FILTERS node before the HQL condition and theta joins	WITHOUT_CLASSIFICATION	0.9999991521657016	WITHOUT_CLASSIFICATION	8.478342984983825E-7	DEFECT
// add the current fragment to the FILTERS node	WITHOUT_CLASSIFICATION	0.9999982288410122	WITHOUT_CLASSIFICATION	1.7711589877616733E-6	DEFECT
// Create a new THETA_JOINS node as a parent of all filters	WITHOUT_CLASSIFICATION	0.9999999363131672	WITHOUT_CLASSIFICATION	6.36868327935649E-8	DEFECT
// Put the THETA_JOINS node before the HQL condition, after the filters.	WITHOUT_CLASSIFICATION	0.9999994143118396	WITHOUT_CLASSIFICATION	5.85688160405534E-7	DEFECT
// add the current fragment to the THETA_JOINS node	WITHOUT_CLASSIFICATION	0.9999997398416075	WITHOUT_CLASSIFICATION	2.601583924536693E-7	DEFECT
// First, try to get the persister using the given name directly.	WITHOUT_CLASSIFICATION	0.9999975069676119	WITHOUT_CLASSIFICATION	2.493032388019004E-6	DEFECT
// unable to locate it using this name	WITHOUT_CLASSIFICATION	0.9999999088140059	WITHOUT_CLASSIFICATION	9.118599418715686E-8	DEFECT
// If that didn't work, try using the 'import' name.	WITHOUT_CLASSIFICATION	0.9996183071694443	WITHOUT_CLASSIFICATION	3.816928305556455E-4	DEFECT
// Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)	WITHOUT_CLASSIFICATION	0.9999998470015101	WITHOUT_CLASSIFICATION	1.5299848996735123E-7	DEFECT
// locate the registered function by the given name	WITHOUT_CLASSIFICATION	0.9999998526023437	WITHOUT_CLASSIFICATION	1.4739765633721795E-7	DEFECT
// determine the type of the first argument...	WITHOUT_CLASSIFICATION	0.999997476043224	WITHOUT_CLASSIFICATION	2.5239567761345357E-6	DEFECT
// Use the DOT node to emit the first column name. // Create the column names, folled by the column aliases.	WITHOUT_CLASSIFICATION	0.999999998990626	WITHOUT_CLASSIFICATION	1.0093740576889E-9	DEFECT
// Note: this simply constructs a "raw" SQL_TOKEN representing the // where fragment and injects this into the tree.  This "works"; // however it is probably not the best long-term solution. // // At some point we probably want to apply an additional grammar to // properly tokenize this where fragment into constituent parts // focused on the operators embedded within the fragment.	WITHOUT_CLASSIFICATION	0.9998004771526425	WITHOUT_CLASSIFICATION	1.995228473574708E-4	DEFECT
// Append the text of the current node.	WITHOUT_CLASSIFICATION	0.999917617278263	WITHOUT_CLASSIFICATION	8.238272173698676E-5	DEFECT
// If the node has a first child, recurse into the first child.	WITHOUT_CLASSIFICATION	0.9999999414887434	WITHOUT_CLASSIFICATION	5.851125664432233E-8	DEFECT
// If there is a second child (RHS), recurse into that child.	WITHOUT_CLASSIFICATION	0.9999997072089137	WITHOUT_CLASSIFICATION	2.927910862653447E-7	DEFECT
// Iterate through the alias,JoinSequence pairs and generate SQL token nodes.	WITHOUT_CLASSIFICATION	0.9999987372488308	WITHOUT_CLASSIFICATION	1.2627511691591727E-6	DEFECT
// If the from element represents a JOIN_FRAGMENT and it is // a theta-style join, convert its type from JOIN_FRAGMENT // to FROM_FRAGMENT	WITHOUT_CLASSIFICATION	0.9999999954688098	WITHOUT_CLASSIFICATION	4.531190177743106E-9	DEFECT
// this is used during SqlGenerator processing	WITHOUT_CLASSIFICATION	0.9999999858528738	WITHOUT_CLASSIFICATION	1.4147126221721951E-8	DEFECT
// If there is a FROM fragment and the FROM element is an explicit, then add the from part.	WITHOUT_CLASSIFICATION	0.9999964170353706	WITHOUT_CLASSIFICATION	3.5829646294696376E-6	DEFECT
/*&& StringHelper.isNotEmpty( frag )*/	WITHOUT_CLASSIFICATION	0.9999962952370747	WITHOUT_CLASSIFICATION	3.704762925375198E-6	DEFECT
// The FROM fragment will probably begin with ', '.  Remove this if it is present.	WITHOUT_CLASSIFICATION	0.997522917621068	WITHOUT_CLASSIFICATION	0.002477082378932088	DEFECT
// This uses a PathExpressionParser but notice that compound paths are not valid, // only bare names and simple paths:	WITHOUT_CLASSIFICATION	0.9999832686513547	WITHOUT_CLASSIFICATION	1.6731348645328136E-5	DEFECT
// SELECT p FROM p IN CLASS eg.Person ORDER BY p.Name, p.Address, p	WITHOUT_CLASSIFICATION	0.9999997104154293	WITHOUT_CLASSIFICATION	2.895845705718706E-7	DEFECT
// The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.	WITHOUT_CLASSIFICATION	0.9997128916943963	WITHOUT_CLASSIFICATION	2.871083056037603E-4	DEFECT
//named query parameter	WITHOUT_CLASSIFICATION	0.9999755488731611	WITHOUT_CLASSIFICATION	2.445112683894963E-5	DEFECT
//default mode	WITHOUT_CLASSIFICATION	0.9999955107584925	WITHOUT_CLASSIFICATION	4.4892415074781E-6	DEFECT
//QueryJoinFragment join = q.createJoinFragment(useThetaStyleJoin);	WITHOUT_CLASSIFICATION	0.9999999561403489	WITHOUT_CLASSIFICATION	4.385965116971834E-8	DEFECT
//reset the dotcount (but not the path) //after reset!	WITHOUT_CLASSIFICATION	0.9998984031682239	WITHOUT_CLASSIFICATION	1.0159683177615705E-4	DEFECT
//after reset!	WITHOUT_CLASSIFICATION	0.9999902576382832	WITHOUT_CLASSIFICATION	9.74236171685584E-6	DEFECT
// we don't need to worry about any condition in the ON clause // here (toFromFragmentString), since anything in the ON condition // is already applied to the whole query	WITHOUT_CLASSIFICATION	0.962611461202931	WITHOUT_CLASSIFICATION	0.037388538797068986	DEFECT
// bit_length feels a bit broken to me. We have to cast to char in order to // pass when a numeric value is supplied. But of course the answers given will // be wildly different for these two datatypes. 1234.5678 will be 9 bytes as // a char string but will be 8 or 16 bytes as a true numeric. // Jay Nance 2006-09-22	WITHOUT_CLASSIFICATION	0.9979165284580218	WITHOUT_CLASSIFICATION	0.0020834715419782214	DEFECT
// dotcount>=2	WITHOUT_CLASSIFICATION	0.9999790948764902	WITHOUT_CLASSIFICATION	2.0905123509788335E-5	DEFECT
// Do the corresponding RHS	WITHOUT_CLASSIFICATION	0.9999837940881637	WITHOUT_CLASSIFICATION	1.6205911836191946E-5	DEFECT
//if its "id"	WITHOUT_CLASSIFICATION	0.9999970743753761	WITHOUT_CLASSIFICATION	2.925624623971318E-6	DEFECT
//or its the id property name	WITHOUT_CLASSIFICATION	0.9999964699979468	WITHOUT_CLASSIFICATION	3.5300020531516035E-6	DEFECT
//join = q.createJoinFragment(useThetaStyleJoin);	WITHOUT_CLASSIFICATION	0.9999999726522266	WITHOUT_CLASSIFICATION	2.734777348106134E-8	DEFECT
//important!!	WITHOUT_CLASSIFICATION	0.9999545702503412	WITHOUT_CLASSIFICATION	4.5429749658794156E-5	DEFECT
//String[] keyCols = collPersister.getKeyColumnNames();	WITHOUT_CLASSIFICATION	0.9999997520285212	WITHOUT_CLASSIFICATION	2.4797147879491054E-7	DEFECT
// an association	WITHOUT_CLASSIFICATION	0.9999998640378066	WITHOUT_CLASSIFICATION	1.3596219342738738E-7	DEFECT
//allow index() function:	WITHOUT_CLASSIFICATION	0.9999734149220215	WITHOUT_CLASSIFICATION	2.658507797854574E-5	DEFECT
// here assume SQLServer2005 using snapshot isolation, which does not have this problem	WITHOUT_CLASSIFICATION	0.9996213456791114	WITHOUT_CLASSIFICATION	3.7865432088867487E-4	DEFECT
// The reason for this is SQL doesn't let you sort by an expression you are // not returning in the result set.	WITHOUT_CLASSIFICATION	0.9997128916943963	WITHOUT_CLASSIFICATION	2.871083056037603E-4	DEFECT
//many-to-many	WITHOUT_CLASSIFICATION	0.9999618554815	WITHOUT_CLASSIFICATION	3.8144518500060994E-5	DEFECT
// collections of values	WITHOUT_CLASSIFICATION	0.9999978861919556	WITHOUT_CLASSIFICATION	2.113808044374463E-6	DEFECT
//opening paren in new Foo ( ... )	WITHOUT_CLASSIFICATION	0.9995914976892892	WITHOUT_CLASSIFICATION	4.085023107107312E-4	DEFECT
//if we are inside a new Result(), but not inside a nested function	WITHOUT_CLASSIFICATION	0.9999246365125445	WITHOUT_CLASSIFICATION	7.536348745549238E-5	DEFECT
//special case	WITHOUT_CLASSIFICATION	0.9999997199956324	WITHOUT_CLASSIFICATION	2.8000436758207223E-7	DEFECT
// the name of an SQL function	WITHOUT_CLASSIFICATION	0.9999994186043002	WITHOUT_CLASSIFICATION	5.813956998089043E-7	DEFECT
//null child could occur for no from clause in a filter	WITHOUT_CLASSIFICATION	0.9999998969662887	WITHOUT_CLASSIFICATION	1.0303371124442356E-7	DEFECT
//this is basically a copy/paste of OrderByParser ... might be worth refactoring	WITHOUT_CLASSIFICATION	0.8659910678484286	DEFECT	0.13400893215157128	WITHOUT_CLASSIFICATION
// SELECT p FROM p IN CLASS eg.Person GROUP BY p.Name, p.Address, p	WITHOUT_CLASSIFICATION	0.9999998658858498	WITHOUT_CLASSIFICATION	1.3411415017027384E-7	DEFECT
// return aliases not supported in classic translator!	WITHOUT_CLASSIFICATION	0.9999636600306684	WITHOUT_CLASSIFICATION	3.6339969331690516E-5	DEFECT
//register collection role	WITHOUT_CLASSIFICATION	0.9999988668607079	WITHOUT_CLASSIFICATION	1.133139292111892E-6	DEFECT
// The keyword used to specify an identity column, if identity column key generation is supported.	WITHOUT_CLASSIFICATION	0.999999986292779	WITHOUT_CLASSIFICATION	1.3707220939414494E-8	DEFECT
//.getElementPropertyMapping();	WITHOUT_CLASSIFICATION	0.9999852556009301	WITHOUT_CLASSIFICATION	1.4744399069872352E-5	DEFECT
//crossJoins.add(name);	WITHOUT_CLASSIFICATION	0.9999807175774377	WITHOUT_CLASSIFICATION	1.9282422562280586E-5	DEFECT
//ie no select clause in HQL	WITHOUT_CLASSIFICATION	0.9999998322304994	WITHOUT_CLASSIFICATION	1.6776950073215745E-7	DEFECT
// initialize the Set of queried identifier spaces (ie. tables)	WITHOUT_CLASSIFICATION	0.9999999994386541	WITHOUT_CLASSIFICATION	5.61345821849118E-10	DEFECT
//ie. no select clause	WITHOUT_CLASSIFICATION	0.999999945330209	WITHOUT_CLASSIFICATION	5.4669790909222283E-8	DEFECT
//there _was_ a select clause	WITHOUT_CLASSIFICATION	0.9999999776882752	WITHOUT_CLASSIFICATION	2.231172478001441E-8	DEFECT
// return the concrete type, or the underlying type if a concrete type // was not specified	WITHOUT_CLASSIFICATION	0.9999992543280356	WITHOUT_CLASSIFICATION	7.456719644293779E-7	DEFECT
//many-to-many	WITHOUT_CLASSIFICATION	0.9999618554815	WITHOUT_CLASSIFICATION	3.8144518500060994E-5	DEFECT
//q.addCollection(collectionName, collectionRole);	WITHOUT_CLASSIFICATION	0.9999910526845601	WITHOUT_CLASSIFICATION	8.947315439769846E-6	DEFECT
// classic parser does not support bulk manipulation statements	WITHOUT_CLASSIFICATION	0.9997687134084422	WITHOUT_CLASSIFICATION	2.3128659155780486E-4	DEFECT
// can't cache this stuff either (per-invocation)	WITHOUT_CLASSIFICATION	0.9999991449897415	WITHOUT_CLASSIFICATION	8.550102584919662E-7	DEFECT
// unfortunately this stuff can't be cached because // it is per-invocation, not constant for the // QueryTranslator instance	WITHOUT_CLASSIFICATION	0.999999640101258	WITHOUT_CLASSIFICATION	3.598987420060637E-7	DEFECT
// This is the legacy behaviour for HQL queries...	WITHOUT_CLASSIFICATION	0.9998521748912785	WITHOUT_CLASSIFICATION	1.4782510872153628E-4	DEFECT
// not known!	WITHOUT_CLASSIFICATION	0.9996645713089033	WITHOUT_CLASSIFICATION	3.354286910967955E-4	DEFECT
// not known!	WITHOUT_CLASSIFICATION	0.9996645713089033	WITHOUT_CLASSIFICATION	3.354286910967955E-4	DEFECT
// we have the form: trim(trimSource) //      so we trim leading and trailing spaces // EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9999931771168752	WITHOUT_CLASSIFICATION	6.822883124870656E-6	DEFECT
// not known!	WITHOUT_CLASSIFICATION	0.9996645713089033	WITHOUT_CLASSIFICATION	3.354286910967955E-4	DEFECT
// not known!	WITHOUT_CLASSIFICATION	0.9996645713089033	WITHOUT_CLASSIFICATION	3.354286910967955E-4	DEFECT
//Need this, since join condition can appear inside parens!	WITHOUT_CLASSIFICATION	0.997162362524582	WITHOUT_CLASSIFICATION	0.002837637475418072	DEFECT
//tokens that close a sub expression //tokens that open a sub expression //tokens that would indicate a sub expression is a boolean expression	WITHOUT_CLASSIFICATION	0.9997149633094902	WITHOUT_CLASSIFICATION	2.850366905098394E-4	DEFECT
//expressionTerminators.add(","); // deliberately excluded	WITHOUT_CLASSIFICATION	0.9999999613793932	WITHOUT_CLASSIFICATION	3.862060685000729E-8	DEFECT
//expressionOpeners.add(","); // deliberately excluded	WITHOUT_CLASSIFICATION	0.9999995989557655	WITHOUT_CLASSIFICATION	4.010442344541709E-7	DEFECT
// we have the form: trim(from trimSource). //      This is functionally equivalent to trim(trimSource) // EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9960657457280319	WITHOUT_CLASSIFICATION	0.0039342542719680955	DEFECT
// otherwise, a trim-specification and/or a trim-character // have been specified;  we need to decide which options // are present and "do the right thing" // should leading trim-characters be trimmed? // should trailing trim-characters be trimmed? // the trim-character (what is to be trimmed off?) // the trim-source (from where should it be trimmed?)	WITHOUT_CLASSIFICATION	0.9999997240436523	WITHOUT_CLASSIFICATION	2.7595634775819727E-7	DEFECT
//Inside a BETWEEN ... AND ... expression	WITHOUT_CLASSIFICATION	0.9970581258442486	WITHOUT_CLASSIFICATION	0.002941874155751485	DEFECT
//were an odd or even number of NOTs encountered //the join string built up by compound paths inside this expression //a flag indicating if the subexpression is known to be boolean	WITHOUT_CLASSIFICATION	0.9999999423862844	WITHOUT_CLASSIFICATION	5.7613715646484994E-8	DEFECT
//ie. a many-to-many	WITHOUT_CLASSIFICATION	0.9999814602566074	WITHOUT_CLASSIFICATION	1.8539743392579614E-5	DEFECT
//Cope with [,]	WITHOUT_CLASSIFICATION	0.9999971578606108	WITHOUT_CLASSIFICATION	2.8421393890848015E-6	DEFECT
//Cope with a continued path expression (ie. ].baz)	WITHOUT_CLASSIFICATION	0.9999975948214	WITHOUT_CLASSIFICATION	2.405178599881803E-6	DEFECT
//NOTE: early return	WITHOUT_CLASSIFICATION	0.9999695278763862	WITHOUT_CLASSIFICATION	3.0472123613814537E-5	DEFECT
//Cope with a subselect	WITHOUT_CLASSIFICATION	0.9999994733058698	WITHOUT_CLASSIFICATION	5.266941302177784E-7	DEFECT
//Cope with special cases of AND, NOT, ()	WITHOUT_CLASSIFICATION	0.999999071828826	WITHOUT_CLASSIFICATION	9.281711739413088E-7	DEFECT
//Close extra brackets we opened	WITHOUT_CLASSIFICATION	0.999999661265045	WITHOUT_CLASSIFICATION	3.38734954955206E-7	DEFECT
//take note when this is a boolean expression	WITHOUT_CLASSIFICATION	0.9968548443279033	WITHOUT_CLASSIFICATION	0.0031451556720967695	DEFECT
// assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.9999996721186791	WITHOUT_CLASSIFICATION	3.278813209065632E-7	DEFECT
//process a token, mapping OO path expressions to SQL expressions	WITHOUT_CLASSIFICATION	0.999947672280293	WITHOUT_CLASSIFICATION	5.232771970691996E-5	DEFECT
//Open any extra brackets we might need.	WITHOUT_CLASSIFICATION	0.9998418457329277	WITHOUT_CLASSIFICATION	1.5815426707234027E-4	DEFECT
//Cope with special cases of AND, NOT, )	WITHOUT_CLASSIFICATION	0.9999989533987867	WITHOUT_CLASSIFICATION	1.0466012132689905E-6	DEFECT
// the next one up must also be	WITHOUT_CLASSIFICATION	0.9999993237189986	WITHOUT_CLASSIFICATION	6.762810015091508E-7	DEFECT
// Add any joins	WITHOUT_CLASSIFICATION	0.9999986672770433	WITHOUT_CLASSIFICATION	1.3327229566642956E-6	DEFECT
// assumes that types are all of span 1	WITHOUT_CLASSIFICATION	0.9999996721186791	WITHOUT_CLASSIFICATION	3.278813209065632E-7	DEFECT
//named query parameter	WITHOUT_CLASSIFICATION	0.9999755488731611	WITHOUT_CLASSIFICATION	2.445112683894963E-5	DEFECT
//path expression	WITHOUT_CLASSIFICATION	0.9999821542607996	WITHOUT_CLASSIFICATION	1.784573920042798E-5	DEFECT
// saves / updates don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999998944534986	WITHOUT_CLASSIFICATION	1.0554650139539461E-7	DEFECT
// persists don't cascade to uninitialized collections	WITHOUT_CLASSIFICATION	0.9999999260326397	WITHOUT_CLASSIFICATION	7.396736034067316E-8	DEFECT
//anything else	WITHOUT_CLASSIFICATION	0.9999988470008172	WITHOUT_CLASSIFICATION	1.1529991827985367E-6	DEFECT
// the path expression continues after a ]	WITHOUT_CLASSIFICATION	0.9999793503321491	WITHOUT_CLASSIFICATION	2.0649667850859096E-5	DEFECT
// careful with this!	WITHOUT_CLASSIFICATION	0.9999998262587465	WITHOUT_CLASSIFICATION	1.737412534766764E-7	DEFECT
// the path expression ends at the ]	WITHOUT_CLASSIFICATION	0.999528465383943	WITHOUT_CLASSIFICATION	4.715346160569598E-4	DEFECT
// "finish off" the join	WITHOUT_CLASSIFICATION	0.9999998786220041	WITHOUT_CLASSIFICATION	1.2137799595767768E-7	DEFECT
//NOTICE: no " or . since they are part of (compound) identifiers	WITHOUT_CLASSIFICATION	0.9999999918627764	WITHOUT_CLASSIFICATION	8.137223515301854E-9	DEFECT
//cannot instantiate	WITHOUT_CLASSIFICATION	0.9999873804827127	WITHOUT_CLASSIFICATION	1.2619517287261959E-5	DEFECT
// start by looking for HQL keywords...	WITHOUT_CLASSIFICATION	0.9999951794472919	WITHOUT_CLASSIFICATION	4.82055270806676E-6	DEFECT
// inner joins can be abbreviated to 'join'	WITHOUT_CLASSIFICATION	0.9999994743733145	WITHOUT_CLASSIFICATION	5.256266855122304E-7	DEFECT
// 'outer' is optional and is ignored	WITHOUT_CLASSIFICATION	0.9999999982772145	WITHOUT_CLASSIFICATION	1.7227854756406274E-9	DEFECT
// now anything that is not a HQL keyword	WITHOUT_CLASSIFICATION	0.9997714536365807	WITHOUT_CLASSIFICATION	2.2854636341923708E-4	DEFECT
// process the "old" HQL style where aliases appear _first_ // ie. using the IN or IN CLASS constructions	WITHOUT_CLASSIFICATION	0.9999999945383611	WITHOUT_CLASSIFICATION	5.461638959707109E-9	DEFECT
// treat it as a classname	WITHOUT_CLASSIFICATION	0.9999907980289032	WITHOUT_CLASSIFICATION	9.201971096678379E-6	DEFECT
// treat it as a path expression	WITHOUT_CLASSIFICATION	0.9998807709723532	WITHOUT_CLASSIFICATION	1.1922902764683294E-4	DEFECT
// starts with the name of a mapped class (new style)	WITHOUT_CLASSIFICATION	0.999999639120466	WITHOUT_CLASSIFICATION	3.6087953404175506E-7	DEFECT
// starts with a path expression (new style)	WITHOUT_CLASSIFICATION	0.9999988198687564	WITHOUT_CLASSIFICATION	1.1801312436314477E-6	DEFECT
//allow ODMG OQL style: from Person p, p.cars c	WITHOUT_CLASSIFICATION	0.999870502189002	WITHOUT_CLASSIFICATION	1.294978109979989E-4	DEFECT
//handle quoted strings	WITHOUT_CLASSIFICATION	0.9999999777609773	WITHOUT_CLASSIFICATION	2.2239022712815695E-8	DEFECT
// Object insertions, updates, and deletions have list semantics because // they must happen in the right order so as to respect referential // integrity	WITHOUT_CLASSIFICATION	0.9999995261891149	WITHOUT_CLASSIFICATION	4.7381088506790066E-7	DEFECT
// "finish off" the join	WITHOUT_CLASSIFICATION	0.9999998786220041	WITHOUT_CLASSIFICATION	1.2137799595767768E-7	DEFECT
//ignore whitespace	WITHOUT_CLASSIFICATION	0.9999999453825739	WITHOUT_CLASSIFICATION	5.461742622691992E-8	DEFECT
//do replacements	WITHOUT_CLASSIFICATION	0.99999995436428	WITHOUT_CLASSIFICATION	4.563571991505968E-8	DEFECT
//handle HQL2 collection syntax	WITHOUT_CLASSIFICATION	0.9999977909984042	WITHOUT_CLASSIFICATION	2.209001595696932E-6	DEFECT
// uuid.hex is deprecated	WITHOUT_CLASSIFICATION	0.9999999618417884	WITHOUT_CLASSIFICATION	3.815821156248642E-8	DEFECT
// AbstractSelectingDelegate impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999753861228	WITHOUT_CLASSIFICATION	2.4613877153612342E-8	DEFECT
//hilo params	WITHOUT_CLASSIFICATION	0.9999989669787464	WITHOUT_CLASSIFICATION	1.0330212535844157E-6	DEFECT
//sql = query;	WITHOUT_CLASSIFICATION	0.999998336002743	WITHOUT_CLASSIFICATION	1.6639972570173258E-6	DEFECT
// performance opt	WITHOUT_CLASSIFICATION	0.9999999241833624	WITHOUT_CLASSIFICATION	7.58166375715871E-8	DEFECT
//sql = update;	WITHOUT_CLASSIFICATION	0.9999998113891376	WITHOUT_CLASSIFICATION	1.886108623978392E-7	DEFECT
//hilo config	WITHOUT_CLASSIFICATION	0.9999826941103702	WITHOUT_CLASSIFICATION	1.7305889629766014E-5	DEFECT
// so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999999630043653	WITHOUT_CLASSIFICATION	3.699563462656102E-8	DEFECT
// don't allow comments on these insert statements as comments totally // blow up the Oracle getGeneratedKeys "support" :(	WITHOUT_CLASSIFICATION	0.9999946871173268	WITHOUT_CLASSIFICATION	5.312882673217224E-6	DEFECT
//abort the save (the object is already saved by a circular cascade)	WITHOUT_CLASSIFICATION	0.9999975417693744	WITHOUT_CLASSIFICATION	2.4582306256011105E-6	DEFECT
//throw new IdentifierGenerationException("save associated object first, or disable cascade for inverse association");	WITHOUT_CLASSIFICATION	0.9999999998783708	WITHOUT_CLASSIFICATION	1.2162918754712605E-10	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
//do nothing to avoid a lazy property initialization	WITHOUT_CLASSIFICATION	0.9999861100261955	WITHOUT_CLASSIFICATION	1.3889973804502407E-5	DEFECT
//keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9999995817590462	WITHOUT_CLASSIFICATION	4.1824095374432955E-7	DEFECT
// so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999999630043653	WITHOUT_CLASSIFICATION	3.699563462656102E-8	DEFECT
// do nothing until we hit the rsult set containing the generated id	WITHOUT_CLASSIFICATION	0.9999999490315009	WITHOUT_CLASSIFICATION	5.0968499164557955E-8	DEFECT
/* COLUMN and TABLE should be renamed but it would break the public API */	WITHOUT_CLASSIFICATION	0.9998370523985309	WITHOUT_CLASSIFICATION	1.6294760146916932E-4	DEFECT
// Loaded entity instances, by EntityKey	WITHOUT_CLASSIFICATION	0.999999647167161	WITHOUT_CLASSIFICATION	3.528328389387687E-7	DEFECT
// if the given name is un-qualified we may neen to qualify it	WITHOUT_CLASSIFICATION	0.9999999131207068	WITHOUT_CLASSIFICATION	8.687929313953901E-8	DEFECT
// the default...	WITHOUT_CLASSIFICATION	0.9999785482067647	WITHOUT_CLASSIFICATION	2.1451793235369457E-5	DEFECT
// unfortunately not really safe to normalize this // to 1 as an initial value like we do the others // because we would not be able to control this if // we are using a sequence...	WITHOUT_CLASSIFICATION	0.9999999548637444	WITHOUT_CLASSIFICATION	4.513625557694491E-8	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
// Identity map of CollectionEntry instances, by the collection wrapper	WITHOUT_CLASSIFICATION	0.9999972055152476	WITHOUT_CLASSIFICATION	2.794484752445275E-6	DEFECT
// general purpose parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999958403501858	WITHOUT_CLASSIFICATION	4.159649814069245E-6	DEFECT
// table-specific parameters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999740411948	WITHOUT_CLASSIFICATION	2.595880509998535E-8	DEFECT
// Configurable implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993558022778	WITHOUT_CLASSIFICATION	6.441977222604679E-7	DEFECT
// IdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999986447638658	WITHOUT_CLASSIFICATION	1.3552361342185057E-6	DEFECT
// PersistentIdentifierGenerator implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998979343465	WITHOUT_CLASSIFICATION	1.0206565349759057E-7	DEFECT
// prepare and execute the insert	WITHOUT_CLASSIFICATION	0.9999999393978113	WITHOUT_CLASSIFICATION	6.060218871393372E-8	DEFECT
// prepare and execute the insert	WITHOUT_CLASSIFICATION	0.9999999393978113	WITHOUT_CLASSIFICATION	6.060218871393372E-8	DEFECT
//fetch the generated id in a separate query	WITHOUT_CLASSIFICATION	0.9999817071913802	WITHOUT_CLASSIFICATION	1.8292808619762966E-5	DEFECT
// we just hit the last position	WITHOUT_CLASSIFICATION	0.9999990948937976	WITHOUT_CLASSIFICATION	9.051062024599687E-7	DEFECT
// scroll ahead	WITHOUT_CLASSIFICATION	0.9999992329253837	WITHOUT_CLASSIFICATION	7.670746162763354E-7	DEFECT
// scroll backward	WITHOUT_CLASSIFICATION	0.9999873349075398	WITHOUT_CLASSIFICATION	1.2665092460184906E-5	DEFECT
// we have not yet hit the last result...	WITHOUT_CLASSIFICATION	0.9873273835798744	WITHOUT_CLASSIFICATION	0.012672616420125668	DEFECT
// Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998811272401	WITHOUT_CLASSIFICATION	1.1887275986450736E-7	DEFECT
// State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965343473148	WITHOUT_CLASSIFICATION	3.4656526851598583E-6	DEFECT
// Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999988947383425	WITHOUT_CLASSIFICATION	1.1052616575149579E-6	DEFECT
// do this when all the properties are updateable since there is // a certain likelihood that the information will already be // snapshot-cached.	WITHOUT_CLASSIFICATION	0.9999992459150214	WITHOUT_CLASSIFICATION	7.540849786170685E-7	DEFECT
// Inner classes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999929977064397	WITHOUT_CLASSIFICATION	7.002293560337631E-6	DEFECT
// Constructors ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998811272401	WITHOUT_CLASSIFICATION	1.1887275986450736E-7	DEFECT
// State ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965343473148	WITHOUT_CLASSIFICATION	3.4656526851598583E-6	DEFECT
// Criteria impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999988947383425	WITHOUT_CLASSIFICATION	1.1052616575149579E-6	DEFECT
// Caches	WITHOUT_CLASSIFICATION	0.9999998686391205	WITHOUT_CLASSIFICATION	1.3136087956803482E-7	DEFECT
//Generators:	WITHOUT_CLASSIFICATION	0.9999987646534696	WITHOUT_CLASSIFICATION	1.2353465304047482E-6	DEFECT
// cache region is defined by the root-class in the hierarchy...	WITHOUT_CLASSIFICATION	0.9999896644521065	WITHOUT_CLASSIFICATION	1.0335547893576071E-5	DEFECT
//check if the detached object being merged is the parent	WITHOUT_CLASSIFICATION	0.9999984193638256	WITHOUT_CLASSIFICATION	1.5806361744220847E-6	DEFECT
// after *all* persisters and named queries are registered	WITHOUT_CLASSIFICATION	0.999999951106404	WITHOUT_CLASSIFICATION	4.889359594727677E-8	DEFECT
// if we get here, it is possible that we have a proxy 'in the way' of the merge map resolution... // 	WITHOUT_CLASSIFICATION	0.9994696062744107	WITHOUT_CLASSIFICATION	5.303937255891629E-4	DEFECT
//JNDI + Serialization:	WITHOUT_CLASSIFICATION	0.9999944082006865	WITHOUT_CLASSIFICATION	5.591799313519126E-6	DEFECT
//checking for named queries	WITHOUT_CLASSIFICATION	0.9999998913016742	WITHOUT_CLASSIFICATION	1.08698325828494E-7	DEFECT
//stats	WITHOUT_CLASSIFICATION	0.9999949156376996	WITHOUT_CLASSIFICATION	5.084362300423472E-6	DEFECT
// EntityNotFoundDelegate	WITHOUT_CLASSIFICATION	0.9999994940925295	WITHOUT_CLASSIFICATION	5.059074705534737E-7	DEFECT
// Check named HQL queries	WITHOUT_CLASSIFICATION	0.9999999970596264	WITHOUT_CLASSIFICATION	2.940373583944462E-9	DEFECT
// this will throw an error if there's something wrong.	WITHOUT_CLASSIFICATION	0.9995862174199662	WITHOUT_CLASSIFICATION	4.137825800337029E-4	DEFECT
//prevents this session from adding things to cache	WITHOUT_CLASSIFICATION	0.999865994083468	WITHOUT_CLASSIFICATION	1.34005916531935E-4	DEFECT
// from javax.naming.Referenceable	WITHOUT_CLASSIFICATION	0.9999998250517411	WITHOUT_CLASSIFICATION	1.7494825878211231E-7	DEFECT
// look for the instance by uuid	WITHOUT_CLASSIFICATION	0.9999992418896794	WITHOUT_CLASSIFICATION	7.581103206725284E-7	DEFECT
//for a dynamic-class	WITHOUT_CLASSIFICATION	0.9999868652241197	WITHOUT_CLASSIFICATION	1.3134775880200853E-5	DEFECT
//test this entity to see if we must query it	WITHOUT_CLASSIFICATION	0.9999998873891578	WITHOUT_CLASSIFICATION	1.1261084223258247E-7	DEFECT
//NOTE EARLY EXIT	WITHOUT_CLASSIFICATION	0.9999933621825333	WITHOUT_CLASSIFICATION	6.637817466638353E-6	DEFECT
// for backward-compatability	WITHOUT_CLASSIFICATION	0.9999996721859499	WITHOUT_CLASSIFICATION	3.278140500532208E-7	DEFECT
// ignore this error for now	WITHOUT_CLASSIFICATION	0.9999999057270123	WITHOUT_CLASSIFICATION	9.427298766291852E-8	DEFECT
//to stop the class from being unloaded	WITHOUT_CLASSIFICATION	0.9999991181656229	WITHOUT_CLASSIFICATION	8.818343770095174E-7	DEFECT
// in case we were deserialized in a different JVM, look for an instance with the same name // (alternatively we could do an actual JNDI lookup here....)	WITHOUT_CLASSIFICATION	0.9996128116248906	WITHOUT_CLASSIFICATION	3.8718837510937326E-4	DEFECT
//must add to JNDI _after_ adding to HashMaps, because some JNDI servers use serialization	WITHOUT_CLASSIFICATION	0.999999947680821	WITHOUT_CLASSIFICATION	5.2319179048784744E-8	DEFECT
// Make sure this is a defined parameter and check the incoming value type	WITHOUT_CLASSIFICATION	0.9999998059190348	WITHOUT_CLASSIFICATION	1.9408096515815178E-7	DEFECT
// for each of the defined parameters, make sure its value // has been set	WITHOUT_CLASSIFICATION	0.9999999944999536	WITHOUT_CLASSIFICATION	5.500046407336107E-9	DEFECT
//we never need to apply locks to the SQL	WITHOUT_CLASSIFICATION	0.9999925519725026	WITHOUT_CLASSIFICATION	7.448027497507169E-6	DEFECT
// inserts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999971398088352	WITHOUT_CLASSIFICATION	2.8601911649113493E-6	DEFECT
// deletes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999977632224124	WITHOUT_CLASSIFICATION	2.2367775875547956E-6	DEFECT
// during deserialization, we need to reconnect all proxies and // collections to this session, as well as the EntityEntry and // CollectionEntry instances; these associations are transient // because serialization is used for different things.	WITHOUT_CLASSIFICATION	0.9999999880620842	WITHOUT_CLASSIFICATION	1.1937915716348605E-8	DEFECT
// updates ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999990551789251	WITHOUT_CLASSIFICATION	9.448210748495916E-7	DEFECT
// loading ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999517444871109	WITHOUT_CLASSIFICATION	4.8255512888997885E-5	DEFECT
//final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9999997507530155	WITHOUT_CLASSIFICATION	2.492469844776843E-7	DEFECT
//final boolean forceCacheRefresh,	WITHOUT_CLASSIFICATION	0.9999997507530155	WITHOUT_CLASSIFICATION	2.492469844776843E-7	DEFECT
// first, try to load it from the temp PC associated to this SS	WITHOUT_CLASSIFICATION	0.9999999947089195	WITHOUT_CLASSIFICATION	5.29108044004887E-9	DEFECT
// if the metadata allowed proxy creation and caller did not request forceful eager loading, // generate a proxy	WITHOUT_CLASSIFICATION	0.9999998861602607	WITHOUT_CLASSIFICATION	1.138397393093774E-7	DEFECT
// otherwise immediately materialize it	WITHOUT_CLASSIFICATION	0.9999997851091271	WITHOUT_CLASSIFICATION	2.1489087289965664E-7	DEFECT
/////////////////////////////////////////////////////////////////////////////////////////////////////	WITHOUT_CLASSIFICATION	0.9999716818625526	WITHOUT_CLASSIFICATION	2.831813744743344E-5	DEFECT
// no auto-flushing to support in stateless session	WITHOUT_CLASSIFICATION	0.99999997500735	WITHOUT_CLASSIFICATION	2.4992649974849823E-8	DEFECT
//after setting values to object, entityMode	WITHOUT_CLASSIFICATION	0.9999967804449902	WITHOUT_CLASSIFICATION	3.219555009838114E-6	DEFECT
//for EJB3	WITHOUT_CLASSIFICATION	0.999971107411083	WITHOUT_CLASSIFICATION	2.889258891700667E-5	DEFECT
// just ignore	WITHOUT_CLASSIFICATION	0.9999999928443011	WITHOUT_CLASSIFICATION	7.155698915158402E-9	DEFECT
// do a check	WITHOUT_CLASSIFICATION	0.999999255503125	WITHOUT_CLASSIFICATION	7.444968750044032E-7	DEFECT
// saveOrUpdate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999094051711	WITHOUT_CLASSIFICATION	9.059482879548135E-8	DEFECT
// update() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997407780662	WITHOUT_CLASSIFICATION	2.5922193383428207E-7	DEFECT
// lock() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999983435628448	WITHOUT_CLASSIFICATION	1.6564371552255284E-6	DEFECT
// persist() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998513140469	WITHOUT_CLASSIFICATION	1.4868595317631846E-7	DEFECT
// persistOnFlush() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999238169283	WITHOUT_CLASSIFICATION	7.618307178474715E-8	DEFECT
// merge() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999999776312269	WITHOUT_CLASSIFICATION	2.236877309430231E-7	DEFECT
// saveOrUpdateCopy() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997507795964	WITHOUT_CLASSIFICATION	2.4922040362414357E-7	DEFECT
// delete() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997992629648	WITHOUT_CLASSIFICATION	2.0073703533563262E-7	DEFECT
// load()/get() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999991853900934	WITHOUT_CLASSIFICATION	8.146099065883184E-7	DEFECT
// refresh() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999991354491845	WITHOUT_CLASSIFICATION	8.64550815479785E-7	DEFECT
// replicate() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999776657225	WITHOUT_CLASSIFICATION	2.2334277461662456E-8	DEFECT
// do not auto-flush while outside a transaction	WITHOUT_CLASSIFICATION	0.9999989241487884	WITHOUT_CLASSIFICATION	1.0758512116129106E-6	DEFECT
// this is an internal error of some sort...	WITHOUT_CLASSIFICATION	0.9990122084621691	WITHOUT_CLASSIFICATION	9.877915378309204E-4	DEFECT
//stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9999933910084765	WITHOUT_CLASSIFICATION	6.608991523537538E-6	DEFECT
//only collections belonging to deleted entities are allowed to be dereferenced in the case of orphan delete	WITHOUT_CLASSIFICATION	0.9999991282833033	WITHOUT_CLASSIFICATION	8.717166966636857E-7	DEFECT
// if it was previously unreferenced, we need to flush in order to // get its state into the database in order to execute query	WITHOUT_CLASSIFICATION	0.9999999933999294	WITHOUT_CLASSIFICATION	6.600070545174753E-9	DEFECT
// not for internal use:	WITHOUT_CLASSIFICATION	0.999999657892275	WITHOUT_CLASSIFICATION	3.4210772502706523E-7	DEFECT
// otherwise, we only need to flush if there are in-memory changes // to the queried tables	WITHOUT_CLASSIFICATION	0.9999999976350543	WITHOUT_CLASSIFICATION	2.364945738229124E-9	DEFECT
// might need to run a different filter entirely after the flush // because the collection role may have changed	WITHOUT_CLASSIFICATION	0.999999157005155	WITHOUT_CLASSIFICATION	8.429948449534432E-7	DEFECT
//stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9999933910084765	WITHOUT_CLASSIFICATION	6.608991523537538E-6	DEFECT
//stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9999933910084765	WITHOUT_CLASSIFICATION	6.608991523537538E-6	DEFECT
//if it is initialized, see if the underlying //instance is contained, since we need to  //account for the fact that it might have been //evicted	WITHOUT_CLASSIFICATION	0.9999985124075564	WITHOUT_CLASSIFICATION	1.4875924435493383E-6	DEFECT
// basically just an adapted copy of find(CriteriaImpl)	WITHOUT_CLASSIFICATION	0.9999997800628142	WITHOUT_CLASSIFICATION	2.19937185872843E-7	DEFECT
// it is possible for this method to be called during flush processing, // so make certain that we do not accidently initialize an uninitialized proxy	WITHOUT_CLASSIFICATION	0.9999999975565484	WITHOUT_CLASSIFICATION	2.4434515705413596E-9	DEFECT
// nothing to do in a stateful session	WITHOUT_CLASSIFICATION	0.9999985064287464	WITHOUT_CLASSIFICATION	1.4935712536237853E-6	DEFECT
// ignore	WITHOUT_CLASSIFICATION	0.9999996022307994	WITHOUT_CLASSIFICATION	3.977692004945396E-7	DEFECT
// ignore this error for now	WITHOUT_CLASSIFICATION	0.9999999057270123	WITHOUT_CLASSIFICATION	9.427298766291852E-8	DEFECT
// we need to writeObject() on this since interceptor is user defined	WITHOUT_CLASSIFICATION	0.9999999980555839	WITHOUT_CLASSIFICATION	1.9444161092537226E-9	DEFECT
// the old-time stand-by...	WITHOUT_CLASSIFICATION	0.9997839582768429	WITHOUT_CLASSIFICATION	2.160417231571134E-4	DEFECT
// parameter bind values...	WITHOUT_CLASSIFICATION	0.9999980911401378	WITHOUT_CLASSIFICATION	1.908859862197218E-6	DEFECT
// Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999992190280255	WITHOUT_CLASSIFICATION	7.809719746275868E-7	DEFECT
// prepend value and type list with null for any positions before the wanted position.	WITHOUT_CLASSIFICATION	0.9999951315790776	WITHOUT_CLASSIFICATION	4.868420922372053E-6	DEFECT
// Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999927511799113	WITHOUT_CLASSIFICATION	7.24882008878172E-6	DEFECT
// we have a CGLIB enhanced entity	WITHOUT_CLASSIFICATION	0.9999994994460096	WITHOUT_CLASSIFICATION	5.00553990279754E-7	DEFECT
// we have a CGLIB enhanced entity	WITHOUT_CLASSIFICATION	0.9999994994460096	WITHOUT_CLASSIFICATION	5.00553990279754E-7	DEFECT
// we have a Javassist enhanced entity	WITHOUT_CLASSIFICATION	0.9999999475637628	WITHOUT_CLASSIFICATION	5.243623729913041E-8	DEFECT
// we have a Javassist enhanced entity	WITHOUT_CLASSIFICATION	0.9999999475637628	WITHOUT_CLASSIFICATION	5.243623729913041E-8	DEFECT
// FieldInterceptor impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999982701503138	WITHOUT_CLASSIFICATION	1.7298496861148862E-6	DEFECT
// subclass accesses ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999989738495959	WITHOUT_CLASSIFICATION	1.0261504040658105E-6	DEFECT
//let's assume that there is only one lazy fetch group, for now!	WITHOUT_CLASSIFICATION	0.9999916003363796	WITHOUT_CLASSIFICATION	8.399663620479509E-6	DEFECT
// FieldHandler impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993932928848	WITHOUT_CLASSIFICATION	6.067071152628833E-7	DEFECT
// should *not* need to grow beyond the size of the total number of columns in the rs	WITHOUT_CLASSIFICATION	0.9999844681747908	WITHOUT_CLASSIFICATION	1.5531825209156766E-5	DEFECT
// should probably no-op commit/rollback here, at least in JTA scenarios	WITHOUT_CLASSIFICATION	0.9999313516043259	WITHOUT_CLASSIFICATION	6.864839567407842E-5	DEFECT
// Base Expectation impls ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9995440013832537	WITHOUT_CLASSIFICATION	4.559986167463079E-4	DEFECT
// Various Expectation instances ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999946792048723	WITHOUT_CLASSIFICATION	5.3207951277093034E-6	DEFECT
// explicitly perform no checking...	WITHOUT_CLASSIFICATION	0.9999957035125142	WITHOUT_CLASSIFICATION	4.29648748579217E-6	DEFECT
// used from testsuite	WITHOUT_CLASSIFICATION	0.9999999881981171	WITHOUT_CLASSIFICATION	1.1801882883235896E-8	DEFECT
// assume we are in an auto-commit state	WITHOUT_CLASSIFICATION	0.9999999908614933	WITHOUT_CLASSIFICATION	9.138506785504024E-9	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
// register synch; stats.connect()	WITHOUT_CLASSIFICATION	0.9999998249214999	WITHOUT_CLASSIFICATION	1.7507850017768185E-7	DEFECT
//noncritical, swallow and let the other propagate!	WITHOUT_CLASSIFICATION	0.9999984646745873	WITHOUT_CLASSIFICATION	1.5353254126356112E-6	DEFECT
// calls executeBatch()	WITHOUT_CLASSIFICATION	0.9999991683828475	WITHOUT_CLASSIFICATION	8.316171524389393E-7	DEFECT
//no big deal	WITHOUT_CLASSIFICATION	0.9999964172072443	WITHOUT_CLASSIFICATION	3.5827927556255837E-6	DEFECT
// no big deal	WITHOUT_CLASSIFICATION	0.9999995798886185	WITHOUT_CLASSIFICATION	4.201113814885727E-7	DEFECT
// no big deal	WITHOUT_CLASSIFICATION	0.9999995798886185	WITHOUT_CLASSIFICATION	4.201113814885727E-7	DEFECT
// sybase driver (jConnect) throwing NPE here in certain // cases, but we'll just handle the general "unexpected" case	WITHOUT_CLASSIFICATION	0.9999999818519263	WITHOUT_CLASSIFICATION	1.8148073715791576E-8	DEFECT
// see explanation above...	WITHOUT_CLASSIFICATION	0.9999135487921106	WITHOUT_CLASSIFICATION	8.645120788940842E-5	DEFECT
// If we are in the process of releasing, no sense // checking for aggressive-release possibility.	WITHOUT_CLASSIFICATION	0.9999999947673134	WITHOUT_CLASSIFICATION	5.232686645036802E-9	DEFECT
// EARLY EXIT!!!!	WITHOUT_CLASSIFICATION	0.9999771072978842	WITHOUT_CLASSIFICATION	2.289270211575977E-5	DEFECT
// ResultSet impl ("overridden") ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999973958538385	WITHOUT_CLASSIFICATION	2.60414616152668E-6	DEFECT
// ResultSet impl (delegated) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999990177279126	WITHOUT_CLASSIFICATION	9.822720874851516E-7	DEFECT
// refer to comment in StatefulPersistenceContext.addCollection()	WITHOUT_CLASSIFICATION	0.9999993701858939	WITHOUT_CLASSIFICATION	6.298141061840056E-7	DEFECT
// ConnectionManager.Callback implementation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999089645943967	WITHOUT_CLASSIFICATION	9.103540560328106E-5	DEFECT
// Note : success = false, because we don't know the outcome of the transaction	WITHOUT_CLASSIFICATION	0.999999153070962	WITHOUT_CLASSIFICATION	8.469290381134594E-7	DEFECT
// we already have a callback registered; either a local // (org.hibernate.Transaction) transaction has accepted // callback responsibilities, or we have previously // registered a transaction synch.	WITHOUT_CLASSIFICATION	0.9999999627239048	WITHOUT_CLASSIFICATION	3.7276095194113346E-8	DEFECT
// the configured transaction-factory says it only supports // local callback mode, so no sense attempting to register a // JTA Synchronization	WITHOUT_CLASSIFICATION	0.9999962687469405	WITHOUT_CLASSIFICATION	3.731253059530257E-6	DEFECT
// transactions marked for rollback-only cause some TM impls to throw exceptions	WITHOUT_CLASSIFICATION	0.9989522456725414	WITHOUT_CLASSIFICATION	0.0010477543274586606	DEFECT
// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999980308291153	WITHOUT_CLASSIFICATION	1.969170884694351E-6	DEFECT
//postInitialize() will be called after initialization	WITHOUT_CLASSIFICATION	0.9999950591783348	WITHOUT_CLASSIFICATION	4.940821665283354E-6	DEFECT
// cannot handle single quotes	WITHOUT_CLASSIFICATION	0.999999369867536	WITHOUT_CLASSIFICATION	6.30132463973696E-7	DEFECT
// todo : for 4.0 //	WITHOUT_CLASSIFICATION	0.9998230964913651	WITHOUT_CLASSIFICATION	1.7690350863491583E-4	DEFECT
// note that for sequential scrolling, we make the assumption that // the first persister element is the "root entity"	WITHOUT_CLASSIFICATION	0.999999859994201	WITHOUT_CLASSIFICATION	1.4000579893585756E-7	DEFECT
// don't even bother trying to read further	WITHOUT_CLASSIFICATION	0.9999773098520051	WITHOUT_CLASSIFICATION	2.2690147994908298E-5	DEFECT
// don't even bother trying to read any further	WITHOUT_CLASSIFICATION	0.9999605139949065	WITHOUT_CLASSIFICATION	3.9486005093403504E-5	DEFECT
// position cursor to the last row	WITHOUT_CLASSIFICATION	0.9999992664011867	WITHOUT_CLASSIFICATION	7.335988132392525E-7	DEFECT
// sequentially read the result set in reverse until we recognize // a change in the key value.  At that point, we are pointed at // the last physical sequential row for the logical row in which // we are interested in processing	WITHOUT_CLASSIFICATION	0.9999999991159674	WITHOUT_CLASSIFICATION	8.84032626420719E-10	DEFECT
// Read backwards until we read past the first physical sequential // row with the key we are interested in loading	WITHOUT_CLASSIFICATION	0.9998995585404272	WITHOUT_CLASSIFICATION	1.0044145957287381E-4	DEFECT
// Finally, read ahead one row to position result set cursor // at the first physical row we are interested in loading	WITHOUT_CLASSIFICATION	0.9999992087813386	WITHOUT_CLASSIFICATION	7.912186613435811E-7	DEFECT
// now get an existing proxy for each row element (if there is one)	WITHOUT_CLASSIFICATION	0.9999999900377445	WITHOUT_CLASSIFICATION	9.962255399892082E-9	DEFECT
// force the proxy to resolve itself	WITHOUT_CLASSIFICATION	0.9999998518452259	WITHOUT_CLASSIFICATION	1.481547740630753E-7	DEFECT
// this is equivalent to the old behavior...	WITHOUT_CLASSIFICATION	0.9999336407645785	WITHOUT_CLASSIFICATION	6.635923542161259E-5	DEFECT
//if null, owner will be retrieved from session	WITHOUT_CLASSIFICATION	0.9999560453533335	WITHOUT_CLASSIFICATION	4.3954646666487434E-5	DEFECT
//final String queryString, 	WITHOUT_CLASSIFICATION	0.9999807164681177	WITHOUT_CLASSIFICATION	1.9283531882370126E-5	DEFECT
// if it was a reference to self, don't need to nullify // unless we are using native id generation, in which // case we definitely need to nullify	WITHOUT_CLASSIFICATION	0.999999985321394	WITHOUT_CLASSIFICATION	1.4678606011504685E-8	DEFECT
//end of array, start filling again from start	WITHOUT_CLASSIFICATION	0.9999990980102186	WITHOUT_CLASSIFICATION	9.019897814393201E-7	DEFECT
// in an effort to avoid concurrent-modification-exceptions (from // potential recursive calls back through here as a result of the // eventual call to PersistentCollection#endRead), we scan the // internal loadingCollections map for matches and store those matches // in a temp collection.  the temp collection is then used to "drive" // the #endRead processing.	WITHOUT_CLASSIFICATION	0.999992776792931	WITHOUT_CLASSIFICATION	7.22320706906104E-6	DEFECT
//we can reuse it for each row	WITHOUT_CLASSIFICATION	0.9999983189301127	WITHOUT_CLASSIFICATION	1.6810698872944797E-6	DEFECT
//can't reuse in this case	WITHOUT_CLASSIFICATION	0.9999801081807148	WITHOUT_CLASSIFICATION	1.9891819285236563E-5	DEFECT
// First we need to suspend any current JTA transaction and obtain // a JDBC connection	WITHOUT_CLASSIFICATION	0.999998452935469	WITHOUT_CLASSIFICATION	1.547064530952659E-6	DEFECT
//getResultList(results);	WITHOUT_CLASSIFICATION	0.9999718708917551	WITHOUT_CLASSIFICATION	2.812910824480311E-5	DEFECT
//if we only returned one entity, query by key is more efficient	WITHOUT_CLASSIFICATION	0.9999899311261181	WITHOUT_CLASSIFICATION	1.0068873881946175E-5	DEFECT
// a collection loaded in the current session // can not possibly be the collection belonging // to the entity passed to update()	WITHOUT_CLASSIFICATION	0.999997579584961	WITHOUT_CLASSIFICATION	2.420415038836016E-6	DEFECT
// handle empty collection	WITHOUT_CLASSIFICATION	0.9999997358063349	WITHOUT_CLASSIFICATION	2.641936649768614E-7	DEFECT
// else no collection element, but also no owner	WITHOUT_CLASSIFICATION	0.9999999230946531	WITHOUT_CLASSIFICATION	7.690534683589647E-8	DEFECT
//handle empty collections	WITHOUT_CLASSIFICATION	0.9999999700573964	WITHOUT_CLASSIFICATION	2.994260366372759E-8	DEFECT
// else this is not a collection initializer (and empty collections will // be detected by looking for the owner's identifier in the result set)	WITHOUT_CLASSIFICATION	0.9999998766146643	WITHOUT_CLASSIFICATION	1.2338533581188316E-7	DEFECT
// validate() instances of Validatable	WITHOUT_CLASSIFICATION	0.9999995561450103	WITHOUT_CLASSIFICATION	4.4385498975420474E-7	DEFECT
// if we know there is exactly 1 row, we can skip. // it would be great if we could _always_ skip this; // it is a problem for <key-many-to-one>	WITHOUT_CLASSIFICATION	0.9997062581592971	WITHOUT_CLASSIFICATION	2.9374184070287416E-4	DEFECT
// remove all collections for the entity from the session-level cache	WITHOUT_CLASSIFICATION	0.9999969617196517	WITHOUT_CLASSIFICATION	3.0382803482146573E-6	DEFECT
//null version means the object is in the process of being loaded somewhere else in the ResultSet	WITHOUT_CLASSIFICATION	0.9999988842103397	WITHOUT_CLASSIFICATION	1.115789660246164E-6	DEFECT
//problematic for <key-many-to-one>!	WITHOUT_CLASSIFICATION	0.9999409767284128	WITHOUT_CLASSIFICATION	5.902327158716336E-5	DEFECT
//use the id passed in	WITHOUT_CLASSIFICATION	0.9999998913707334	WITHOUT_CLASSIFICATION	1.0862926657029988E-7	DEFECT
//do nothing	WITHOUT_CLASSIFICATION	0.9999964384690594	WITHOUT_CLASSIFICATION	3.5615309407163037E-6	DEFECT
// prefer re-generation of identity!	WITHOUT_CLASSIFICATION	0.9999910835276069	WITHOUT_CLASSIFICATION	8.916472393133087E-6	DEFECT
//no point doing this if NONE was requested	WITHOUT_CLASSIFICATION	0.9999997601894037	WITHOUT_CLASSIFICATION	2.3981059629702096E-7	DEFECT
//If the object is already loaded, return the loaded one	WITHOUT_CLASSIFICATION	0.9999969581013852	WITHOUT_CLASSIFICATION	3.0418986148441347E-6	DEFECT
//its already loaded so don't need to hydrate it	WITHOUT_CLASSIFICATION	0.9999806797983735	WITHOUT_CLASSIFICATION	1.932020162652215E-5	DEFECT
// cascade the refresh prior to refreshing this entity	WITHOUT_CLASSIFICATION	0.9999996867541581	WITHOUT_CLASSIFICATION	3.13245841945752E-7	DEFECT
//the load() which takes an entity does not pass an entityName	WITHOUT_CLASSIFICATION	0.9999219216338635	WITHOUT_CLASSIFICATION	7.807836613639846E-5	DEFECT
//we only check the version when _upgrading_ lock modes	WITHOUT_CLASSIFICATION	0.9999989574659767	WITHOUT_CLASSIFICATION	1.0425340233293824E-6	DEFECT
// look for a proxy	WITHOUT_CLASSIFICATION	0.9999944149411952	WITHOUT_CLASSIFICATION	5.585058804748816E-6	DEFECT
//we need to upgrade the lock mode to the mode requested	WITHOUT_CLASSIFICATION	0.9999993751149073	WITHOUT_CLASSIFICATION	6.248850926461289E-7	DEFECT
//its the given optional object	WITHOUT_CLASSIFICATION	0.9999940306923618	WITHOUT_CLASSIFICATION	5.969307638220443E-6	DEFECT
// instantiate a new instance	WITHOUT_CLASSIFICATION	0.9999999711097514	WITHOUT_CLASSIFICATION	2.8890248545714604E-8	DEFECT
//need to hydrate it.	WITHOUT_CLASSIFICATION	0.9999964383167803	WITHOUT_CLASSIFICATION	3.5616832196428683E-6	DEFECT
// return a newly loaded object	WITHOUT_CLASSIFICATION	0.9999968883975163	WITHOUT_CLASSIFICATION	3.111602483677216E-6	DEFECT
//will be ignored, using the existing Entry instead	WITHOUT_CLASSIFICATION	0.9999998363923398	WITHOUT_CLASSIFICATION	1.636076601621719E-7	DEFECT
// key is an entity involved with the operation performed by the listener; // value can be either a copy of the entity or the entity itself	WITHOUT_CLASSIFICATION	0.9999999935317194	WITHOUT_CLASSIFICATION	6.468280548880434E-9	DEFECT
//materialize associations (and initialize the object) later	WITHOUT_CLASSIFICATION	0.9999999047401554	WITHOUT_CLASSIFICATION	9.52598445231471E-8	DEFECT
// Get the persister for the _subclass_	WITHOUT_CLASSIFICATION	0.99999997628605	WITHOUT_CLASSIFICATION	2.3713949946352864E-8	DEFECT
// ok in normal Hibernate usage to delete a detached entity; JPA however // forbids it, thus this is a hook for HEM to affect this behavior	WITHOUT_CLASSIFICATION	0.9999946854623922	WITHOUT_CLASSIFICATION	5.314537607790003E-6	DEFECT
// the entry will be removed after the flush, and will no longer // override the stale snapshot // This is now handled by removeEntity() in EntityDeleteAction //persistenceContext.removeDatabaseSnapshot(key);	WITHOUT_CLASSIFICATION	0.9999766211395409	WITHOUT_CLASSIFICATION	2.3378860459143457E-5	DEFECT
//addInitializedCollection(collection, persister, id);	WITHOUT_CLASSIFICATION	0.999999913206358	WITHOUT_CLASSIFICATION	8.679364203141618E-8	DEFECT
//EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999655062189466	WITHOUT_CLASSIFICATION	3.449378105341125E-5	DEFECT
//EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999655062189466	WITHOUT_CLASSIFICATION	3.449378105341125E-5	DEFECT
/*|| oj.getJoinable().consumesCollectionAlias() */	WITHOUT_CLASSIFICATION	0.9999999223434674	WITHOUT_CLASSIFICATION	7.765653255782692E-8	DEFECT
// here we do not bother with the discriminator.	WITHOUT_CLASSIFICATION	0.999999813341493	WITHOUT_CLASSIFICATION	1.8665850704776878E-7	DEFECT
// Code to handle subclasses of topClass	WITHOUT_CLASSIFICATION	0.9999985192417418	WITHOUT_CLASSIFICATION	1.480758258179812E-6	DEFECT
//woops we got an instance of another class hierarchy branch	WITHOUT_CLASSIFICATION	0.9999993637390535	WITHOUT_CLASSIFICATION	6.362609464526198E-7	DEFECT
// we can go straight to the first required row	WITHOUT_CLASSIFICATION	0.9999951952495322	WITHOUT_CLASSIFICATION	4.804750467879111E-6	DEFECT
// we need to step through the rows one row at a time (slow)	WITHOUT_CLASSIFICATION	0.9999996592577337	WITHOUT_CLASSIFICATION	3.407422662333642E-7	DEFECT
// synchronized to avoid multi-thread access issues; defined as method synch to avoid // potential deadlock issues due to nature of code.	WITHOUT_CLASSIFICATION	0.9999998979061039	WITHOUT_CLASSIFICATION	1.0209389606382541E-7	DEFECT
// Allows various loaders (ok mainly the QueryLoader :) to check // whether scrolling of their result set should be allowed. // // By default it is allowed.	WITHOUT_CLASSIFICATION	0.9999924657569204	WITHOUT_CLASSIFICATION	7.534243079625926E-6	DEFECT
//before adding to collection!	WITHOUT_CLASSIFICATION	0.9999364019189335	WITHOUT_CLASSIFICATION	6.359808106649507E-5	DEFECT
// if the current depth is 0, the root thing being loaded is the // many-to-many collection itself.  Here, it is alright to use // an inner join...	WITHOUT_CLASSIFICATION	0.9999998197086961	WITHOUT_CLASSIFICATION	1.802913040135775E-7	DEFECT
//operations which cascade as far as the collection also cascade to collection elements	WITHOUT_CLASSIFICATION	0.9999995546696097	WITHOUT_CLASSIFICATION	4.4533039034220313E-7	DEFECT
// simple, because we can't have a one-to-one or a collection  // (or even a property-ref) in a composite-element:	WITHOUT_CLASSIFICATION	0.99999883559422	WITHOUT_CLASSIFICATION	1.1644057800058518E-6	DEFECT
//a composite key	WITHOUT_CLASSIFICATION	0.9999996075779328	WITHOUT_CLASSIFICATION	3.9242206713955794E-7	DEFECT
// if no batch, use "foo = ? and bar = ?"	WITHOUT_CLASSIFICATION	0.9999999956574619	WITHOUT_CLASSIFICATION	4.342538049931075E-9	DEFECT
//it must be a collection fetch	WITHOUT_CLASSIFICATION	0.9999974951564565	WITHOUT_CLASSIFICATION	2.504843543430396E-6	DEFECT
// needed later for many-to-many/filter application	WITHOUT_CLASSIFICATION	0.9999956403923502	WITHOUT_CLASSIFICATION	4.359607649786703E-6	DEFECT
/*&& etype.isReferenceToPrimaryKey()*/	WITHOUT_CLASSIFICATION	0.9999976284004977	WITHOUT_CLASSIFICATION	2.3715995023926247E-6	DEFECT
// it might still need to apply a collection ordering based on a // many-to-many defined order-by...	WITHOUT_CLASSIFICATION	0.9991932760160097	WITHOUT_CLASSIFICATION	8.067239839904004E-4	DEFECT
// if a composite key, use "( (foo = ? and bar = ?) or (foo = ? and bar = ?) )" for batching //TODO: unnecessary for databases with ANSI-style joins	WITHOUT_CLASSIFICATION	0.999999035308777	WITHOUT_CLASSIFICATION	9.646912230595452E-7	DEFECT
// belong to other persister // belong to other persister	WITHOUT_CLASSIFICATION	0.9999999599371924	WITHOUT_CLASSIFICATION	4.0062807636469286E-8	DEFECT
// we found it	WITHOUT_CLASSIFICATION	0.9999970759342879	WITHOUT_CLASSIFICATION	2.924065712137336E-6	DEFECT
//we can use an inner join for the many-to-many	WITHOUT_CLASSIFICATION	0.9999998514963452	WITHOUT_CLASSIFICATION	1.4850365470060033E-7	DEFECT
//disable a join back to this same association	WITHOUT_CLASSIFICATION	0.9999914828596597	WITHOUT_CLASSIFICATION	8.517140340257952E-6	DEFECT
//NOTE: unlike all other Loaders, this one is NOT //      multithreaded, or cacheable!!	WITHOUT_CLASSIFICATION	0.9999935145415063	WITHOUT_CLASSIFICATION	6.485458493664576E-6	DEFECT
//the user visible aliases, which are unknown to the superclass, //these are not the actual "physical" SQL aliases	WITHOUT_CLASSIFICATION	0.9999769887228817	WITHOUT_CLASSIFICATION	2.3011277118336013E-5	DEFECT
//root entity comes *last*	WITHOUT_CLASSIFICATION	0.9999914781379408	WITHOUT_CLASSIFICATION	8.521862059312527E-6	DEFECT
//deliberately ignore return value!	WITHOUT_CLASSIFICATION	0.9999980947926632	WITHOUT_CLASSIFICATION	1.90520733673897E-6	DEFECT
//alias may be null //EARLY EXIT	WITHOUT_CLASSIFICATION	0.9999798827247423	WITHOUT_CLASSIFICATION	2.0117275257791523E-5	DEFECT
// if it is a compound path	WITHOUT_CLASSIFICATION	0.9999998921347393	WITHOUT_CLASSIFICATION	1.0786526073891172E-7	DEFECT
// otherwise assume the parent is the the criteria that created us	WITHOUT_CLASSIFICATION	0.999999995964382	WITHOUT_CLASSIFICATION	4.03561801832019E-9	DEFECT
// if its the root criteria, we are done	WITHOUT_CLASSIFICATION	0.9999999747175685	WITHOUT_CLASSIFICATION	2.5282431554886598E-8	DEFECT
// otherwise, recurse	WITHOUT_CLASSIFICATION	0.9999999569744028	WITHOUT_CLASSIFICATION	4.302559716931293E-8	DEFECT
//the criteria instance	WITHOUT_CLASSIFICATION	0.9999999150928327	WITHOUT_CLASSIFICATION	8.490716729689017E-8	DEFECT
// the entity name	WITHOUT_CLASSIFICATION	0.9999978669833873	WITHOUT_CLASSIFICATION	2.133016612683239E-6	DEFECT
//not found in inner query , try the outer query	WITHOUT_CLASSIFICATION	0.9999863361313536	WITHOUT_CLASSIFICATION	1.366386864648461E-5	DEFECT
//not found in inner query , try the outer query	WITHOUT_CLASSIFICATION	0.9999863361313536	WITHOUT_CLASSIFICATION	1.366386864648461E-5	DEFECT
//it refers to an alias of a projection	WITHOUT_CLASSIFICATION	0.9999975744822664	WITHOUT_CLASSIFICATION	2.4255177335405927E-6	DEFECT
//should never happen, i think	WITHOUT_CLASSIFICATION	0.9999976159816625	WITHOUT_CLASSIFICATION	2.384018337495749E-6	DEFECT
// Detect discriminator values...	WITHOUT_CLASSIFICATION	0.9999897327407552	WITHOUT_CLASSIFICATION	1.0267259244775276E-5	DEFECT
// Convert the string value into the proper type.	WITHOUT_CLASSIFICATION	0.9999969823790777	WITHOUT_CLASSIFICATION	3.0176209223150844E-6	DEFECT
// and the qualifier is not the alias of this criteria //      -> check to see if we belong to some criteria other //          than the one that created us	WITHOUT_CLASSIFICATION	0.9999999999987512	WITHOUT_CLASSIFICATION	1.2487433302635299E-12	DEFECT
//it does not refer to an alias of a projection, //look for a property	WITHOUT_CLASSIFICATION	0.9999889469020153	WITHOUT_CLASSIFICATION	1.1053097984629995E-5	DEFECT
// Otherwise, this is an ordinary value.	WITHOUT_CLASSIFICATION	0.9999952129948269	WITHOUT_CLASSIFICATION	4.787005173115579E-6	DEFECT
// Currently *not* cachable if autodiscover types is in effect (e.g. "select * ...")	WITHOUT_CLASSIFICATION	0.9999990148067966	WITHOUT_CLASSIFICATION	9.851932033185404E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// this is only needed (afaict) for ResultTransformer processing...	WITHOUT_CLASSIFICATION	0.9997164051296533	WITHOUT_CLASSIFICATION	2.835948703466416E-4	DEFECT
// determine if the collection elements are entities...	WITHOUT_CLASSIFICATION	0.9999994481799402	WITHOUT_CLASSIFICATION	5.518200598504803E-7	DEFECT
// build an array with indices equal to the total number // of actual returns in the result Hibernate will return // for this query (scalars + non-scalars)	WITHOUT_CLASSIFICATION	0.99912703394071	WITHOUT_CLASSIFICATION	8.729660592900429E-4	DEFECT
// replace {....} with corresponding column aliases	WITHOUT_CLASSIFICATION	0.9999946938891052	WITHOUT_CLASSIFICATION	5.3061108947949165E-6	DEFECT
// No additional open braces found in the string, append the // rest of the string in its entirty and quit this loop	WITHOUT_CLASSIFICATION	0.9999933880619022	WITHOUT_CLASSIFICATION	6.611938097887465E-6	DEFECT
// apend everything up until the next encountered open brace	WITHOUT_CLASSIFICATION	0.9999988658718366	WITHOUT_CLASSIFICATION	1.1341281634256953E-6	DEFECT
// it is a simple table alias {foo}	WITHOUT_CLASSIFICATION	0.999999840203683	WITHOUT_CLASSIFICATION	1.5979631697611152E-7	DEFECT
// passing through anything we do not know : to support jdbc escape sequences HB-898	WITHOUT_CLASSIFICATION	0.9993482023655681	WITHOUT_CLASSIFICATION	6.517976344318996E-4	DEFECT
// passing through anything we do not know : to support jdbc escape sequences HB-898	WITHOUT_CLASSIFICATION	0.9993482023655681	WITHOUT_CLASSIFICATION	6.517976344318996E-4	DEFECT
// The current alias is referencing the collection to be eagerly fetched	WITHOUT_CLASSIFICATION	0.9999671704657738	WITHOUT_CLASSIFICATION	3.28295342262157E-5	DEFECT
// it is a property reference {foo.bar}	WITHOUT_CLASSIFICATION	0.9999701920318816	WITHOUT_CLASSIFICATION	2.9807968118330166E-5	DEFECT
// Possibly handle :something parameters for the query ?	WITHOUT_CLASSIFICATION	0.9999924348522955	WITHOUT_CLASSIFICATION	7.565147704503429E-6	DEFECT
// Let return-propertys override whatever the persister has for aliases.	WITHOUT_CLASSIFICATION	0.9999999464076528	WITHOUT_CLASSIFICATION	5.359234728912324E-8	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
//NOTE: EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9996427553748141	WITHOUT_CLASSIFICATION	3.572446251858308E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// Now, process the returns	WITHOUT_CLASSIFICATION	0.9999999689371654	WITHOUT_CLASSIFICATION	3.106283467830773E-8	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// already been processed...	WITHOUT_CLASSIFICATION	0.9999993939726602	WITHOUT_CLASSIFICATION	6.060273398638287E-7	DEFECT
// already been processed...	WITHOUT_CLASSIFICATION	0.9999993939726602	WITHOUT_CLASSIFICATION	6.060273398638287E-7	DEFECT
// Make sure the owner alias is known...	WITHOUT_CLASSIFICATION	0.9999886516652563	WITHOUT_CLASSIFICATION	1.1348334743816669E-5	DEFECT
// first, break down the returns into maps keyed by alias // so that role returns can be more easily resolved to their owners	WITHOUT_CLASSIFICATION	0.9999990569745698	WITHOUT_CLASSIFICATION	9.430254301028293E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// If this return's alias has not been processed yet, do so b4 further processing of this return	WITHOUT_CLASSIFICATION	0.9999999650847239	WITHOUT_CLASSIFICATION	3.4915276114311114E-8	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// for merging of versioned entities, we consider the version having // been changed only when: // 1) the two version values are different; //      *AND* // 2) The target actually represents database state! // // This second condition is a special case which allows // an entity to be merged during the same transaction // (though during a seperate operation) in which it was // originally persisted/saved	WITHOUT_CLASSIFICATION	0.9992010687092212	WITHOUT_CLASSIFICATION	7.989312907788706E-4	DEFECT
// this is the second pass through on a merge op, so here we limit the // replacement to associations types (value types were already replaced // during the first pass)	WITHOUT_CLASSIFICATION	0.9999995323609948	WITHOUT_CLASSIFICATION	4.676390052299211E-7	DEFECT
//EARLY EXIT	WITHOUT_CLASSIFICATION	0.999989177895297	WITHOUT_CLASSIFICATION	1.0822104702944368E-5	DEFECT
// cascade-save to collections AFTER the collection owner was saved	WITHOUT_CLASSIFICATION	0.9999984870796436	WITHOUT_CLASSIFICATION	1.512920356421445E-6	DEFECT
// Initialize the error handling delegate.	WITHOUT_CLASSIFICATION	0.9999999440670514	WITHOUT_CLASSIFICATION	5.593294853997471E-8	DEFECT
// Use the delegate.	WITHOUT_CLASSIFICATION	0.9999999943818183	WITHOUT_CLASSIFICATION	5.618181629880714E-9	DEFECT
// currently only the Hibernate-supplied DbTimestampType is supported here	WITHOUT_CLASSIFICATION	0.9999895792559695	WITHOUT_CLASSIFICATION	1.0420744030541674E-5	DEFECT
// This is called when it's time to fully resolve a path expression.	WITHOUT_CLASSIFICATION	0.997687719437876	WITHOUT_CLASSIFICATION	0.002312280562123945	DEFECT
// make a new one	WITHOUT_CLASSIFICATION	0.9999938427136871	WITHOUT_CLASSIFICATION	6.157286312938201E-6	DEFECT
// not so sure this is even valid subtree.  but if it was, it'd // represent two unrelated table references...	WITHOUT_CLASSIFICATION	0.9999998928215785	WITHOUT_CLASSIFICATION	1.0717842141313659E-7	DEFECT
// (NOT (GT a b) ) => (LE a b)	WITHOUT_CLASSIFICATION	0.9999999160269294	WITHOUT_CLASSIFICATION	8.397307058650702E-8	DEFECT
//private Type[] sqlResultTypes;	WITHOUT_CLASSIFICATION	0.9999976768798899	WITHOUT_CLASSIFICATION	2.3231201100564867E-6	DEFECT
//include the discriminator and class-level where, but not filters	WITHOUT_CLASSIFICATION	0.9999999227425737	WITHOUT_CLASSIFICATION	7.725742634302756E-8	DEFECT
//sqlResultTypes = selectClause.getSqlResultTypes();	WITHOUT_CLASSIFICATION	0.9999998295077855	WITHOUT_CLASSIFICATION	1.7049221435780943E-7	DEFECT
//by default	WITHOUT_CLASSIFICATION	0.999998181757315	WITHOUT_CLASSIFICATION	1.8182426849877855E-6	DEFECT
// This is now handled earlier in this method.	WITHOUT_CLASSIFICATION	0.99999126919677	WITHOUT_CLASSIFICATION	8.73080322998032E-6	DEFECT
// -- Loader implementation --	WITHOUT_CLASSIFICATION	0.9999971885771645	WITHOUT_CLASSIFICATION	2.8114228356707284E-6	DEFECT
// -- Loader overrides --	WITHOUT_CLASSIFICATION	0.9999999231441749	WITHOUT_CLASSIFICATION	7.685582510363564E-8	DEFECT
// (NOT (IS_NULL a b) ) => (IS_NOT_NULL a b)	WITHOUT_CLASSIFICATION	0.9999999117316799	WITHOUT_CLASSIFICATION	8.826832009736218E-8	DEFECT
//NONE, because its the requested lock mode, not the actual! 	WITHOUT_CLASSIFICATION	0.999954358761503	WITHOUT_CLASSIFICATION	4.5641238496932245E-5	DEFECT
// meant to handle dynamic instantiation queries...	WITHOUT_CLASSIFICATION	0.9999867955084817	WITHOUT_CLASSIFICATION	1.320449151825336E-5	DEFECT
// --- Query translator methods ---	WITHOUT_CLASSIFICATION	0.9999975435900869	WITHOUT_CLASSIFICATION	2.4564099132028624E-6	DEFECT
// -- Implementation private methods --	WITHOUT_CLASSIFICATION	0.9999941499476906	WITHOUT_CLASSIFICATION	5.85005230930888E-6	DEFECT
//deduplicate unique constraints sharing the same columns //this is needed by Hibernate Annotations since it creates automagically // unique constraints for the user	WITHOUT_CLASSIFICATION	0.9999997030072931	WITHOUT_CLASSIFICATION	2.969927067910416E-7	DEFECT
// Try to find out the name of the primary key to create it as identity if the IdentityGenerator is used	WITHOUT_CLASSIFICATION	0.999999999973961	WITHOUT_CLASSIFICATION	2.6038956813441944E-11	DEFECT
// to support dialects that have their own identity data type	WITHOUT_CLASSIFICATION	0.9999984121818657	WITHOUT_CLASSIFICATION	1.5878181343731424E-6	DEFECT
// Prepare the left hand side and get the data type.	WITHOUT_CLASSIFICATION	0.9999998051382791	WITHOUT_CLASSIFICATION	1.9486172083603312E-7	DEFECT
//used also for generation of FK names!	WITHOUT_CLASSIFICATION	0.999977214462297	WITHOUT_CLASSIFICATION	2.2785537702989613E-5	DEFECT
//usually useless	WITHOUT_CLASSIFICATION	0.9999992820430846	WITHOUT_CLASSIFICATION	7.179569153357989E-7	DEFECT
// added this caching as I noticed that getType() is being called multiple times...	WITHOUT_CLASSIFICATION	0.9932378980458185	WITHOUT_CLASSIFICATION	0.00676210195418156	DEFECT
//do not add unique constraint on DB not supporting unique and nullable columns	WITHOUT_CLASSIFICATION	0.9999999201105961	WITHOUT_CLASSIFICATION	7.988940381733219E-8	DEFECT
//for backward compatibility, disable this:	WITHOUT_CLASSIFICATION	0.9999999352748014	WITHOUT_CLASSIFICATION	6.472519869698538E-8	DEFECT
//may be final //may be final //may be final	WITHOUT_CLASSIFICATION	0.9999808351951965	WITHOUT_CLASSIFICATION	1.9164804803502722E-5	DEFECT
//may be final	WITHOUT_CLASSIFICATION	0.9999942963431523	WITHOUT_CLASSIFICATION	5.703656847659839E-6	DEFECT
// may be final	WITHOUT_CLASSIFICATION	0.9999965188381924	WITHOUT_CLASSIFICATION	3.481161807629022E-6	DEFECT
// Custom SQL	WITHOUT_CLASSIFICATION	0.9999999503811039	WITHOUT_CLASSIFICATION	4.9618896112507134E-8	DEFECT
//Primary key constraint	WITHOUT_CLASSIFICATION	0.9999998042296147	WITHOUT_CLASSIFICATION	1.957703854223793E-7	DEFECT
// the root of the incoming property path matched one // of the embedded composite identifier properties	WITHOUT_CLASSIFICATION	0.9999999625562066	WITHOUT_CLASSIFICATION	3.7443793277350865E-8	DEFECT
// ignore it...	WITHOUT_CLASSIFICATION	0.9999648850705624	WITHOUT_CLASSIFICATION	3.511492943772464E-5	DEFECT
//flat recursive algorithm	WITHOUT_CLASSIFICATION	0.9999896662740715	WITHOUT_CLASSIFICATION	1.0333725928611675E-5	DEFECT
//an identifier mapper => getKey will be included in the getNonDuplicatedPropertyIterator() //and checked later, so it needs to be excluded	WITHOUT_CLASSIFICATION	0.9999999670950009	WITHOUT_CLASSIFICATION	3.2904999135104255E-8	DEFECT
//if the hibernate-mapping did not specify a schema/catalog, use the defaults //specified by properties - but note that if the schema/catalog were specified //in hibernate-mapping, or as params, they will already be initialized and //will override the values set here (they are in identifierGeneratorProperties)	WITHOUT_CLASSIFICATION	0.9999999999913128	WITHOUT_CLASSIFICATION	8.687107818785671E-12	DEFECT
//pass the entity-name, if not a collection-id	WITHOUT_CLASSIFICATION	0.9999836660201746	WITHOUT_CLASSIFICATION	1.6333979825348493E-5	DEFECT
// Custom SQL	WITHOUT_CLASSIFICATION	0.9999999503811039	WITHOUT_CLASSIFICATION	4.9618896112507134E-8	DEFECT
//Primary key constraint	WITHOUT_CLASSIFICATION	0.9999998042296147	WITHOUT_CLASSIFICATION	1.957703854223793E-7	DEFECT
//pass the column name (a generated id almost always has a single column)	WITHOUT_CLASSIFICATION	0.9999984516735725	WITHOUT_CLASSIFICATION	1.5483264275378717E-6	DEFECT
//needed to satisfy KeyValue	WITHOUT_CLASSIFICATION	0.999999517835607	WITHOUT_CLASSIFICATION	4.821643930199514E-7	DEFECT
// empty means no scoping	WITHOUT_CLASSIFICATION	0.9999999139998887	WITHOUT_CLASSIFICATION	8.6000111259938E-8	DEFECT
// index should be last column listed	WITHOUT_CLASSIFICATION	0.9999974288233157	WITHOUT_CLASSIFICATION	2.5711766842830345E-6	DEFECT
//if it is a formula index, use the element columns in the PK	WITHOUT_CLASSIFICATION	0.9999995459263584	WITHOUT_CLASSIFICATION	4.540736416243465E-7	DEFECT
// don't create a unique key, 'cos some // databases don't like a UK on nullable // columns	WITHOUT_CLASSIFICATION	0.9996782459507271	WITHOUT_CLASSIFICATION	3.2175404927294005E-4	DEFECT
/*ArrayList list = new ArrayList();	WITHOUT_CLASSIFICATION	0.9999597155990664	WITHOUT_CLASSIFICATION	4.0284400933592955E-5	DEFECT
// }	WITHOUT_CLASSIFICATION	0.9999934386815676	WITHOUT_CLASSIFICATION	6.561318432438375E-6	DEFECT
// no foreign key element of for a one-to-many	WITHOUT_CLASSIFICATION	0.9999994339950538	WITHOUT_CLASSIFICATION	5.660049462543579E-7	DEFECT
//TODO: we could just return all false...	WITHOUT_CLASSIFICATION	0.986632931308536	WITHOUT_CLASSIFICATION	0.013367068691464	DEFECT
// the case of a foreign key to something other than the pk is handled in createPropertyRefConstraints	WITHOUT_CLASSIFICATION	0.999999999327585	WITHOUT_CLASSIFICATION	6.724149683337474E-10	DEFECT
//TODO: we could just return all false...	WITHOUT_CLASSIFICATION	0.986632931308536	WITHOUT_CLASSIFICATION	0.013367068691464	DEFECT
// if the property mapping consists of all formulas,  // make it non-updateable	WITHOUT_CLASSIFICATION	0.9999962389409702	WITHOUT_CLASSIFICATION	3.7610590297476394E-6	DEFECT
//columnUpdateability.length==0 ||	WITHOUT_CLASSIFICATION	0.9999990703121308	WITHOUT_CLASSIFICATION	9.296878693772454E-7	DEFECT
// if the property mapping consists of all formulas,  // make it insertable	WITHOUT_CLASSIFICATION	0.9999663679355779	WITHOUT_CLASSIFICATION	3.363206442216838E-5	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999892300526	WITHOUT_CLASSIFICATION	1.0769947447438444E-8	DEFECT
// expected type is intrinsic here...	WITHOUT_CLASSIFICATION	0.9991367851517848	WITHOUT_CLASSIFICATION	8.63214848215139E-4	DEFECT
//}	WITHOUT_CLASSIFICATION	0.9999757710309766	WITHOUT_CLASSIFICATION	2.4228969023399712E-5	DEFECT
//}	WITHOUT_CLASSIFICATION	0.9999757710309766	WITHOUT_CLASSIFICATION	2.4228969023399712E-5	DEFECT
//return memberPersister.getPropertyType(propertyName);	WITHOUT_CLASSIFICATION	0.9999890428728444	WITHOUT_CLASSIFICATION	1.0957127155496682E-5	DEFECT
//return memberPersister.toColumns(alias, propertyName);	WITHOUT_CLASSIFICATION	0.9999994148308229	WITHOUT_CLASSIFICATION	5.85169177152496E-7	DEFECT
//return memberPersister.getType();	WITHOUT_CLASSIFICATION	0.9999980997759497	WITHOUT_CLASSIFICATION	1.9002240502240102E-6	DEFECT
/*&& !indexIsFormula*/	WITHOUT_CLASSIFICATION	0.9999689754879577	WITHOUT_CLASSIFICATION	3.1024512042252375E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//instanceof AssociationType;	WITHOUT_CLASSIFICATION	0.9999962794513074	WITHOUT_CLASSIFICATION	3.7205486924913344E-6	DEFECT
// we need to determine the best way to know that two joinables // represent a single many-to-many...	WITHOUT_CLASSIFICATION	0.9999960146860297	WITHOUT_CLASSIFICATION	3.985313970284921E-6	DEFECT
//strip leading ','	WITHOUT_CLASSIFICATION	0.9999997643921016	WITHOUT_CLASSIFICATION	2.35607898498246E-7	DEFECT
//public boolean isSubselectLoadable();	WITHOUT_CLASSIFICATION	0.9999998389879323	WITHOUT_CLASSIFICATION	1.610120676986692E-7	DEFECT
// KEY	WITHOUT_CLASSIFICATION	0.9999959093783696	WITHOUT_CLASSIFICATION	4.0906216303977796E-6	DEFECT
//columns	WITHOUT_CLASSIFICATION	0.9999908921636825	WITHOUT_CLASSIFICATION	9.1078363175675E-6	DEFECT
//SQL statements	WITHOUT_CLASSIFICATION	0.9999999481831344	WITHOUT_CLASSIFICATION	5.18168656388925E-8	DEFECT
//extra information about the element type	WITHOUT_CLASSIFICATION	0.9999900709627834	WITHOUT_CLASSIFICATION	9.929037216573284E-6	DEFECT
//types	WITHOUT_CLASSIFICATION	0.9999832667093805	WITHOUT_CLASSIFICATION	1.6733290619497242E-5	DEFECT
// custom sql	WITHOUT_CLASSIFICATION	0.9999998197579786	WITHOUT_CLASSIFICATION	1.80242021405947E-7	DEFECT
//private final String unquotedIdentifierColumnName;	WITHOUT_CLASSIFICATION	0.9999997890533886	WITHOUT_CLASSIFICATION	2.109466114582329E-7	DEFECT
// dynamic filters specifically for many-to-many inside the collection	WITHOUT_CLASSIFICATION	0.9999940511518155	WITHOUT_CLASSIFICATION	5.94884818445703E-6	DEFECT
// dynamic filters for the collection	WITHOUT_CLASSIFICATION	0.9999955917188081	WITHOUT_CLASSIFICATION	4.4082811918627995E-6	DEFECT
// NativeSQL: collect key column and auto-aliases	WITHOUT_CLASSIFICATION	0.9999997940683105	WITHOUT_CLASSIFICATION	2.0593168948925383E-7	DEFECT
//unquotedKeyColumnNames = StringHelper.unQuote(keyColumnAliases);	WITHOUT_CLASSIFICATION	0.9999985313792492	WITHOUT_CLASSIFICATION	1.468620750713621E-6	DEFECT
//ELEMENT	WITHOUT_CLASSIFICATION	0.9999648879247853	WITHOUT_CLASSIFICATION	3.511207521464948E-5	DEFECT
// NativeSQL: collect element column and auto-aliases	WITHOUT_CLASSIFICATION	0.9999999914331196	WITHOUT_CLASSIFICATION	8.566880418379003E-9	DEFECT
// INDEX AND ROW SELECT	WITHOUT_CLASSIFICATION	0.9999991334512671	WITHOUT_CLASSIFICATION	8.665487328354168E-7	DEFECT
// NativeSQL: collect index column and auto-aliases	WITHOUT_CLASSIFICATION	0.9999994460470861	WITHOUT_CLASSIFICATION	5.539529140010761E-7	DEFECT
//unquotedIdentifierColumnName = identifierColumnAlias;	WITHOUT_CLASSIFICATION	0.9999999609205239	WITHOUT_CLASSIFICATION	3.907947617178287E-8	DEFECT
//unquotedIdentifierColumnName = null;	WITHOUT_CLASSIFICATION	0.9999993906898762	WITHOUT_CLASSIFICATION	6.093101238270984E-7	DEFECT
//GENERATE THE SQL:	WITHOUT_CLASSIFICATION	0.9999966210561354	WITHOUT_CLASSIFICATION	3.3789438645625517E-6	DEFECT
// for non-arrays, we don't need to know the element class //elementType.returnedClass();	WITHOUT_CLASSIFICATION	0.9999999899868958	WITHOUT_CLASSIFICATION	1.0013104300183019E-8	DEFECT
//not all classpersisters implement PropertyMapping!	WITHOUT_CLASSIFICATION	0.9994321396877265	WITHOUT_CLASSIFICATION	5.678603122734416E-4	DEFECT
// Handle any filters applied to this collection	WITHOUT_CLASSIFICATION	0.9999998752166263	WITHOUT_CLASSIFICATION	1.2478337380437506E-7	DEFECT
// Handle any filters applied to this collection for many-to-many	WITHOUT_CLASSIFICATION	0.999999955945215	WITHOUT_CLASSIFICATION	4.405478498065581E-8	DEFECT
//if there is a user-specified loader, return that //TODO: filters!?	WITHOUT_CLASSIFICATION	0.9998519670421055	WITHOUT_CLASSIFICATION	1.4803295789449323E-4	DEFECT
// Take care of any entities that might have // been evicted!	WITHOUT_CLASSIFICATION	0.9998962406436765	WITHOUT_CLASSIFICATION	1.0375935632341207E-4	DEFECT
//strip leading ','	WITHOUT_CLASSIFICATION	0.9999997643921016	WITHOUT_CLASSIFICATION	2.35607898498246E-7	DEFECT
// Run a subquery loader	WITHOUT_CLASSIFICATION	0.99982370103513	WITHOUT_CLASSIFICATION	1.7629896486999358E-4	DEFECT
//needed by arrays	WITHOUT_CLASSIFICATION	0.9999986658978857	WITHOUT_CLASSIFICATION	1.3341021142782513E-6	DEFECT
//TODO: something with formulas...	WITHOUT_CLASSIFICATION	0.9900583786432632	WITHOUT_CLASSIFICATION	0.009941621356736716	DEFECT
//an assertion	WITHOUT_CLASSIFICATION	0.9999991392016936	WITHOUT_CLASSIFICATION	8.607983063384989E-7	DEFECT
// Remove all the old entries	WITHOUT_CLASSIFICATION	0.9999991233581126	WITHOUT_CLASSIFICATION	8.766418874529599E-7	DEFECT
//create all the new entries	WITHOUT_CLASSIFICATION	0.9999999636399453	WITHOUT_CLASSIFICATION	3.6360054710011994E-8	DEFECT
/*&& !indexIsFormula*/	WITHOUT_CLASSIFICATION	0.9999689754879577	WITHOUT_CLASSIFICATION	3.1024512042252375E-5	DEFECT
/*&& !indexIsFormula*/	WITHOUT_CLASSIFICATION	0.9999689754879577	WITHOUT_CLASSIFICATION	3.1024512042252375E-5	DEFECT
//delete all the deleted entries	WITHOUT_CLASSIFICATION	0.9999999824330023	WITHOUT_CLASSIFICATION	1.75669978056146E-8	DEFECT
//insert all the new entries	WITHOUT_CLASSIFICATION	0.9999998265127942	WITHOUT_CLASSIFICATION	1.7348720578750742E-7	DEFECT
//==elementType ??	WITHOUT_CLASSIFICATION	0.9999958944725074	WITHOUT_CLASSIFICATION	4.1055274925896706E-6	DEFECT
//update all the modified entries	WITHOUT_CLASSIFICATION	0.9999998721108155	WITHOUT_CLASSIFICATION	1.2788918450515207E-7	DEFECT
//identifier collections not supported for 1-to-many	WITHOUT_CLASSIFICATION	0.9999976777060976	WITHOUT_CLASSIFICATION	2.322293902392138E-6	DEFECT
// update removed rows fks to null	WITHOUT_CLASSIFICATION	0.9992780025007306	WITHOUT_CLASSIFICATION	7.219974992693248E-4	DEFECT
// will still be issued when it used to be null	WITHOUT_CLASSIFICATION	0.9999177408486879	WITHOUT_CLASSIFICATION	8.225915131208089E-5	DEFECT
// now update all changed or added rows fks	WITHOUT_CLASSIFICATION	0.9999994456666973	WITHOUT_CLASSIFICATION	5.543333027263052E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//use suffix for the entity columns	WITHOUT_CLASSIFICATION	0.999992194923624	WITHOUT_CLASSIFICATION	7.805076375914266E-6	DEFECT
// the class hierarchy structure	WITHOUT_CLASSIFICATION	0.9999998689894208	WITHOUT_CLASSIFICATION	1.310105790961021E-7	DEFECT
//private final String rootTableName;	WITHOUT_CLASSIFICATION	0.9999986456438651	WITHOUT_CLASSIFICATION	1.3543561348801786E-6	DEFECT
//INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9999646745979419	WITHOUT_CLASSIFICATION	3.532540205802722E-5	DEFECT
//Custom SQL	WITHOUT_CLASSIFICATION	0.9999998241594429	WITHOUT_CLASSIFICATION	1.7584055715856825E-7	DEFECT
// the class hierarchy structure	WITHOUT_CLASSIFICATION	0.9999998689894208	WITHOUT_CLASSIFICATION	1.310105790961021E-7	DEFECT
// Execute the SQL:	WITHOUT_CLASSIFICATION	0.9999997487463461	WITHOUT_CLASSIFICATION	2.5125365382148076E-7	DEFECT
// This could also just be true all the time...	WITHOUT_CLASSIFICATION	0.999989819840684	WITHOUT_CLASSIFICATION	1.0180159316110928E-5	DEFECT
//chop the last union (all)	WITHOUT_CLASSIFICATION	0.999992836868129	WITHOUT_CLASSIFICATION	7.163131871027235E-6	DEFECT
//TODO: check this....	WITHOUT_CLASSIFICATION	0.9963173436600052	WITHOUT_CLASSIFICATION	0.003682656339994844	DEFECT
//INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9999646745979419	WITHOUT_CLASSIFICATION	3.532540205802722E-5	DEFECT
// properties of this class, including inherited properties	WITHOUT_CLASSIFICATION	0.9999795753147487	WITHOUT_CLASSIFICATION	2.0424685251388086E-5	DEFECT
// the closure of all properties in the entire hierarchy including // subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.9999941486256915	WITHOUT_CLASSIFICATION	5.851374308484913E-6	DEFECT
// the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.9999999289148839	WITHOUT_CLASSIFICATION	7.108511614331825E-8	DEFECT
// subclass discrimination works by assigning particular // values to certain combinations of null primary key // values in the outer join using an SQL CASE	WITHOUT_CLASSIFICATION	0.9999496073153972	WITHOUT_CLASSIFICATION	5.039268460287171E-5	DEFECT
//MULTITABLES	WITHOUT_CLASSIFICATION	0.9999883076846536	WITHOUT_CLASSIFICATION	1.169231534634886E-5	DEFECT
// Custom sql	WITHOUT_CLASSIFICATION	0.9999999202088218	WITHOUT_CLASSIFICATION	7.979117816308778E-8	DEFECT
// subclass closure properties	WITHOUT_CLASSIFICATION	0.9999991019190106	WITHOUT_CLASSIFICATION	8.980809893584345E-7	DEFECT
// SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999980472556182	WITHOUT_CLASSIFICATION	1.952744381773971E-6	DEFECT
//( (Column) model.getTable().getPrimaryKey().getColumnIterator().next() ).getName();	WITHOUT_CLASSIFICATION	0.9999997813239191	WITHOUT_CLASSIFICATION	2.186760809774566E-7	DEFECT
//( (Column) sc.getTable().getPrimaryKey().getColumnIterator().next() ).getName();	WITHOUT_CLASSIFICATION	0.9999999623630729	WITHOUT_CLASSIFICATION	3.7636927076358506E-8	DEFECT
// don't need subclass tables, because they can't appear in conditions	WITHOUT_CLASSIFICATION	0.9958293163192985	WITHOUT_CLASSIFICATION	0.004170683680701534	DEFECT
// special case where we need to force incloude all subclass joins	WITHOUT_CLASSIFICATION	0.9999999752552666	WITHOUT_CLASSIFICATION	2.4744733362834886E-8	DEFECT
// the class hierarchy structure	WITHOUT_CLASSIFICATION	0.9999998689894208	WITHOUT_CLASSIFICATION	1.310105790961021E-7	DEFECT
// properties of this class, including inherited properties	WITHOUT_CLASSIFICATION	0.9999795753147487	WITHOUT_CLASSIFICATION	2.0424685251388086E-5	DEFECT
// the closure of all columns used by the entire hierarchy including // subclasses and superclasses of this class	WITHOUT_CLASSIFICATION	0.9999999289148839	WITHOUT_CLASSIFICATION	7.108511614331825E-8	DEFECT
//get em on the second pass!	WITHOUT_CLASSIFICATION	0.9999922574316389	WITHOUT_CLASSIFICATION	7.742568361082331E-6	DEFECT
// now look up the object we are really interested in! // (this lets us correctly handle proxies and multi-row // or multi-column queries)	WITHOUT_CLASSIFICATION	0.9999964687676648	WITHOUT_CLASSIFICATION	3.5312323351461253E-6	DEFECT
// discriminator column	WITHOUT_CLASSIFICATION	0.9999993948723062	WITHOUT_CLASSIFICATION	6.05127693854437E-7	DEFECT
//INITIALIZATION:	WITHOUT_CLASSIFICATION	0.9999646745979419	WITHOUT_CLASSIFICATION	3.532540205802722E-5	DEFECT
//private final Map propertyTableNumbersByName = new HashMap();	WITHOUT_CLASSIFICATION	0.9999998605398426	WITHOUT_CLASSIFICATION	1.3946015739699857E-7	DEFECT
// CLASS + TABLE	WITHOUT_CLASSIFICATION	0.9999996696851289	WITHOUT_CLASSIFICATION	3.3031487109305434E-7	DEFECT
// DISCRIMINATOR	WITHOUT_CLASSIFICATION	0.9999982806023665	WITHOUT_CLASSIFICATION	1.7193976335232055E-6	DEFECT
// PROPERTIES	WITHOUT_CLASSIFICATION	0.9999993176881365	WITHOUT_CLASSIFICATION	6.823118634709873E-7	DEFECT
// SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999980472556182	WITHOUT_CLASSIFICATION	1.952744381773971E-6	DEFECT
// Execute the SQL:	WITHOUT_CLASSIFICATION	0.9999997487463461	WITHOUT_CLASSIFICATION	2.5125365382148076E-7	DEFECT
// JOINS	WITHOUT_CLASSIFICATION	0.9999936521150264	WITHOUT_CLASSIFICATION	6.347884973568206E-6	DEFECT
//propertyTableNumbersByName.put( prop.getName(), join );	WITHOUT_CLASSIFICATION	0.9999990262367742	WITHOUT_CLASSIFICATION	9.737632257829824E-7	DEFECT
//Access cached SQL	WITHOUT_CLASSIFICATION	0.9999997582808084	WITHOUT_CLASSIFICATION	2.417191915847267E-7	DEFECT
//figure out which tables need to be fetched	WITHOUT_CLASSIFICATION	0.9999992988921252	WITHOUT_CLASSIFICATION	7.011078747192939E-7	DEFECT
//figure out which columns are needed	WITHOUT_CLASSIFICATION	0.999999809032813	WITHOUT_CLASSIFICATION	1.9096718684705998E-7	DEFECT
//figure out which formulas are needed	WITHOUT_CLASSIFICATION	0.9999998604806446	WITHOUT_CLASSIFICATION	1.3951935545088354E-7	DEFECT
//render the SQL	WITHOUT_CLASSIFICATION	0.9999880505301881	WITHOUT_CLASSIFICATION	1.1949469811960266E-5	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is Tuplizer-centric ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999892300526	WITHOUT_CLASSIFICATION	1.0769947447438444E-8	DEFECT
// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999585830717	WITHOUT_CLASSIFICATION	4.141692840407226E-8	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
// The optional SQL string defined in the where attribute	WITHOUT_CLASSIFICATION	0.9999999976340606	WITHOUT_CLASSIFICATION	2.365939412585703E-9	DEFECT
//information about lazy properties of this class	WITHOUT_CLASSIFICATION	0.9982864620513546	WITHOUT_CLASSIFICATION	0.0017135379486454133	DEFECT
//information about all properties in class hierarchy	WITHOUT_CLASSIFICATION	0.999927254360987	WITHOUT_CLASSIFICATION	7.274563901302887E-5	DEFECT
//information about all columns/formulas in class hierarchy	WITHOUT_CLASSIFICATION	0.9999869993761149	WITHOUT_CLASSIFICATION	1.3000623885054096E-5	DEFECT
// dynamic filters attached to the class-level	WITHOUT_CLASSIFICATION	0.9999986573475846	WITHOUT_CLASSIFICATION	1.342652415362333E-6	DEFECT
// SQL strings	WITHOUT_CLASSIFICATION	0.9999993941645648	WITHOUT_CLASSIFICATION	6.058354352826758E-7	DEFECT
// for objects that came in via update()	WITHOUT_CLASSIFICATION	0.9999999695483867	WITHOUT_CLASSIFICATION	3.045161337915349E-8	DEFECT
// PROPERTIES	WITHOUT_CLASSIFICATION	0.9999993176881365	WITHOUT_CLASSIFICATION	6.823118634709873E-7	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
// IDENTIFIER	WITHOUT_CLASSIFICATION	0.9999958669127098	WITHOUT_CLASSIFICATION	4.133087290100319E-6	DEFECT
// VERSION	WITHOUT_CLASSIFICATION	0.9999975935658107	WITHOUT_CLASSIFICATION	2.4064341892517765E-6	DEFECT
//WHERE STRING	WITHOUT_CLASSIFICATION	0.9999991047298487	WITHOUT_CLASSIFICATION	8.952701514270024E-7	DEFECT
// SUBCLASS PROPERTY CLOSURE	WITHOUT_CLASSIFICATION	0.9999996131648716	WITHOUT_CLASSIFICATION	3.8683512838350073E-7	DEFECT
//before add :-)	WITHOUT_CLASSIFICATION	0.9999910906064648	WITHOUT_CLASSIFICATION	8.90939353516011E-6	DEFECT
// Handle any filters applied to the class level	WITHOUT_CLASSIFICATION	0.9999999844712376	WITHOUT_CLASSIFICATION	1.552876235358027E-8	DEFECT
// only one-to-one is lazy fetched	WITHOUT_CLASSIFICATION	0.9999884394793137	WITHOUT_CLASSIFICATION	1.1560520686296098E-5	DEFECT
//note early exit here:	WITHOUT_CLASSIFICATION	0.9997712595369675	WITHOUT_CLASSIFICATION	2.2874046303248286E-4	DEFECT
// object have been loaded with setReadOnly(true); HHH-2236	WITHOUT_CLASSIFICATION	0.999980041085112	WITHOUT_CLASSIFICATION	1.9958914888056357E-5	DEFECT
// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!	WITHOUT_CLASSIFICATION	0.9983115277271842	WITHOUT_CLASSIFICATION	0.001688472272815775	DEFECT
//strip leading ", "	WITHOUT_CLASSIFICATION	0.9999998123177617	WITHOUT_CLASSIFICATION	1.8768223831364422E-7	DEFECT
//if there is no resulting row, return null	WITHOUT_CLASSIFICATION	0.9999736387138829	WITHOUT_CLASSIFICATION	2.6361286117156152E-5	DEFECT
//otherwise return the "hydrated" state (ie. associations are not resolved)	WITHOUT_CLASSIFICATION	0.9999996581080638	WITHOUT_CLASSIFICATION	3.4189193624224246E-7	DEFECT
//null owner ok??	WITHOUT_CLASSIFICATION	0.9999929798889684	WITHOUT_CLASSIFICATION	7.020111031543112E-6	DEFECT
// null sql means that the only lazy properties // are shared PK one-to-one associations which are // handled differently in the Type#nullSafeGet code...	WITHOUT_CLASSIFICATION	0.9999994203803937	WITHOUT_CLASSIFICATION	5.796196062582684E-7	DEFECT
// Create a new FROM node for the referenced class.	WITHOUT_CLASSIFICATION	0.9999998737584701	WITHOUT_CLASSIFICATION	1.2624152994518814E-7	DEFECT
// the difficulty here is exactly what do we update in order to // force the version to be incremented in the db...	WITHOUT_CLASSIFICATION	0.9999986569131607	WITHOUT_CLASSIFICATION	1.3430868392797114E-6	DEFECT
// performance op to avoid the array search	WITHOUT_CLASSIFICATION	0.9999999877014287	WITHOUT_CLASSIFICATION	1.2298571134549172E-8	DEFECT
// properly handle property-ref-based associations	WITHOUT_CLASSIFICATION	0.9999999606505818	WITHOUT_CLASSIFICATION	3.934941824269689E-8	DEFECT
//Enable for HHH-440, which we don't like:	WITHOUT_CLASSIFICATION	0.9999926153915838	WITHOUT_CLASSIFICATION	7.38460841619396E-6	DEFECT
// ALIASES	WITHOUT_CLASSIFICATION	0.9999932016228787	WITHOUT_CLASSIFICATION	6.798377121269156E-6	DEFECT
// aliases named identifier ( alias.idname )	WITHOUT_CLASSIFICATION	0.999999992962789	WITHOUT_CLASSIFICATION	7.037211128741256E-9	DEFECT
// aliases for composite-id's	WITHOUT_CLASSIFICATION	0.9999999650765791	WITHOUT_CLASSIFICATION	3.492342104165448E-8	DEFECT
// Fetch embedded identifiers propertynames from the "virtual" identifier component	WITHOUT_CLASSIFICATION	0.9999999486695852	WITHOUT_CLASSIFICATION	5.133041483582218E-8	DEFECT
// embedded composite ids ( alias.idname1, alias.idname2 )	WITHOUT_CLASSIFICATION	0.999999959818195	WITHOUT_CLASSIFICATION	4.018180499894351E-8	DEFECT
// TODO: skip formulas?	WITHOUT_CLASSIFICATION	0.9989418137285737	WITHOUT_CLASSIFICATION	0.0010581862714262584	DEFECT
//don't need filters for the static loaders	WITHOUT_CLASSIFICATION	0.9999981346786823	WITHOUT_CLASSIFICATION	1.8653213177747549E-6	DEFECT
//do two passes, for collection property-ref!	WITHOUT_CLASSIFICATION	0.9997291929502494	WITHOUT_CLASSIFICATION	2.7080704975054713E-4	DEFECT
// select the correct row by either pk or rowid	WITHOUT_CLASSIFICATION	0.9999437227734342	WITHOUT_CLASSIFICATION	5.627722656569426E-5	DEFECT
//TODO: eventually, rowIdName[j]	WITHOUT_CLASSIFICATION	0.9378749030938923	WITHOUT_CLASSIFICATION	0.06212509690610775	DEFECT
// this is a property of the table, which we are updating	WITHOUT_CLASSIFICATION	0.9999873993429046	WITHOUT_CLASSIFICATION	1.2600657095372429E-5	DEFECT
// special shortcut for id properties, skip the join! // this must only occur at the _end_ of a path expression	WITHOUT_CLASSIFICATION	0.9999510455945925	WITHOUT_CLASSIFICATION	4.895440540741533E-5	DEFECT
// we are using "all" or "dirty" property-based optimistic locking	WITHOUT_CLASSIFICATION	0.9999998541620616	WITHOUT_CLASSIFICATION	1.4583793838876655E-7	DEFECT
// nothing to do; even if the operand is a parameter, no way we could // infer an appropriate expected type here	WITHOUT_CLASSIFICATION	0.9999996799488625	WITHOUT_CLASSIFICATION	3.200511375641493E-7	DEFECT
// this property belongs on the table and is to be inserted	WITHOUT_CLASSIFICATION	0.9999725106034287	WITHOUT_CLASSIFICATION	2.7489396571279996E-5	DEFECT
// add normal properties	WITHOUT_CLASSIFICATION	0.9999999289359455	WITHOUT_CLASSIFICATION	7.106405447861266E-8	DEFECT
// add the discriminator	WITHOUT_CLASSIFICATION	0.9999999674037087	WITHOUT_CLASSIFICATION	3.259629134347899E-8	DEFECT
// more specifically : "? [op] datetime" //      1) if the operator is MINUS, the param needs to be of //          some datetime type //      2) if the operator is PLUS, the param needs to be of //          some numeric type	WITHOUT_CLASSIFICATION	0.9999851819705952	WITHOUT_CLASSIFICATION	1.481802940476434E-5	DEFECT
// add normal properties	WITHOUT_CLASSIFICATION	0.9999999289359455	WITHOUT_CLASSIFICATION	7.106405447861266E-8	DEFECT
// this property belongs on the table and is to be inserted	WITHOUT_CLASSIFICATION	0.9999725106034287	WITHOUT_CLASSIFICATION	2.7489396571279996E-5	DEFECT
// add the discriminator	WITHOUT_CLASSIFICATION	0.9999999674037087	WITHOUT_CLASSIFICATION	3.259629134347899E-8	DEFECT
// add the primary key	WITHOUT_CLASSIFICATION	0.9999998291402827	WITHOUT_CLASSIFICATION	1.7085971724453628E-7	DEFECT
// delegate already handles PK columns	WITHOUT_CLASSIFICATION	0.9999999071539685	WITHOUT_CLASSIFICATION	9.28460315458383E-8	DEFECT
// we can't batch joined inserts, *especially* not if it is an identity insert; // nor can we batch statements where the expectation is based on an output param	WITHOUT_CLASSIFICATION	0.9999984000454899	WITHOUT_CLASSIFICATION	1.5999545101623763E-6	DEFECT
// Render the SQL query	WITHOUT_CLASSIFICATION	0.9999780445096251	WITHOUT_CLASSIFICATION	2.1955490374934322E-5	DEFECT
// Write the values of fields onto the prepared statement - we MUST use the state at the time the // insert was issued (cos of foreign key constraints). Not necessarily the object's current state	WITHOUT_CLASSIFICATION	0.9999998277517407	WITHOUT_CLASSIFICATION	1.7224825935391388E-7	DEFECT
// TODO : shouldnt inserts be Expectations.NONE?	WITHOUT_CLASSIFICATION	0.7805337381670712	DEFECT	0.21946626183292883	WITHOUT_CLASSIFICATION
//don't bother trying to update, we know there is no row there yet	WITHOUT_CLASSIFICATION	0.9999655425622128	WITHOUT_CLASSIFICATION	3.445743778709124E-5	DEFECT
//if all fields are null, we might need to delete existing row	WITHOUT_CLASSIFICATION	0.9999746545954826	WITHOUT_CLASSIFICATION	2.5345404517303242E-5	DEFECT
//there is probably a row there, so try to update //if no rows were updated, we will find out	WITHOUT_CLASSIFICATION	0.9999999937033617	WITHOUT_CLASSIFICATION	6.296638393477187E-9	DEFECT
//note: updates to joined tables can't be batched...	WITHOUT_CLASSIFICATION	0.9998049203202326	WITHOUT_CLASSIFICATION	1.9507967976731705E-4	DEFECT
// starting index	WITHOUT_CLASSIFICATION	0.9999953682000287	WITHOUT_CLASSIFICATION	4.631799971387304E-6	DEFECT
//Now write the values of fields onto the prepared statement	WITHOUT_CLASSIFICATION	0.9999983580409785	WITHOUT_CLASSIFICATION	1.641959021604211E-6	DEFECT
// Write any appropriate versioning conditional parameters	WITHOUT_CLASSIFICATION	0.9998706624569446	WITHOUT_CLASSIFICATION	1.293375430553625E-4	DEFECT
//Render the SQL query	WITHOUT_CLASSIFICATION	0.99998373842965	WITHOUT_CLASSIFICATION	1.6261570349903332E-5	DEFECT
// Do the key. The key is immutable so we can use the _current_ object state - not necessarily // the state at the time the delete was issued	WITHOUT_CLASSIFICATION	0.9999993883751995	WITHOUT_CLASSIFICATION	6.116248004931448E-7	DEFECT
// We should use the _current_ object state (ie. after any updates that occurred during flush)	WITHOUT_CLASSIFICATION	0.9999988048959997	WITHOUT_CLASSIFICATION	1.1951040003325918E-6	DEFECT
// this property belongs to the table and it is not specifically // excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9999993623307594	WITHOUT_CLASSIFICATION	6.376692405931502E-7	DEFECT
//note: dirtyFields==null means we had no snapshot, and we couldn't get one using select-before-update //	WITHOUT_CLASSIFICATION	0.9999996178901498	WITHOUT_CLASSIFICATION	3.821098502430357E-7	DEFECT
// more specifically : "datetime [op] ?" //      1) if the operator is MINUS, we really cannot determine //          the expected type as either another datetime or //          numeric would be valid //      2) if the operator is PLUS, the param needs to be of //          some numeric type	WITHOUT_CLASSIFICATION	0.9999984348053751	WITHOUT_CLASSIFICATION	1.5651946249430603E-6	DEFECT
// For the case of dynamic-update="true", we need to generate the UPDATE SQL	WITHOUT_CLASSIFICATION	0.9999999928307882	WITHOUT_CLASSIFICATION	7.169211800689624E-9	DEFECT
// don't need to check laziness (dirty checking algorithm handles that)	WITHOUT_CLASSIFICATION	0.9999955011496722	WITHOUT_CLASSIFICATION	4.498850327835483E-6	DEFECT
// For the case of dynamic-update="false", or no snapshot, we use the static SQL	WITHOUT_CLASSIFICATION	0.9999999981243942	WITHOUT_CLASSIFICATION	1.875605846686205E-9	DEFECT
// if not "get", then try "is"	WITHOUT_CLASSIFICATION	0.9999874477614903	WITHOUT_CLASSIFICATION	1.2552238509677033E-5	DEFECT
// Now update only the tables with dirty properties (and the table with the version number)	WITHOUT_CLASSIFICATION	0.9999999953850466	WITHOUT_CLASSIFICATION	4.6149534631234755E-9	DEFECT
// For the case of dynamic-insert="true", we need to generate the INSERT SQL	WITHOUT_CLASSIFICATION	0.9999999902227427	WITHOUT_CLASSIFICATION	9.777257315305217E-9	DEFECT
// For the case of dynamic-insert="true", we need to generate the INSERT SQL	WITHOUT_CLASSIFICATION	0.9999999902227427	WITHOUT_CLASSIFICATION	9.777257315305217E-9	DEFECT
// For the case of dynamic-insert="false", use the static SQL	WITHOUT_CLASSIFICATION	0.9999999817546351	WITHOUT_CLASSIFICATION	1.8245364909688053E-8	DEFECT
// For the case of dynamic-insert="false", use the static SQL	WITHOUT_CLASSIFICATION	0.9999999817546351	WITHOUT_CLASSIFICATION	1.8245364909688053E-8	DEFECT
// not supported	WITHOUT_CLASSIFICATION	0.9999975246239325	WITHOUT_CLASSIFICATION	2.4753760675872265E-6	DEFECT
// this property belongs to the table and it is not specifically // excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9999993623307594	WITHOUT_CLASSIFICATION	6.376692405931502E-7	DEFECT
// we need to utilize dynamic delete statements	WITHOUT_CLASSIFICATION	0.9999999921000221	WITHOUT_CLASSIFICATION	7.899977834478042E-9	DEFECT
// otherwise, utilize the static delete statements	WITHOUT_CLASSIFICATION	0.999999999744301	WITHOUT_CLASSIFICATION	2.5569896373367664E-10	DEFECT
//just a performance opt!	WITHOUT_CLASSIFICATION	0.9999999821901381	WITHOUT_CLASSIFICATION	1.7809861899381725E-8	DEFECT
//just a performance opt!	WITHOUT_CLASSIFICATION	0.9999999821901381	WITHOUT_CLASSIFICATION	1.7809861899381725E-8	DEFECT
//all joins join to the pk of the driving table	WITHOUT_CLASSIFICATION	0.9999987614691288	WITHOUT_CLASSIFICATION	1.2385308712631972E-6	DEFECT
//notice that we skip the first table; it is the driving table!	WITHOUT_CLASSIFICATION	0.9999997992038242	WITHOUT_CLASSIFICATION	2.007961758574542E-7	DEFECT
//we can inner join to superclass tables (the row MUST be there) //we can never inner join to subclass tables	WITHOUT_CLASSIFICATION	0.9999999979888166	WITHOUT_CLASSIFICATION	2.011183381087893E-9	DEFECT
//skip the driving table	WITHOUT_CLASSIFICATION	0.9999999569544352	WITHOUT_CLASSIFICATION	4.30455647258615E-8	DEFECT
//get 'em in the right order (not that it really matters)	WITHOUT_CLASSIFICATION	0.9982036889223507	WITHOUT_CLASSIFICATION	0.0017963110776493135	DEFECT
// here, we work under the following assumptions: //      ------------ valid cases -------------------------------------- //      1) datetime + {something other than datetime} : always results //              in a datetime ( db will catch invalid conversions ) //      2) datetime - datetime : always results in a DOUBLE //      3) datetime - {something other than datetime} : always results //              in a datetime ( db will catch invalid conversions ) //      ------------ invalid cases ------------------------------------ //      4) datetime + datetime //      5) {something other than datetime} - datetime //      6) datetime * {any type} //      7) datetime / {any type} //      8) {any type} / datetime // doing so allows us to properly handle parameters as either the left // or right side here in the majority of cases	WITHOUT_CLASSIFICATION	0.9271102700676136	WITHOUT_CLASSIFICATION	0.07288972993238638	DEFECT
//render the where and from parts	WITHOUT_CLASSIFICATION	0.9999936308270493	WITHOUT_CLASSIFICATION	6.369172950656431E-6	DEFECT
//we *could* regerate this inside each called method!	WITHOUT_CLASSIFICATION	0.9999780116231847	WITHOUT_CLASSIFICATION	2.198837681530294E-5	DEFECT
//now render the joins	WITHOUT_CLASSIFICATION	0.999988626239262	WITHOUT_CLASSIFICATION	1.1373760738013197E-5	DEFECT
// This will add the new from element to the origin.	WITHOUT_CLASSIFICATION	0.9999949986080908	WITHOUT_CLASSIFICATION	5.0013919091267765E-6	DEFECT
//now render the select clause	WITHOUT_CLASSIFICATION	0.999998423277449	WITHOUT_CLASSIFICATION	1.5767225509512431E-6	DEFECT
//now tie it all together	WITHOUT_CLASSIFICATION	0.9999989106003335	WITHOUT_CLASSIFICATION	1.0893996665044104E-6	DEFECT
//insert/update/delete SQL	WITHOUT_CLASSIFICATION	0.9999997464165337	WITHOUT_CLASSIFICATION	2.535834664315314E-7	DEFECT
//select SQL	WITHOUT_CLASSIFICATION	0.9999995073107223	WITHOUT_CLASSIFICATION	4.926892776216258E-7	DEFECT
//no need to check laziness, dirty checking handles that	WITHOUT_CLASSIFICATION	0.9999999659262028	WITHOUT_CLASSIFICATION	3.4073797246460994E-8	DEFECT
// Fully resolve the map reference, create implicit joins.	WITHOUT_CLASSIFICATION	0.9999990227082098	WITHOUT_CLASSIFICATION	9.772917901639706E-7	DEFECT
// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965880943033	WITHOUT_CLASSIFICATION	3.4119056967041506E-6	DEFECT
// The basic implementation is to simply use the node's text	WITHOUT_CLASSIFICATION	0.9999994234768689	WITHOUT_CLASSIFICATION	5.765231311639753E-7	DEFECT
// for dialects which are known to not support ANSI-SQL row-value-constructor syntax, // we should mutate the tree.	WITHOUT_CLASSIFICATION	0.9999997990094008	WITHOUT_CLASSIFICATION	2.009905992363292E-7	DEFECT
// Due to the complexity in initializing the SelectClause, do not generate one here. // If it is not found; simply return null... // // Also, do not cache since it gets generated well after we are created.	WITHOUT_CLASSIFICATION	0.9999954670792313	WITHOUT_CLASSIFICATION	4.5329207686550625E-6	DEFECT
// check the version unsaved-value, if appropriate	WITHOUT_CLASSIFICATION	0.9999997171779451	WITHOUT_CLASSIFICATION	2.8282205481548386E-7	DEFECT
// let this take precedence if defined, since it works for // assigned identifiers	WITHOUT_CLASSIFICATION	0.9999990352335276	WITHOUT_CLASSIFICATION	9.647664723970026E-7	DEFECT
// check the id unsaved-value	WITHOUT_CLASSIFICATION	0.9999998912228153	WITHOUT_CLASSIFICATION	1.0877718473916032E-7	DEFECT
// check to see if it is in the second-level cache	WITHOUT_CLASSIFICATION	0.9999995763471032	WITHOUT_CLASSIFICATION	4.2365289676473346E-7	DEFECT
///////////////////////////////////////////////////////////////////////	WITHOUT_CLASSIFICATION	0.9999716818625526	WITHOUT_CLASSIFICATION	2.831813744743344E-5	DEFECT
// For property references generate <tablealias>.<columnname> as <projectionalias>	WITHOUT_CLASSIFICATION	0.9999999072100076	WITHOUT_CLASSIFICATION	9.278999239249211E-8	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
//if there is no resulting row, return null	WITHOUT_CLASSIFICATION	0.9999736387138829	WITHOUT_CLASSIFICATION	2.6361286117156152E-5	DEFECT
//force immediate execution of the insert	WITHOUT_CLASSIFICATION	0.9999986477873927	WITHOUT_CLASSIFICATION	1.352212607295159E-6	DEFECT
// If this from element is a collection and the path is a collection property (maxIndex, etc.) then // generate a sub-query.	WITHOUT_CLASSIFICATION	0.9997156355862022	WITHOUT_CLASSIFICATION	2.8436441379785135E-4	DEFECT
// entities ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999998107068055	WITHOUT_CLASSIFICATION	1.892931945040302E-6	DEFECT
// collections ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999869029545385	WITHOUT_CLASSIFICATION	1.3097045461501673E-5	DEFECT
//cannot occur	WITHOUT_CLASSIFICATION	0.9999969544734082	WITHOUT_CLASSIFICATION	3.0455265918058742E-6	DEFECT
//cannot occur	WITHOUT_CLASSIFICATION	0.9999969544734082	WITHOUT_CLASSIFICATION	3.0455265918058742E-6	DEFECT
// only carry on if the method has no parameters	WITHOUT_CLASSIFICATION	0.9999748068321702	WITHOUT_CLASSIFICATION	2.519316782975829E-5	DEFECT
// try "get"	WITHOUT_CLASSIFICATION	0.9999955181511587	WITHOUT_CLASSIFICATION	4.481848841307734E-6	DEFECT
// do nothing...	WITHOUT_CLASSIFICATION	0.9997982291101098	WITHOUT_CLASSIFICATION	2.017708898902458E-4	DEFECT
// do nothing...	WITHOUT_CLASSIFICATION	0.9997982291101098	WITHOUT_CLASSIFICATION	2.017708898902458E-4	DEFECT
// should be safe to only ever expect EntityPersister references here	WITHOUT_CLASSIFICATION	0.9999370729412621	WITHOUT_CLASSIFICATION	6.292705873796565E-5	DEFECT
// this page intentionally left blank :)	WITHOUT_CLASSIFICATION	0.9999544106219022	WITHOUT_CLASSIFICATION	4.558937809779881E-5	DEFECT
// do not do anything	WITHOUT_CLASSIFICATION	0.9999420177933648	WITHOUT_CLASSIFICATION	5.798220663518189E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// ignore	WITHOUT_CLASSIFICATION	0.9999996022307994	WITHOUT_CLASSIFICATION	3.977692004945396E-7	DEFECT
//cant instantiate	WITHOUT_CLASSIFICATION	0.9999985174476956	WITHOUT_CLASSIFICATION	1.4825523043228555E-6	DEFECT
//if it is a property of an embedded component, invoke on the "identifier"	WITHOUT_CLASSIFICATION	0.9999995487246978	WITHOUT_CLASSIFICATION	4.5127530216126963E-7	DEFECT
// otherwise:	WITHOUT_CLASSIFICATION	0.9999998403756611	WITHOUT_CLASSIFICATION	1.5962433878299623E-7	DEFECT
// skip finalize methods	WITHOUT_CLASSIFICATION	0.9999996462141099	WITHOUT_CLASSIFICATION	3.537858901481901E-7	DEFECT
// note: interfaces is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.9999731054050053	WITHOUT_CLASSIFICATION	2.6894594994660976E-5	DEFECT
// note: interfaces is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.9999731054050053	WITHOUT_CLASSIFICATION	2.6894594994660976E-5	DEFECT
// HHH-2481 make sure the callback gets cleared, otherwise the instance stays in a static thread local.	WITHOUT_CLASSIFICATION	0.9999942353915033	WITHOUT_CLASSIFICATION	5.764608496586203E-6	DEFECT
// while constructor is running	WITHOUT_CLASSIFICATION	0.9999999157084737	WITHOUT_CLASSIFICATION	8.429152631092393E-8	DEFECT
// while constructor is running	WITHOUT_CLASSIFICATION	0.9999999157084737	WITHOUT_CLASSIFICATION	8.429152631092393E-8	DEFECT
// note: interface is assumed to already contain HibernateProxy.class	WITHOUT_CLASSIFICATION	0.9999945348523254	WITHOUT_CLASSIFICATION	5.465147674721084E-6	DEFECT
// interfaces // arguments	WITHOUT_CLASSIFICATION	0.9999999849729642	WITHOUT_CLASSIFICATION	1.5027035849110197E-8	DEFECT
//TODO!	WITHOUT_CLASSIFICATION	0.9971200758760632	WITHOUT_CLASSIFICATION	0.002879924123936873	DEFECT
// Get the caller	WITHOUT_CLASSIFICATION	0.9999998471054632	WITHOUT_CLASSIFICATION	1.528945368628131E-7	DEFECT
// Get the caller principals	WITHOUT_CLASSIFICATION	0.9999999463181188	WITHOUT_CLASSIFICATION	5.3681881064333604E-8	DEFECT
//private static final Alias DEFAULT_ALIAS = new Alias(10, null);	WITHOUT_CLASSIFICATION	0.9999998683490394	WITHOUT_CLASSIFICATION	1.316509605486789E-7	DEFECT
// Needed to bump this up to DotNode, because that is the only thing which currently // knows about the property-ref path in the correct format; it is either this, or // recurse over the DotNodes constructing the property path just like DotNode does // internally	WITHOUT_CLASSIFICATION	0.9999999706017277	WITHOUT_CLASSIFICATION	2.9398272234815142E-8	DEFECT
//if the identifier is quoted, remove the quotes	WITHOUT_CLASSIFICATION	0.9999991765369304	WITHOUT_CLASSIFICATION	8.234630695454919E-7	DEFECT
//truncate the identifier to the max alias length, less the suffix length	WITHOUT_CLASSIFICATION	0.9999999801752145	WITHOUT_CLASSIFICATION	1.982478558567954E-8	DEFECT
//full joins are not supported.. yet!	WITHOUT_CLASSIFICATION	0.99527158311579	WITHOUT_CLASSIFICATION	0.004728416884210009	DEFECT
// null is not considered the same type as Integer. //$NON-NLS-1 //$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999860264003867	WITHOUT_CLASSIFICATION	1.3973599613240505E-5	DEFECT
// the outerJoinsAfterWhere needs to come before where clause to properly // handle dynamic filters	WITHOUT_CLASSIFICATION	0.9999967443035435	WITHOUT_CLASSIFICATION	3.2556964566370207E-6	DEFECT
//$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999904037695596	WITHOUT_CLASSIFICATION	9.59623044033645E-6	DEFECT
//$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999904037695596	WITHOUT_CLASSIFICATION	9.59623044033645E-6	DEFECT
//$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999904037695596	WITHOUT_CLASSIFICATION	9.59623044033645E-6	DEFECT
//$NON-NLS-1	WITHOUT_CLASSIFICATION	0.9999904037695596	WITHOUT_CLASSIFICATION	9.59623044033645E-6	DEFECT
// strip off any leading 'and' token	WITHOUT_CLASSIFICATION	0.9999934321344672	WITHOUT_CLASSIFICATION	6.567865532846306E-6	DEFECT
// if the condition is not already there...	WITHOUT_CLASSIFICATION	0.9562973317583595	WITHOUT_CLASSIFICATION	0.04370266824164045	DEFECT
//dontSpace.add("'");	WITHOUT_CLASSIFICATION	0.9999971863232876	WITHOUT_CLASSIFICATION	2.813676712380347E-6	DEFECT
//for MySQL	WITHOUT_CLASSIFICATION	0.9999908866621839	WITHOUT_CLASSIFICATION	9.113337816081504E-6	DEFECT
//HashMap columnsUnique = new HashMap();	WITHOUT_CLASSIFICATION	0.9999999306003406	WITHOUT_CLASSIFICATION	6.939965931290577E-8	DEFECT
//null caused some problems	WITHOUT_CLASSIFICATION	0.9999031002845037	WITHOUT_CLASSIFICATION	9.689971549635769E-5	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
//not sure if this would ever be null but wanted to be careful	WITHOUT_CLASSIFICATION	0.9999993258506467	WITHOUT_CLASSIFICATION	6.741493532902053E-7	DEFECT
//even on inverse="true"	WITHOUT_CLASSIFICATION	0.999999129172835	WITHOUT_CLASSIFICATION	8.708271651272771E-7	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
// If true then execute db updates, otherwise just generate and display updates	WITHOUT_CLASSIFICATION	0.9999999856698087	WITHOUT_CLASSIFICATION	1.4330191187986702E-8	DEFECT
// we only release the connection	WITHOUT_CLASSIFICATION	0.9999992521089682	WITHOUT_CLASSIFICATION	7.478910317691138E-7	DEFECT
// deprecated option...	WITHOUT_CLASSIFICATION	0.9999993138623028	WITHOUT_CLASSIFICATION	6.861376972789022E-7	DEFECT
//if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9999972068797407	WITHOUT_CLASSIFICATION	2.7931202594071813E-6	DEFECT
//actually, this last test is probably unnecessary, since  //beforeCompletion() doesn't get called during rollback	WITHOUT_CLASSIFICATION	0.9999799328404894	WITHOUT_CLASSIFICATION	2.006715951069849E-5	DEFECT
// this one only really needed for badly-behaved applications! // (if the TransactionManager has a Sychronization registered, // its a noop) // (actually we do need it for downgrading locks)	WITHOUT_CLASSIFICATION	0.9999992718568544	WITHOUT_CLASSIFICATION	7.281431456155849E-7	DEFECT
// Create an DotNode AST for the path and resolve it.	WITHOUT_CLASSIFICATION	0.9999997126549356	WITHOUT_CLASSIFICATION	2.8734506434581457E-7	DEFECT
//if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9999972068797407	WITHOUT_CLASSIFICATION	2.7931202594071813E-6	DEFECT
//if we could not register a synchronization, //do the before/after completion callbacks //ourself (but we need to let jdbcContext //know that this is what we are going to //do, so it doesn't keep trying to register //synchronizations)	WITHOUT_CLASSIFICATION	0.9997908847163539	WITHOUT_CLASSIFICATION	2.091152836459494E-4	DEFECT
// swallow it, and continue to roll back JTA transaction	WITHOUT_CLASSIFICATION	0.9999843319851349	WITHOUT_CLASSIFICATION	1.566801486510562E-5	DEFECT
// so the transaction is already rolled back, by JTA spec	WITHOUT_CLASSIFICATION	0.9999988997918489	WITHOUT_CLASSIFICATION	1.1002081511681006E-6	DEFECT
// this method is a noop if there is a Synchronization!	WITHOUT_CLASSIFICATION	0.9999960256909358	WITHOUT_CLASSIFICATION	3.974309064147427E-6	DEFECT
// two conditions where we need to transform this to a theta-join syntax: //      1) 'elem' is the "root from-element" in correlated subqueries //      2) The DotNode.useThetaStyleImplicitJoins has been set to true //          and 'elem' represents an implicit join	WITHOUT_CLASSIFICATION	0.999985652663534	WITHOUT_CLASSIFICATION	1.4347336465840807E-5	DEFECT
// WebSphere, however, is not a sane JEE/JTA container...	WITHOUT_CLASSIFICATION	0.9998818037908141	WITHOUT_CLASSIFICATION	1.1819620918576267E-4	DEFECT
// for sane JEE/JTA containers, the transaction itself functions as its identifier...	WITHOUT_CLASSIFICATION	0.9999999047244418	WITHOUT_CLASSIFICATION	9.52755581807648E-8	DEFECT
//swallow, the transaction was finished	WITHOUT_CLASSIFICATION	0.9999778769220765	WITHOUT_CLASSIFICATION	2.2123077923555017E-5	DEFECT
// all AliasToEntityMapResultTransformer are considered equal ~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999571837203	WITHOUT_CLASSIFICATION	4.2816279675437384E-8	DEFECT
// Create the join element under the from element.	WITHOUT_CLASSIFICATION	0.9999996433511098	WITHOUT_CLASSIFICATION	3.566488901539091E-7	DEFECT
// all DistinctRootEntityResultTransformer are considered equal ~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.999999967966385	WITHOUT_CLASSIFICATION	3.203361495648395E-8	DEFECT
// map of EntityMode -> Tuplizer	WITHOUT_CLASSIFICATION	0.9999999151003788	WITHOUT_CLASSIFICATION	8.48996212643401E-8	DEFECT
// this is a virtual id property...	WITHOUT_CLASSIFICATION	0.9960607870499991	WITHOUT_CLASSIFICATION	0.0039392129500008515	DEFECT
//this one needed only for guessEntityMode()	WITHOUT_CLASSIFICATION	0.9999923993271038	WITHOUT_CLASSIFICATION	7.600672896217883E-6	DEFECT
// create our own copy of the user-supplied tuplizer impl map	WITHOUT_CLASSIFICATION	0.9999995498699911	WITHOUT_CLASSIFICATION	4.5013000893870166E-7	DEFECT
// todo : move this to SF per HHH-3517; also see HHH-1907 and ComponentMetamodel	WITHOUT_CLASSIFICATION	0.9999947492685897	WITHOUT_CLASSIFICATION	5.250731410274947E-6	DEFECT
// then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available	WITHOUT_CLASSIFICATION	0.9999999884383646	WITHOUT_CLASSIFICATION	1.156163538808401E-8	DEFECT
// Build the dynamic-map tuplizer...	WITHOUT_CLASSIFICATION	0.9999509390996197	WITHOUT_CLASSIFICATION	4.9060900380270044E-5	DEFECT
// then dom4j tuplizer, if dom4j representation is available	WITHOUT_CLASSIFICATION	0.9999999724179889	WITHOUT_CLASSIFICATION	2.7582011092323096E-8	DEFECT
// Build the dynamic-map tuplizer...	WITHOUT_CLASSIFICATION	0.9999509390996197	WITHOUT_CLASSIFICATION	4.9060900380270044E-5	DEFECT
// put the "standard" tuplizers into the tuplizer map first	WITHOUT_CLASSIFICATION	0.9999999747971874	WITHOUT_CLASSIFICATION	2.520281256885989E-8	DEFECT
// found a ctor, but it was not publicly accessible so try to request accessibility	WITHOUT_CLASSIFICATION	0.9999986908311282	WITHOUT_CLASSIFICATION	1.3091688717853598E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// cached for efficiency...	WITHOUT_CLASSIFICATION	0.9998743386562637	WITHOUT_CLASSIFICATION	1.256613437362276E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//it was not embedded, so the argument is just an id	WITHOUT_CLASSIFICATION	0.9999998834065773	WITHOUT_CLASSIFICATION	1.1659342275920912E-7	DEFECT
// then the pojo tuplizer, using the dynamic-map tuplizer if no pojo representation is available	WITHOUT_CLASSIFICATION	0.9999999884383646	WITHOUT_CLASSIFICATION	1.156163538808401E-8	DEFECT
// then dom4j tuplizer, if dom4j representation is available	WITHOUT_CLASSIFICATION	0.9999999724179889	WITHOUT_CLASSIFICATION	2.7582011092323096E-8	DEFECT
// put the "standard" tuplizers into the tuplizer map first	WITHOUT_CLASSIFICATION	0.9999999747971874	WITHOUT_CLASSIFICATION	2.520281256885989E-8	DEFECT
// then handle any user-defined entity modes...	WITHOUT_CLASSIFICATION	0.9999998448500933	WITHOUT_CLASSIFICATION	1.5514990676260776E-7	DEFECT
//return currentId;	WITHOUT_CLASSIFICATION	0.9999874208703189	WITHOUT_CLASSIFICATION	1.2579129681195433E-5	DEFECT
//reset the id	WITHOUT_CLASSIFICATION	0.9999976270684411	WITHOUT_CLASSIFICATION	2.3729315589436964E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//reset the version	WITHOUT_CLASSIFICATION	0.9999929836130653	WITHOUT_CLASSIFICATION	7.016386934651829E-6	DEFECT
// the default is to simply not lazy fetch properties for now...	WITHOUT_CLASSIFICATION	0.9972613534226689	WITHOUT_CLASSIFICATION	0.0027386465773311572	DEFECT
// Add the second join, the one that ends in the destination table.	WITHOUT_CLASSIFICATION	0.9999999899432068	WITHOUT_CLASSIFICATION	1.0056793228634826E-8	DEFECT
// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965880943033	WITHOUT_CLASSIFICATION	3.4119056967041506E-6	DEFECT
// found a ctor, but it was not publicly accessible so try to request accessibility	WITHOUT_CLASSIFICATION	0.9999986908311282	WITHOUT_CLASSIFICATION	1.3091688717853598E-6	DEFECT
// determine the id getter and setter methods from the proxy interface (if any) // determine all interfaces needed by the resulting proxy	WITHOUT_CLASSIFICATION	0.9999944329280717	WITHOUT_CLASSIFICATION	5.567071928380812E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//not final because proxy factory creation can fail	WITHOUT_CLASSIFICATION	0.9994438774935182	WITHOUT_CLASSIFICATION	5.56122506481812E-4	DEFECT
// superclass entity-name	WITHOUT_CLASSIFICATION	0.9999999441918338	WITHOUT_CLASSIFICATION	5.580816634284482E-8	DEFECT
// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965880943033	WITHOUT_CLASSIFICATION	3.4119056967041506E-6	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
//init the aliases, after initing the constructornode	WITHOUT_CLASSIFICATION	0.9999999390705226	WITHOUT_CLASSIFICATION	6.092947731694533E-8	DEFECT
// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965880943033	WITHOUT_CLASSIFICATION	3.4119056967041506E-6	DEFECT
// legacy behavior (with no abstract attribute specified)	WITHOUT_CLASSIFICATION	0.9999999952895	WITHOUT_CLASSIFICATION	4.710499950233472E-9	DEFECT
// Get ready to start adding nodes.	WITHOUT_CLASSIFICATION	0.9999996425880165	WITHOUT_CLASSIFICATION	3.5741198345878837E-7	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
//note: this affects the return value!	WITHOUT_CLASSIFICATION	0.9997431973022886	WITHOUT_CLASSIFICATION	2.5680269771142443E-4	DEFECT
// Need to account for allowable '_' within the variant	WITHOUT_CLASSIFICATION	0.9999999717226036	WITHOUT_CLASSIFICATION	2.8277396346596802E-8	DEFECT
// Add the type to the list of returned sqlResultTypes.	WITHOUT_CLASSIFICATION	0.9999999527720561	WITHOUT_CLASSIFICATION	4.7227943992324075E-8	DEFECT
// Collection Types:	WITHOUT_CLASSIFICATION	0.9999982655087043	WITHOUT_CLASSIFICATION	1.7344912956962687E-6	DEFECT
// convenience methods relating to operations across arrays of types...	WITHOUT_CLASSIFICATION	0.9998267874537615	WITHOUT_CLASSIFICATION	1.7321254623841201E-4	DEFECT
//lobs cannot be compared	WITHOUT_CLASSIFICATION	0.9999892397202566	WITHOUT_CLASSIFICATION	1.0760279743388217E-5	DEFECT
//Blobs are ignored by merge()	WITHOUT_CLASSIFICATION	0.999999935506635	WITHOUT_CLASSIFICATION	6.449336505436676E-8	DEFECT
//value is the entity name	WITHOUT_CLASSIFICATION	0.9999986817039618	WITHOUT_CLASSIFICATION	1.3182960381666952E-6	DEFECT
//EARLY EXIT!	WITHOUT_CLASSIFICATION	0.9999655062189466	WITHOUT_CLASSIFICATION	3.449378105341125E-5	DEFECT
// generate id select fragment and then property select fragment for // each expression, just like generateSelectFragments().	WITHOUT_CLASSIFICATION	0.9999979770623229	WITHOUT_CLASSIFICATION	2.0229376771631063E-6	DEFECT
//TODO!	WITHOUT_CLASSIFICATION	0.9971200758760632	WITHOUT_CLASSIFICATION	0.002879924123936873	DEFECT
//xml is the entity name	WITHOUT_CLASSIFICATION	0.9999980114067027	WITHOUT_CLASSIFICATION	1.988593297245754E-6	DEFECT
//special case ... this is the leaf of the containment graph, even though not immutable	WITHOUT_CLASSIFICATION	0.9916053321240771	WITHOUT_CLASSIFICATION	0.008394667875922898	DEFECT
//tolerates nulls	WITHOUT_CLASSIFICATION	0.9999987543921458	WITHOUT_CLASSIFICATION	1.2456078542311613E-6	DEFECT
/*sqlResultTypeList,*/	WITHOUT_CLASSIFICATION	0.9999431794855694	WITHOUT_CLASSIFICATION	5.68205144305439E-5	DEFECT
// metaType is assumed to be single-column type	WITHOUT_CLASSIFICATION	0.9999997814473954	WITHOUT_CLASSIFICATION	2.185526046855975E-7	DEFECT
// Get all the select expressions (that we just generated) and render the select.	WITHOUT_CLASSIFICATION	0.9999998697895905	WITHOUT_CLASSIFICATION	1.3021040942669714E-7	DEFECT
// Look through the FromElement's children to find any collections of values that should be fetched...	WITHOUT_CLASSIFICATION	0.9991937826787656	WITHOUT_CLASSIFICATION	8.062173212343916E-4	DEFECT
//return AssociationType.FOREIGN_KEY_TO_PARENT; //this is better but causes a transient object exception...	WITHOUT_CLASSIFICATION	0.9996217757333938	WITHOUT_CLASSIFICATION	3.782242666061272E-4	DEFECT
// Use the lower case function name. // Remember whether we're in a SELECT clause or not.	WITHOUT_CLASSIFICATION	0.9999999783793492	WITHOUT_CLASSIFICATION	2.1620650862284768E-8	DEFECT
// IDENT might be the name of a class.	WITHOUT_CLASSIFICATION	0.9999905718820693	WITHOUT_CLASSIFICATION	9.428117930639502E-6	DEFECT
//TODO!!!	WITHOUT_CLASSIFICATION	0.996825572217895	WITHOUT_CLASSIFICATION	0.003174427782105019	DEFECT
//st.setTimestamp( index,  new Timestamp( cal.getTimeInMillis() ), cal ); //JDK 1.5 only	WITHOUT_CLASSIFICATION	0.9999398752070117	WITHOUT_CLASSIFICATION	6.012479298838416E-5	DEFECT
//st.setDate( index,  new Date( cal.getTimeInMillis() ), cal ); //JDK 1.5 only	WITHOUT_CLASSIFICATION	0.999972956947716	WITHOUT_CLASSIFICATION	2.7043052283890913E-5	DEFECT
// both are Timestamps	WITHOUT_CLASSIFICATION	0.9999999892718106	WITHOUT_CLASSIFICATION	1.0728189477601156E-8	DEFECT
// at least one is a plain old Date	WITHOUT_CLASSIFICATION	0.999999698815732	WITHOUT_CLASSIFICATION	3.011842679031377E-7	DEFECT
//noop	WITHOUT_CLASSIFICATION	0.9999060456973579	WITHOUT_CLASSIFICATION	9.395430264206286E-5	DEFECT
// if the corresponding SQL value is NULL, the reader we got is NULL as well	WITHOUT_CLASSIFICATION	0.9999956134679238	WITHOUT_CLASSIFICATION	4.38653207633417E-6	DEFECT
// Fetch Reader content up to the end - and put characters in a StringBuffer	WITHOUT_CLASSIFICATION	0.9999998262386165	WITHOUT_CLASSIFICATION	1.7376138344007295E-7	DEFECT
// Return StringBuffer content as a large String	WITHOUT_CLASSIFICATION	0.9999991729403844	WITHOUT_CLASSIFICATION	8.270596155288081E-7	DEFECT
//or Types.LONGVARCHAR?	WITHOUT_CLASSIFICATION	0.9999995541982192	WITHOUT_CLASSIFICATION	4.4580178082224276E-7	DEFECT
//Not called at runtime so doesn't matter if its slow :)	WITHOUT_CLASSIFICATION	0.9985986328067984	WITHOUT_CLASSIFICATION	0.0014013671932016564	DEFECT
//TODO	WITHOUT_CLASSIFICATION	0.9997342756553311	WITHOUT_CLASSIFICATION	2.657243446689062E-4	DEFECT
// Chop off the rest of the tree.	WITHOUT_CLASSIFICATION	0.9999998273483314	WITHOUT_CLASSIFICATION	1.7265166866209452E-7	DEFECT
//different nullability rules for pk/fk	WITHOUT_CLASSIFICATION	0.999976374342208	WITHOUT_CLASSIFICATION	2.3625657792134647E-5	DEFECT
//cache this	WITHOUT_CLASSIFICATION	0.9999984720791955	WITHOUT_CLASSIFICATION	1.5279208046094517E-6	DEFECT
//only really need new array during semiresolve!	WITHOUT_CLASSIFICATION	0.9999689457390724	WITHOUT_CLASSIFICATION	3.10542609276648E-5	DEFECT
// Forcefully remove leading ands from where fragments; the grammar will // handle adding them	WITHOUT_CLASSIFICATION	0.9999465890359097	WITHOUT_CLASSIFICATION	5.341096409015108E-5	DEFECT
//TODO!!!!!!!	WITHOUT_CLASSIFICATION	0.9982468805729569	WITHOUT_CLASSIFICATION	0.0017531194270431459	DEFECT
// Create a new FILTERS node as a parent of all filters	WITHOUT_CLASSIFICATION	0.9999994043401526	WITHOUT_CLASSIFICATION	5.95659847411127E-7	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
//public Object instantiate(Object parent, SessionImplementor session) throws HibernateException;	WITHOUT_CLASSIFICATION	0.9999888002841282	WITHOUT_CLASSIFICATION	1.1199715871780856E-5	DEFECT
//nothing to do	WITHOUT_CLASSIFICATION	0.999987160751243	WITHOUT_CLASSIFICATION	1.2839248756864844E-5	DEFECT
//nothing to do	WITHOUT_CLASSIFICATION	0.999987160751243	WITHOUT_CLASSIFICATION	1.2839248756864844E-5	DEFECT
// VersionType impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //      Note : simply returns null for seed() and next() as the only known //      application of binary types for versioning is for use with the //      TIMESTAMP datatype supported by Sybase and SQL Server, which //      are completely db-generated values...	WITHOUT_CLASSIFICATION	0.9995297065072912	WITHOUT_CLASSIFICATION	4.702934927088408E-4	DEFECT
//lobs cannot be compared	WITHOUT_CLASSIFICATION	0.9999892397202566	WITHOUT_CLASSIFICATION	1.0760279743388217E-5	DEFECT
//not really necessary, I guess...	WITHOUT_CLASSIFICATION	0.9997911706912556	WITHOUT_CLASSIFICATION	2.088293087443719E-4	DEFECT
//Clobs are ignored by merge() operation	WITHOUT_CLASSIFICATION	0.9999999879638017	WITHOUT_CLASSIFICATION	1.2036198253895308E-8	DEFECT
// we do not have to worry about queued additions to uninitialized // collections, since they can only occur for inverse collections!	WITHOUT_CLASSIFICATION	0.9999472881180118	WITHOUT_CLASSIFICATION	5.2711881988274106E-5	DEFECT
// collections cannot be compared	WITHOUT_CLASSIFICATION	0.999975023712316	WITHOUT_CLASSIFICATION	2.4976287684129295E-5	DEFECT
//remember the uk value	WITHOUT_CLASSIFICATION	0.9999967626381964	WITHOUT_CLASSIFICATION	3.2373618036731436E-6	DEFECT
//NOOP	WITHOUT_CLASSIFICATION	0.9999713599925291	WITHOUT_CLASSIFICATION	2.864000747092318E-5	DEFECT
//processCollectionProperty(token, q.getCollectionPersister(collectionRole), collectionName);	WITHOUT_CLASSIFICATION	0.999989291594566	WITHOUT_CLASSIFICATION	1.070840543400072E-5	DEFECT
//we must use the "remembered" uk value, since it is  //not available from the EntityEntry during assembly	WITHOUT_CLASSIFICATION	0.9999999677139897	WITHOUT_CLASSIFICATION	3.2286010357064554E-8	DEFECT
// collections don't dirty an unversioned parent entity	WITHOUT_CLASSIFICATION	0.999999287386241	WITHOUT_CLASSIFICATION	7.126137590821116E-7	DEFECT
// return false;	WITHOUT_CLASSIFICATION	0.9999995446032757	WITHOUT_CLASSIFICATION	4.553967242981957E-7	DEFECT
// This just handles a particular case of component // projection, perhaps get rid of it and throw an exception	WITHOUT_CLASSIFICATION	0.99999989020195	WITHOUT_CLASSIFICATION	1.0979805009173916E-7	DEFECT
//NOTE: we avoid joining to the next table if the named property is just the foreign key value	WITHOUT_CLASSIFICATION	0.9999999808157779	WITHOUT_CLASSIFICATION	1.9184222191721672E-8	DEFECT
// the key is the owning entity itself, so get the ID from the key	WITHOUT_CLASSIFICATION	0.9999998990005827	WITHOUT_CLASSIFICATION	1.0099941723243969E-7	DEFECT
// if the original is a PersistentCollection, and that original // was not flagged as dirty, then reset the target's dirty flag // here after the copy operation. // </p> // One thing to be careful of here is a "bare" original collection // in which case we should never ever ever reset the dirty flag // on the target because we simply do not know...	WITHOUT_CLASSIFICATION	0.9999997368749042	WITHOUT_CLASSIFICATION	2.6312509585421875E-7	DEFECT
//ignore subselect keywords	WITHOUT_CLASSIFICATION	0.9999995179603194	WITHOUT_CLASSIFICATION	4.820396805018292E-7	DEFECT
// copy elements into newly empty target collection	WITHOUT_CLASSIFICATION	0.9999999895894119	WITHOUT_CLASSIFICATION	1.0410588132694639E-8	DEFECT
// for a null target, or a target which is the same as the original, we // need to put the merged elements in a new collection	WITHOUT_CLASSIFICATION	0.9999999945125336	WITHOUT_CLASSIFICATION	5.487466421192301E-9	DEFECT
// by default just use an unanticipated capacity since we don't // know how to extract the capacity to use from original here...	WITHOUT_CLASSIFICATION	0.9999997671815345	WITHOUT_CLASSIFICATION	2.3281846551850667E-7	DEFECT
// get the elements back into the target making sure to handle dirty flag	WITHOUT_CLASSIFICATION	0.9999997917240357	WITHOUT_CLASSIFICATION	2.0827596417678224E-7	DEFECT
// check if collection is currently being loaded	WITHOUT_CLASSIFICATION	0.9999842327322367	WITHOUT_CLASSIFICATION	1.5767267763338066E-5	DEFECT
// check if it is already completely loaded, but unowned	WITHOUT_CLASSIFICATION	0.9999990343055429	WITHOUT_CLASSIFICATION	9.65694457037852E-7	DEFECT
// cache the actual id of the object, not the value of the // property-ref, which might not be initialized	WITHOUT_CLASSIFICATION	0.9999974645641346	WITHOUT_CLASSIFICATION	2.535435865342808E-6	DEFECT
//TODO!!!!!!!	WITHOUT_CLASSIFICATION	0.9982468805729569	WITHOUT_CLASSIFICATION	0.0017531194270431459	DEFECT
// create a new collection wrapper, to be initialized later	WITHOUT_CLASSIFICATION	0.9999991714365227	WITHOUT_CLASSIFICATION	8.285634772806112E-7	DEFECT
// Some JDBC drivers erroneously return an empty array here for a null DB value :/	WITHOUT_CLASSIFICATION	0.9999930101341272	WITHOUT_CLASSIFICATION	6.989865872884661E-6	DEFECT
// our column span is the number of columns in the PK	WITHOUT_CLASSIFICATION	0.9999992513662779	WITHOUT_CLASSIFICATION	7.48633722049567E-7	DEFECT
//cannot batch fetch by unique key (property-ref associations)	WITHOUT_CLASSIFICATION	0.9999865568854391	WITHOUT_CLASSIFICATION	1.3443114560828336E-5	DEFECT
// we already know current is not null...	WITHOUT_CLASSIFICATION	0.9725059426320851	WITHOUT_CLASSIFICATION	0.02749405736791483	DEFECT
// the ids are fully resolved, so compare them with isDirty(), not isModified()	WITHOUT_CLASSIFICATION	0.9999899611011077	WITHOUT_CLASSIFICATION	1.0038898892180841E-5	DEFECT
//the owner of the association is not the owner of the id	WITHOUT_CLASSIFICATION	0.9999967245965713	WITHOUT_CLASSIFICATION	3.2754034285652104E-6	DEFECT
// ----------------------------------------------------------- Constructors	WITHOUT_CLASSIFICATION	0.999999970755405	WITHOUT_CLASSIFICATION	2.9244594869546287E-8	DEFECT
// ----------------------------------------------------- Instance Variables	WITHOUT_CLASSIFICATION	0.9999998873265333	WITHOUT_CLASSIFICATION	1.1267346657629556E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// --------------------------------------------------------- Public Methods	WITHOUT_CLASSIFICATION	0.9999993092664502	WITHOUT_CLASSIFICATION	6.907335499077103E-7	DEFECT
// Compare the two maps for equality	WITHOUT_CLASSIFICATION	0.9999997384520841	WITHOUT_CLASSIFICATION	2.615479158835158E-7	DEFECT
// Simple tests that require no synchronization	WITHOUT_CLASSIFICATION	0.999992188658915	WITHOUT_CLASSIFICATION	7.811341084960267E-6	DEFECT
//Sybase fail if we don't do that, sigh...	WITHOUT_CLASSIFICATION	0.9961565562741054	WITHOUT_CLASSIFICATION	0.0038434437258945387	DEFECT
// Handles things like: // a and b or c // a and ( b or c ) // not a and not b // not ( a and b ) // x between y and z            (overloaded "and") // x in ( a, b, c )             (overloaded brackets) // not not a // a is not null                (overloaded "not") // etc...... // and expressions like // foo = bar                    (maps to: foo.id = bar.id) // foo.Bar = 'foo'              (maps to: foo.bar = 'foo') // foo.Bar.Baz = 1.0            (maps to: foo.bar = bar.id and bar.baz = 1.0) // 1.0 = foo.Bar.Baz            (maps to: bar.baz = 1.0 and foo.Bar = bar.id) // foo.Bar.Baz = a.B.C          (maps to: bar.Baz = b.C and foo.Bar = bar.id and a.B = b.id) // foo.Bar.Baz + a.B.C          (maps to: bar.Baz + b.C and foo.Bar = bar.id and a.B = b.id) // ( foo.Bar.Baz + 1.0 ) < 2.0  (maps to: ( bar.Baz + 1.0 ) < 2.0 and foo.Bar = bar.id)	WITHOUT_CLASSIFICATION	0.9976650903535244	WITHOUT_CLASSIFICATION	0.0023349096464756938	DEFECT
// release the jdk internal caches everytime to ensure this // plays nicely with destroyable class-loaders	WITHOUT_CLASSIFICATION	0.9999999961919619	WITHOUT_CLASSIFICATION	3.808038070769507E-9	DEFECT
// release the jdk internal caches everytime to ensure this // plays nicely with destroyable class-loaders	WITHOUT_CLASSIFICATION	0.9999999961919619	WITHOUT_CLASSIFICATION	3.808038070769507E-9	DEFECT
// try to "pretty print" it	WITHOUT_CLASSIFICATION	0.9999889419280125	WITHOUT_CLASSIFICATION	1.1058071987462703E-5	DEFECT
// otherwise, just dump it	WITHOUT_CLASSIFICATION	0.9999999983022502	WITHOUT_CLASSIFICATION	1.697749799384007E-9	DEFECT
//its an interface so we can't really tell anything...	WITHOUT_CLASSIFICATION	0.9995988483377314	WITHOUT_CLASSIFICATION	4.0115166226867353E-4	DEFECT
//its an interface so we can't really tell anything...	WITHOUT_CLASSIFICATION	0.9995988483377314	WITHOUT_CLASSIFICATION	4.0115166226867353E-4	DEFECT
// use default behavior	WITHOUT_CLASSIFICATION	0.9999999933134517	WITHOUT_CLASSIFICATION	6.6865482217108305E-9	DEFECT
//NOTE: early return	WITHOUT_CLASSIFICATION	0.9999695278763862	WITHOUT_CLASSIFICATION	3.0472123613814537E-5	DEFECT
// the MRU cache used to keep hard references to the most recently used query plans; // note : LRU here is a bit of a misnomer, it indicates that LRU entries are removed, the // actual kept entries are the MRU entries	WITHOUT_CLASSIFICATION	0.999987382951485	WITHOUT_CLASSIFICATION	1.2617048515040409E-5	DEFECT
// we want to be able to just use the defaults, // if JNDI environment properties are not supplied // so don't put null in anywhere	WITHOUT_CLASSIFICATION	0.9999999999186424	WITHOUT_CLASSIFICATION	8.135766650732913E-11	DEFECT
// Clone //-----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9999989516446101	WITHOUT_CLASSIFICATION	1.0483553898715605E-6	DEFECT
// Serialize //-----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9999994880365177	WITHOUT_CLASSIFICATION	5.119634822020867E-7	DEFECT
// stream closed in the finally	WITHOUT_CLASSIFICATION	0.9999996128544453	WITHOUT_CLASSIFICATION	3.8714555472581066E-7	DEFECT
// stream closed in the finally	WITHOUT_CLASSIFICATION	0.9999996128544453	WITHOUT_CLASSIFICATION	3.8714555472581066E-7	DEFECT
// Deserialize //-----------------------------------------------------------------------	WITHOUT_CLASSIFICATION	0.9999998861160789	WITHOUT_CLASSIFICATION	1.1388392098008103E-7	DEFECT
/* static methods only - hide constructor */	WITHOUT_CLASSIFICATION	0.9999990876802825	WITHOUT_CLASSIFICATION	9.123197175826279E-7	DEFECT
/*&& !('_'==character)*/	WITHOUT_CLASSIFICATION	0.9999996225944372	WITHOUT_CLASSIFICATION	3.7740556277350115E-7	DEFECT
// returnign null!	WITHOUT_CLASSIFICATION	0.9999926219251313	WITHOUT_CLASSIFICATION	7.378074868721838E-6	DEFECT
// returnign null!	WITHOUT_CLASSIFICATION	0.9999926219251313	WITHOUT_CLASSIFICATION	7.378074868721838E-6	DEFECT
// includes last '.'	WITHOUT_CLASSIFICATION	0.9999996586118268	WITHOUT_CLASSIFICATION	3.4138817317264597E-7	DEFECT
// +1 to include the following '.'	WITHOUT_CLASSIFICATION	0.99999756397655	WITHOUT_CLASSIFICATION	2.4360234500251948E-6	DEFECT
// Impl note: takes advantage of the fact that an escpaed single quote // embedded within a quote-block can really be handled as two seperate // quote-blocks for the purposes of this method...	WITHOUT_CLASSIFICATION	0.998961943181728	WITHOUT_CLASSIFICATION	0.0010380568182718616	DEFECT
// first time we find match!	WITHOUT_CLASSIFICATION	0.9999999924453102	WITHOUT_CLASSIFICATION	7.554689734788539E-9	DEFECT
// entityNames may now include slashes for the representations //classname may be an inner class	WITHOUT_CLASSIFICATION	0.9999970754373174	WITHOUT_CLASSIFICATION	2.9245626826131975E-6	DEFECT
// wrapped iterators	WITHOUT_CLASSIFICATION	0.9999999293575974	WITHOUT_CLASSIFICATION	7.064240256044253E-8	DEFECT
// index of current iterator in the wrapped iterators array	WITHOUT_CLASSIFICATION	0.9999906263813326	WITHOUT_CLASSIFICATION	9.373618667377852E-6	DEFECT
// the current iterator	WITHOUT_CLASSIFICATION	0.999999650317867	WITHOUT_CLASSIFICATION	3.496821330640133E-7	DEFECT
// the last used iterator	WITHOUT_CLASSIFICATION	0.9999999966961153	WITHOUT_CLASSIFICATION	3.3038847239396494E-9	DEFECT
//it was a boolean expression	WITHOUT_CLASSIFICATION	0.9999839286556371	WITHOUT_CLASSIFICATION	1.60713443629545E-5	DEFECT
/*public static Object[] clone(Class elementClass, Object[] array) {	WITHOUT_CLASSIFICATION	0.9999996177663774	WITHOUT_CLASSIFICATION	3.8223362271248887E-7	DEFECT
// call this before any Iterator method to make sure that the current Iterator // is not exhausted	WITHOUT_CLASSIFICATION	0.9997785833370936	WITHOUT_CLASSIFICATION	2.2141666290634274E-4	DEFECT
//doable if needed	WITHOUT_CLASSIFICATION	0.9999997492848628	WITHOUT_CLASSIFICATION	2.507151371495539E-7	DEFECT
// set last used iterator here, in case the user calls remove // before calling hasNext() or next() (although they shouldn't)	WITHOUT_CLASSIFICATION	0.99994294177352	WITHOUT_CLASSIFICATION	5.7058226479927865E-5	DEFECT
// peek ahead	WITHOUT_CLASSIFICATION	0.9999994182132801	WITHOUT_CLASSIFICATION	5.817867198526293E-7	DEFECT
// if we reach the end of the string w/o finding the // matching end, that is an exception	WITHOUT_CLASSIFICATION	0.9999970389619207	WITHOUT_CLASSIFICATION	2.96103807933191E-6	DEFECT
// we have a placeholder, spin forward till we find the end	WITHOUT_CLASSIFICATION	0.9999999513127411	WITHOUT_CLASSIFICATION	4.868725894405805E-8	DEFECT
// make sure spinning forward did not put us past the end of the buffer...	WITHOUT_CLASSIFICATION	0.9999945579942827	WITHOUT_CLASSIFICATION	5.4420057173580985E-6	DEFECT
// First, try to locate this resource through the current // context classloader.	WITHOUT_CLASSIFICATION	0.9999134481882771	WITHOUT_CLASSIFICATION	8.655181172292105E-5	DEFECT
// Next, try to locate this resource through this class's classloader	WITHOUT_CLASSIFICATION	0.9999933670803108	WITHOUT_CLASSIFICATION	6.63291968912497E-6	DEFECT
// Next, try to locate this resource through the system classloader	WITHOUT_CLASSIFICATION	0.9999836150016097	WITHOUT_CLASSIFICATION	1.638499839023342E-5	DEFECT
// Anywhere else we should look?	WITHOUT_CLASSIFICATION	0.9999917480414301	WITHOUT_CLASSIFICATION	8.251958569820123E-6	DEFECT
// would need an IdentitySet for this!	WITHOUT_CLASSIFICATION	0.9999989546723482	WITHOUT_CLASSIFICATION	1.0453276518616517E-6	DEFECT
//Arrays.asList doesn't do primitive arrays	WITHOUT_CLASSIFICATION	0.9999930509997226	WITHOUT_CLASSIFICATION	6.949000277430278E-6	DEFECT
//faster?	WITHOUT_CLASSIFICATION	0.9999968063843546	WITHOUT_CLASSIFICATION	3.1936156454198566E-6	DEFECT
// the name of a class	WITHOUT_CLASSIFICATION	0.9999954215285277	WITHOUT_CLASSIFICATION	4.578471472279874E-6	DEFECT
// Its the listener class name	WITHOUT_CLASSIFICATION	0.9999998779791693	WITHOUT_CLASSIFICATION	1.2202083065248986E-7	DEFECT
//allow 9,8,7,6,5,4,3,2,1	WITHOUT_CLASSIFICATION	0.9999652208136295	WITHOUT_CLASSIFICATION	3.477918637048686E-5	DEFECT
// default to element set if no elements() specified	WITHOUT_CLASSIFICATION	0.9999999996977234	WITHOUT_CLASSIFICATION	3.0227656661978675E-10	DEFECT
// look for the instance by uuid	WITHOUT_CLASSIFICATION	0.9999992418896794	WITHOUT_CLASSIFICATION	7.581103206725284E-7	DEFECT
// in case we were deserialized in a different JVM, look for an instance with the same name // (alternatively we could do an actual JNDI lookup here....)	WITHOUT_CLASSIFICATION	0.9996128116248906	WITHOUT_CLASSIFICATION	3.8718837510937326E-4	DEFECT
// first, lets determine whether to apply cglib or javassist based instrumentation...	WITHOUT_CLASSIFICATION	0.9999998963882626	WITHOUT_CLASSIFICATION	1.0361173736741047E-7	DEFECT
// Make sure we don't override previous set values	WITHOUT_CLASSIFICATION	0.9999999741935566	WITHOUT_CLASSIFICATION	2.580644335890168E-8	DEFECT
//entirely optional!!	WITHOUT_CLASSIFICATION	0.9999898462767521	WITHOUT_CLASSIFICATION	1.0153723247950839E-5	DEFECT
// Its the listener instance (or better be)	WITHOUT_CLASSIFICATION	0.999999618634836	WITHOUT_CLASSIFICATION	3.813651640154919E-7	DEFECT
//context.unbind(boundName);	WITHOUT_CLASSIFICATION	0.9999816733351314	WITHOUT_CLASSIFICATION	1.8326664868565684E-5	DEFECT
//readResolveObject	WITHOUT_CLASSIFICATION	0.9999891488598562	WITHOUT_CLASSIFICATION	1.0851140143867785E-5	DEFECT
//cfg.setProperty("hibernate.show_sql", "true");	WITHOUT_CLASSIFICATION	0.9999996720042034	WITHOUT_CLASSIFICATION	3.2799579664497903E-7	DEFECT
// Defensive, convenience methods	WITHOUT_CLASSIFICATION	0.9999991177176054	WITHOUT_CLASSIFICATION	8.822823944369161E-7	DEFECT
// Create the SessionFactory from hibernate.cfg.xml	WITHOUT_CLASSIFICATION	0.9999994808190815	WITHOUT_CLASSIFICATION	5.19180918385589E-7	DEFECT
// Make sure you log the exception, as it might be swallowed	WITHOUT_CLASSIFICATION	0.9997313025163418	WITHOUT_CLASSIFICATION	2.686974836582953E-4	DEFECT
// Begin unit of work	WITHOUT_CLASSIFICATION	0.9965979266028644	WITHOUT_CLASSIFICATION	0.003402073397135562	DEFECT
// Write HTML header	WITHOUT_CLASSIFICATION	0.9999989546272423	WITHOUT_CLASSIFICATION	1.0453727576410808E-6	DEFECT
// Handle actions	WITHOUT_CLASSIFICATION	0.9999998837546512	WITHOUT_CLASSIFICATION	1.1624534891677442E-7	DEFECT
// Print page	WITHOUT_CLASSIFICATION	0.9999992456960725	WITHOUT_CLASSIFICATION	7.54303927531772E-7	DEFECT
// Write HTML footer	WITHOUT_CLASSIFICATION	0.9999984274486865	WITHOUT_CLASSIFICATION	1.5725513135167255E-6	DEFECT
// End unit of work	WITHOUT_CLASSIFICATION	0.9995103420388649	WITHOUT_CLASSIFICATION	4.896579611350317E-4	DEFECT
// Start the session to be used for this request	WITHOUT_CLASSIFICATION	0.9999995280856631	WITHOUT_CLASSIFICATION	4.7191433688245364E-7	DEFECT
// make the session available to the session factory's "current context"	WITHOUT_CLASSIFICATION	0.9999955065211713	WITHOUT_CLASSIFICATION	4.493478828667666E-6	DEFECT
// pass control along to the rest of the processing chain	WITHOUT_CLASSIFICATION	0.9999999113762374	WITHOUT_CLASSIFICATION	8.862376253908582E-8	DEFECT
// remove session from "current context"	WITHOUT_CLASSIFICATION	0.9998091618115563	WITHOUT_CLASSIFICATION	1.908381884437217E-4	DEFECT
// Eager fetch the collection so we can use it detached	WITHOUT_CLASSIFICATION	0.9999999047410018	WITHOUT_CLASSIFICATION	9.525899818795556E-8	DEFECT
// If we want to handle it bidirectional and detached, we also need to load this // collection with an eager outer-join fetch, this time with Criteria and not HQL:	WITHOUT_CLASSIFICATION	0.9999999907963989	WITHOUT_CLASSIFICATION	9.203601164075893E-9	DEFECT
/*        Event anEvent = (Event) session                .createCriteria(Event.class).setFetchMode("participants", FetchMode.JOIN)                .add( Expression.eq("id", eventId) )                .uniqueResult(); // Eager fetch the colleciton so we can use it detached        */	WITHOUT_CLASSIFICATION	0.9999999992216022	WITHOUT_CLASSIFICATION	7.783977350343726E-10	DEFECT
// End of first unit of work	WITHOUT_CLASSIFICATION	0.9999592573299423	WITHOUT_CLASSIFICATION	4.074267005780173E-5	DEFECT
// or bidirectional safety method, setting both sides: aPerson.addToEvent(anEvent);	WITHOUT_CLASSIFICATION	0.9999985429492964	WITHOUT_CLASSIFICATION	1.4570507036753618E-6	DEFECT
// Begin second unit of work	WITHOUT_CLASSIFICATION	0.9993749249116122	WITHOUT_CLASSIFICATION	6.250750883878509E-4	DEFECT
// Reattachment of aPerson	WITHOUT_CLASSIFICATION	0.9999978736619571	WITHOUT_CLASSIFICATION	2.1263380429120076E-6	DEFECT
// The getEmailAddresses() might trigger a lazy load of the collection	WITHOUT_CLASSIFICATION	0.9995180391542795	WITHOUT_CLASSIFICATION	4.819608457205553E-4	DEFECT
// We need our tm, so get it now and avoid doing other work // if there is a problem	WITHOUT_CLASSIFICATION	0.9999989360140131	WITHOUT_CLASSIFICATION	1.0639859869103877E-6	DEFECT
// Don't hold the JBC node lock throughout the tx, as that // prevents reads and other updates	WITHOUT_CLASSIFICATION	0.9999991206652036	WITHOUT_CLASSIFICATION	8.793347963036428E-7	DEFECT
// Don't hold the JBC node lock throughout the tx, as that // prevents reads and other updates	WITHOUT_CLASSIFICATION	0.9999991206652036	WITHOUT_CLASSIFICATION	8.793347963036428E-7	DEFECT
// JBC put a version in the node when it created as part of // some internal operation. We are always newer, but if // the JBC version is > 1 something odd has happened	WITHOUT_CLASSIFICATION	0.9999999652798699	WITHOUT_CLASSIFICATION	3.472013017835787E-8	DEFECT
//swaldman 2006-08-28: define c3p0-style configuration parameters for properties with //                     hibernate-specific overrides to detect and warn about conflicting //                     declarations	WITHOUT_CLASSIFICATION	0.9999976730577078	WITHOUT_CLASSIFICATION	2.3269422920689263E-6	DEFECT
// Not null if the Isolation level has been specified in the configuration file. // Otherwise, it is left to the Driver's default value.	WITHOUT_CLASSIFICATION	0.9999999991575141	WITHOUT_CLASSIFICATION	8.424858062944599E-10	DEFECT
// Configured outside of Hibernate (i.e. Servlet container, or Java Bean Container // already has Proxool pools running, and this provider is to just borrow one of these	WITHOUT_CLASSIFICATION	0.9999999991747226	WITHOUT_CLASSIFICATION	8.25277356669506E-10	DEFECT
// If you're closing down the ConnectionProvider chances are an // is not a real big deal, just warn	WITHOUT_CLASSIFICATION	0.9999989033086981	WITHOUT_CLASSIFICATION	1.0966913018255519E-6	DEFECT
// (AS is always optional, for consistency with SQL/OQL)	WITHOUT_CLASSIFICATION	0.9999997145701152	WITHOUT_CLASSIFICATION	2.854298847921775E-7	DEFECT
// process the "new" HQL style where aliases are assigned // _after_ the class name or path expression ie. using // the AS construction	WITHOUT_CLASSIFICATION	0.9999999942712544	WITHOUT_CLASSIFICATION	5.728745615767411E-9	DEFECT
// the loaded owner will be set to null after the collection is removed, // so capture its value as the affected owner so it is accessible to // both pre- and post- events	WITHOUT_CLASSIFICATION	0.9999999954207698	WITHOUT_CLASSIFICATION	4.579230152196046E-9	DEFECT
// is a primitive type // invokespecial	WITHOUT_CLASSIFICATION	0.9999975521272481	WITHOUT_CLASSIFICATION	2.4478727520225397E-6	DEFECT
// array of primitive type // do nothing	WITHOUT_CLASSIFICATION	0.9999851664487107	WITHOUT_CLASSIFICATION	1.4833551289397035E-5	DEFECT
// handle a path expression or class name that // appears at the start, in the "new" HQL // style or an alias that appears at the start // in the "old" HQL style	WITHOUT_CLASSIFICATION	0.9999936292799435	WITHOUT_CLASSIFICATION	6.370720056515715E-6	DEFECT
//handle <=, >=, !=, is not, not between, not in	WITHOUT_CLASSIFICATION	0.9999601426748369	WITHOUT_CLASSIFICATION	3.985732516304267E-5	DEFECT
// The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation level	WITHOUT_CLASSIFICATION	0.9999923289084567	WITHOUT_CLASSIFICATION	7.671091543312239E-6	DEFECT
// transfer an explicitly defined entity name // handle the lazy attribute	WITHOUT_CLASSIFICATION	0.9999999998870365	WITHOUT_CLASSIFICATION	1.1296355512088611E-10	DEFECT
//keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9999995817590462	WITHOUT_CLASSIFICATION	4.1824095374432955E-7	DEFECT
//keep the behavior consistent even for boundary usages	WITHOUT_CLASSIFICATION	0.9999995817590462	WITHOUT_CLASSIFICATION	4.1824095374432955E-7	DEFECT
// get meta's from // <joined-subclass>	WITHOUT_CLASSIFICATION	0.9999996657740012	WITHOUT_CLASSIFICATION	3.3422599876059137E-7	DEFECT
// parameters on the property mapping should // override parameters in the typedef	WITHOUT_CLASSIFICATION	0.9997394962744082	WITHOUT_CLASSIFICATION	2.605037255917536E-4	DEFECT
//fetch="join" overrides default laziness //fetch="join" overrides default laziness	WITHOUT_CLASSIFICATION	0.9999999838803336	WITHOUT_CLASSIFICATION	1.6119666376675916E-8	DEFECT
//NOTE SPECIAL CASE: // default to join and non-lazy for the "second join" // of the many-to-many	WITHOUT_CLASSIFICATION	0.9999999015365132	WITHOUT_CLASSIFICATION	9.846348680926419E-8	DEFECT
// so we "clock over" on the first invocation	WITHOUT_CLASSIFICATION	0.9999999630043653	WITHOUT_CLASSIFICATION	3.699563462656102E-8	DEFECT
// state ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999993498285129	WITHOUT_CLASSIFICATION	6.501714870698459E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//element //index -> id	WITHOUT_CLASSIFICATION	0.9999978795736088	WITHOUT_CLASSIFICATION	2.1204263912314723E-6	DEFECT
// note that it might be better to iterate the snapshot but this is safe, // assuming the user implements equals() properly, as required by the Set // contract!	WITHOUT_CLASSIFICATION	0.9776480835268844	WITHOUT_CLASSIFICATION	0.022351916473115623	DEFECT
// collections detect changes made via their public interface and mark // themselves as dirty as a performance optimization	WITHOUT_CLASSIFICATION	0.9999999997101466	WITHOUT_CLASSIFICATION	2.898533671623326E-10	DEFECT
// essentially, if the real session is closed allow any // method call to pass through since the real session // will complain by throwing an appropriate exception; // NOTE that allowing close() above has the same basic effect, //   but we capture that there simply to perform the unbind...	WITHOUT_CLASSIFICATION	0.9999953914060519	WITHOUT_CLASSIFICATION	4.6085939480313655E-6	DEFECT
// The default SQLExceptionConverter for all dialects is based on SQLState // since SQLErrorCode is extremely vendor-specific.  Specific Dialects // may override to return whatever is most appropriate for that vendor.	WITHOUT_CLASSIFICATION	0.9999999808949738	WITHOUT_CLASSIFICATION	1.9105026218691893E-8	DEFECT
//only necessary for postgre < 7.4 //http://anoncvs.postgresql.org/cvsweb.cgi/pgsql/doc/src/sgml/ref/create_sequence.sgml	WITHOUT_CLASSIFICATION	0.9999997561159003	WITHOUT_CLASSIFICATION	2.4388409972493773E-7	DEFECT
// select topic, syntax from information_schema.help // where section like 'Function%' order by section, topic // // see also ->  http://www.h2database.com/html/functions.html	WITHOUT_CLASSIFICATION	0.9999997618561007	WITHOUT_CLASSIFICATION	2.3814389924352774E-7	DEFECT
// registerColumnType(Types.VARBINARY, "CHARACTER($l)"); // registerColumnType(Types.BLOB, "CHARACTER($l)" );  // For use prior to CP 11.0 // registerColumnType(Types.CLOB, "CHARACTER($l)" );	WITHOUT_CLASSIFICATION	0.9999999695815674	WITHOUT_CLASSIFICATION	3.041843255314737E-8	DEFECT
//the BLOB type requires a size arguement - this defaults to //bytes - no arg defaults to 1 whole byte! //other argument mods include K - kilobyte, M - megabyte, G - gigabyte. //refer to the PBdevelopers guide for more info.	WITHOUT_CLASSIFICATION	0.9999943252403632	WITHOUT_CLASSIFICATION	5.674759636762768E-6	DEFECT
// We must return a valid RDMS/RSA command from this method to // prevent RDMS/RSA from issuing *ERROR 400	WITHOUT_CLASSIFICATION	0.9999780404440924	WITHOUT_CLASSIFICATION	2.1959555907510974E-5	DEFECT
// Oracle driver reports to support getGeneratedKeys(), but they only // support the version taking an array of the names of the columns to // be returned (via its RETURNING clause).  No other driver seems to // support this overloaded version.	WITHOUT_CLASSIFICATION	0.9999999694904468	WITHOUT_CLASSIFICATION	3.050955324738457E-8	DEFECT
// add the comment // nest the main query in an outer select // add the rownnumber bit into the outer query select list	WITHOUT_CLASSIFICATION	0.9999996364785959	WITHOUT_CLASSIFICATION	3.635214041190838E-7	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// Note: For object <-> SQL datatype mappings see: //	WITHOUT_CLASSIFICATION	0.999991845811401	WITHOUT_CLASSIFICATION	8.154188598924582E-6	DEFECT
// TRIM(end_keyword string-expression-1 FROM string-expression-2) // use Hibernate implementation "From" is one of the parameters they pass in position ?3 //registerFunction( "trim", new SQLFunctionTemplate(Hibernate.STRING, "trim(?1 ?2 from ?3)") );	WITHOUT_CLASSIFICATION	0.9999998142878085	WITHOUT_CLASSIFICATION	1.857121915860877E-7	DEFECT
// Whether this dialect has an Identity clause added to the data type or a completely seperate identity // data type	WITHOUT_CLASSIFICATION	0.9999991439657662	WITHOUT_CLASSIFICATION	8.560342338327569E-7	DEFECT
// According to both the ANSI-SQL and JPA specs, trim takes a variable number of parameters between 1 and 4. // at least one paramer (trimSource) is required.  From the SQL spec: // // <trim function> ::= //      TRIM <left paren> <trim operands> <right paren> // // <trim operands> ::= //      [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source> // // <trim specification> ::= //      LEADING //      | TRAILING //      | BOTH // // If <trim specification> is omitted, BOTH is assumed. // If <trim character> is omitted, space is assumed	WITHOUT_CLASSIFICATION	0.9999991417608781	WITHOUT_CLASSIFICATION	8.582391219127619E-7	DEFECT
/////////////////////////////////////////////////////////////////////// // Prepare persisters and link them up with their cache // region/access-strategy	WITHOUT_CLASSIFICATION	0.9999999666346833	WITHOUT_CLASSIFICATION	3.336531677043528E-8	DEFECT
//Named Queries:	WITHOUT_CLASSIFICATION	0.9999997579096338	WITHOUT_CLASSIFICATION	2.4209036618771364E-7	DEFECT
// this will throw an error if there's something wrong.	WITHOUT_CLASSIFICATION	0.9995862174199662	WITHOUT_CLASSIFICATION	4.137825800337029E-4	DEFECT
// does not handle arrays (thats ok, cos they can't be lazy) // or newly instantiated collections, so we can do the cast	WITHOUT_CLASSIFICATION	0.9999626213397999	WITHOUT_CLASSIFICATION	3.73786602001122E-5	DEFECT
// collection deletions are a special case since update() can add // deletions of collections not loaded by the session.	WITHOUT_CLASSIFICATION	0.9999797557980343	WITHOUT_CLASSIFICATION	2.024420196561932E-5	DEFECT
// we can do the cast since orphan-delete does not apply to: // 1. newly instantiated collections // 2. arrays (we can't track orphans for detached arrays)	WITHOUT_CLASSIFICATION	0.9998568518569185	WITHOUT_CLASSIFICATION	1.431481430814754E-4	DEFECT
// if the natural-id is marked as non-mutable, it is not retrieved during a // normal database-snapshot operation...	WITHOUT_CLASSIFICATION	0.999999327848723	WITHOUT_CLASSIFICATION	6.721512770126869E-7	DEFECT
// watch out for a case where old is still referenced // somewhere in the object graph! (which is a user error)	WITHOUT_CLASSIFICATION	0.999999821524055	WITHOUT_CLASSIFICATION	1.7847594506928677E-7	DEFECT
//slice, to get the columns for this component //property	WITHOUT_CLASSIFICATION	0.9999981561900432	WITHOUT_CLASSIFICATION	1.8438099567835404E-6	DEFECT
//int result = 17; //result = 37 * result + type.hashCode(); //result = 37 * result + ( value==null ? 0 : value.hashCode() ); //return result;	WITHOUT_CLASSIFICATION	0.9999360728526133	WITHOUT_CLASSIFICATION	6.392714738667649E-5	DEFECT
// The CollectionEntry.isReached() stuff is just to detect any silly users   // who set up circular or shared references between/to collections.	WITHOUT_CLASSIFICATION	0.9999999980218649	WITHOUT_CLASSIFICATION	1.9781352159779436E-9	DEFECT
// detached collection wrappers that get found + reattached // during flush shouldn't be ignored	WITHOUT_CLASSIFICATION	0.9999962749466578	WITHOUT_CLASSIFICATION	3.7250533423521096E-6	DEFECT
// The unique property value represented here may or may not be // serializable, so we do an explicit check here in order to generate // a better error message	WITHOUT_CLASSIFICATION	0.9999967853625737	WITHOUT_CLASSIFICATION	3.2146374264026597E-6	DEFECT
// if the version of a newly instantiated object is not the same // as the version seed value, use that as the unsaved-value	WITHOUT_CLASSIFICATION	0.9999997095053044	WITHOUT_CLASSIFICATION	2.904946956286248E-7	DEFECT
// ie. we never have to null out a reference to // an uninitialized proxy	WITHOUT_CLASSIFICATION	0.9999999967548345	WITHOUT_CLASSIFICATION	3.245165445538273E-9	DEFECT
// ignore this row, the collection is in process of // being loaded somewhere further "up" the stack	WITHOUT_CLASSIFICATION	0.9999999939013888	WITHOUT_CLASSIFICATION	6.098611234182926E-9	DEFECT
// Entity load contexts ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // 	WITHOUT_CLASSIFICATION	0.999962752343679	WITHOUT_CLASSIFICATION	3.724765632100056E-5	DEFECT
// should be ok performance-wise to generate new delegate instances for each // request since these are locally stack-scoped.  Besides, it makes the code // much easier to read than the old TransactionHelper stuff...	WITHOUT_CLASSIFICATION	0.9998365949176777	WITHOUT_CLASSIFICATION	1.6340508232227892E-4	DEFECT
// this implementation is supposed to tolerate incorrect unsaved-value // mappings, for the purpose of backward-compatibility	WITHOUT_CLASSIFICATION	0.9998982177621089	WITHOUT_CLASSIFICATION	1.0178223789116374E-4	DEFECT
// this implementation is supposed to tolerate incorrect unsaved-value // mappings, for the purpose of backward-compatibility	WITHOUT_CLASSIFICATION	0.9998982177621089	WITHOUT_CLASSIFICATION	1.0178223789116374E-4	DEFECT
// wrap up any new collections directly referenced by the object // or its components	WITHOUT_CLASSIFICATION	0.999999993637443	WITHOUT_CLASSIFICATION	6.3625571281188575E-9	DEFECT
// remove any snapshot, not really for memory management purposes, but // rather because it might now be stale, and there is no longer any  // EntityEntry to take precedence // This is now handled by removeEntity() //session.getPersistenceContext().removeDatabaseSnapshot(key);	WITHOUT_CLASSIFICATION	0.9996533027304877	WITHOUT_CLASSIFICATION	3.466972695123235E-4	DEFECT
// skip this check for composite-ids relating to dom4j entity-mode; // alternatively, we could add a check to make sure the incoming id value is // an instance of Element...	WITHOUT_CLASSIFICATION	0.9999907640218559	WITHOUT_CLASSIFICATION	9.23597814399231E-6	DEFECT
// upgrade the lock if necessary: //lock(result, lockMode);	WITHOUT_CLASSIFICATION	0.9999821485590847	WITHOUT_CLASSIFICATION	1.78514409152464E-5	DEFECT
// now, any collections that are initialized // inside this block do not get updated - they // are ignored until the next flush	WITHOUT_CLASSIFICATION	0.999999912565333	WITHOUT_CLASSIFICATION	8.743466691476396E-8	DEFECT
//we must clone embedded composite identifiers, or  //we will get back the same instance that we pass in	WITHOUT_CLASSIFICATION	0.9999999369178543	WITHOUT_CLASSIFICATION	6.308214582368769E-8	DEFECT
// Sub-insertions should occur before containing insertion so // Try to do the callback now	WITHOUT_CLASSIFICATION	0.9998036887706847	WITHOUT_CLASSIFICATION	1.9631122931524145E-4	DEFECT
//the entity is not associated with the session, so //try interceptor and unsaved-value	WITHOUT_CLASSIFICATION	0.9999999286217406	WITHOUT_CLASSIFICATION	7.137825946293939E-8	DEFECT
//scan the query string for class names appearing in the from clause and replace //with all persistent implementors of the class/interface, returning multiple //query strings (make sure we don't pick up a class in the select clause!)	WITHOUT_CLASSIFICATION	0.9982159296291407	WITHOUT_CLASSIFICATION	0.0017840703708593044	DEFECT
// save() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999997425278964	WITHOUT_CLASSIFICATION	2.574721035827896E-7	DEFECT
// evict() operations ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999031950287	WITHOUT_CLASSIFICATION	9.680497128593663E-8	DEFECT
//stops flush being called multiple times if this method is recursively called	WITHOUT_CLASSIFICATION	0.9999933910084765	WITHOUT_CLASSIFICATION	6.608991523537538E-6	DEFECT
//if it is an uninitialized proxy, pointing //with this session, then when it is accessed, //the underlying instance will be "contained"	WITHOUT_CLASSIFICATION	0.9999960597097052	WITHOUT_CLASSIFICATION	3.940290294851548E-6	DEFECT
// Generate an explicit join for the root dot node.   The implied joins will be collected and passed up // to the root dot node.	WITHOUT_CLASSIFICATION	0.9999999816365555	WITHOUT_CLASSIFICATION	1.8363444559475608E-8	DEFECT
// A session is considered to contain an entity only if the entity has // an entry in the session's persistence context and the entry reports // that the entity has not been removed	WITHOUT_CLASSIFICATION	0.9999912339990374	WITHOUT_CLASSIFICATION	8.766000962610664E-6	DEFECT
// Does the collection referenced by this FromElement // specify an order-by attribute?  If so, attach it to // the query's order-by	WITHOUT_CLASSIFICATION	0.9999998298803262	WITHOUT_CLASSIFICATION	1.7011967374247522E-7	DEFECT
// ... and the token could be an identifer and the error is // a mismatched token error ...	WITHOUT_CLASSIFICATION	0.9999183219212775	WITHOUT_CLASSIFICATION	8.167807872260444E-5	DEFECT
// If a where clause was specified in the update/delete query, use it to limit the // returned ids here...	WITHOUT_CLASSIFICATION	0.9999941546328891	WITHOUT_CLASSIFICATION	5.84536711083878E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// Default implementation: // If this node has a data type, and that data type is not an association, then this is scalar.	WITHOUT_CLASSIFICATION	0.9990137143104278	WITHOUT_CLASSIFICATION	9.862856895721066E-4	DEFECT
// Resolve the LHS fully, generate implicit joins.  Pass in the property name so that the resolver can // discover foreign key (id) properties.	WITHOUT_CLASSIFICATION	0.9998729545535278	WITHOUT_CLASSIFICATION	1.270454464722424E-4	DEFECT
// If the propertyType is null and there isn't a parent, just // stop now... there was a problem resolving the node anyway.	WITHOUT_CLASSIFICATION	0.9994976653624261	WITHOUT_CLASSIFICATION	5.023346375737808E-4	DEFECT
//We do not look for an existing join on the same path, because //it makes sense to join twice on the same collection role	WITHOUT_CLASSIFICATION	0.9999969893299069	WITHOUT_CLASSIFICATION	3.010670093205837E-6	DEFECT
// our parent is another dot node, meaning we are being further dereferenced. // thus we need to generate a join unless the parent refers to the associated // entity's PK (because 'our' table would know the FK).	WITHOUT_CLASSIFICATION	0.9999999998023212	WITHOUT_CLASSIFICATION	1.9767872199919214E-10	DEFECT
/*public final Currency getCurrency(int col) throws HibernateException {	WITHOUT_CLASSIFICATION	0.9994680732872956	WITHOUT_CLASSIFICATION	5.319267127044519E-4	DEFECT
// here, we have two possibilities: // 	WITHOUT_CLASSIFICATION	0.9999626561159527	WITHOUT_CLASSIFICATION	3.7343884047338784E-5	DEFECT
// Set the unresolved path in this node and the parent. // Set the text for the parent.	WITHOUT_CLASSIFICATION	0.9999488041376816	WITHOUT_CLASSIFICATION	5.119586231828729E-5	DEFECT
// Get the first child to be considered.  Sub-classes may do this differently in order to skip nodes that // are not select expressions (e.g. DISTINCT).	WITHOUT_CLASSIFICATION	0.999999787446902	WITHOUT_CLASSIFICATION	2.1255309805896672E-7	DEFECT
// If this is an entity and the property is the identifier property, then use getIdentifierType(). //      Note that the propertyName.equals( propertyPath ) checks whether we have a component //      key reference, where the component class property name is the same as the //      entity id property name; if the two are not equal, this is the case and //      we'd need to "fall through" to using the property mapping.	WITHOUT_CLASSIFICATION	0.9999999240109076	WITHOUT_CLASSIFICATION	7.598909240373357E-8	DEFECT
// for a subquery, the alias to use depends on a few things (we // already know this is not an overall SELECT): //      1) if this FROM_ELEMENT represents a correlation to the //          outer-most query //              A) if the outer query represents a multi-table //                  persister, we need to use the given alias //                  in anticipation of one of the multi-table //                  executors being used (as this subquery will //                  actually be used in the "id select" phase //                  of that multi-table executor) //              B) otherwise, we need to use the persister's //                  table name as the column qualification //      2) otherwise (not correlated), use the given alias	WITHOUT_CLASSIFICATION	0.9999663093082662	WITHOUT_CLASSIFICATION	3.369069173371222E-5	DEFECT
// Not a collection? // Return the entity property mapping.	WITHOUT_CLASSIFICATION	0.9999596113921747	WITHOUT_CLASSIFICATION	4.038860782539963E-5	DEFECT
// collection of <many-to-any/> mappings... // used to circumvent the component-collection check below...	WITHOUT_CLASSIFICATION	0.9999996822068278	WITHOUT_CLASSIFICATION	3.1779317232579355E-7	DEFECT
// Otherwise, the destination node was implied by the FROM clause and the FROM clause processor // will automatically add it in the right place.	WITHOUT_CLASSIFICATION	0.999999229823884	WITHOUT_CLASSIFICATION	7.701761159800276E-7	DEFECT
// If the first identifier in the path referrs to the class alias (not the class name), then this // is a correlated subselect.  If it's a correlated sub-select, use the existing table alias.  Otherwise // generate a new one.	WITHOUT_CLASSIFICATION	0.9999999965220224	WITHOUT_CLASSIFICATION	3.4779775810670998E-9	DEFECT
// check to see if our "propPath" actually // represents a property on the persister	WITHOUT_CLASSIFICATION	0.9999992819840429	WITHOUT_CLASSIFICATION	7.18015957052384E-7	DEFECT
// An ident node can represent an index expression if the ident // represents a naked property ref //      *Note: this makes the assumption (which is currently the case //      in the hql-sql grammar) that the ident is first resolved //      itself (addrExpr -> resolve()).  The other option, if that //      changes, is to call resolve from here; but it is //      currently un-needed overhead.	WITHOUT_CLASSIFICATION	0.9999999933717211	WITHOUT_CLASSIFICATION	6.628278932560708E-9	DEFECT
// This uses a PathExpressionParser but notice that compound paths are not valid, // only bare names and simple paths:	WITHOUT_CLASSIFICATION	0.9999832686513547	WITHOUT_CLASSIFICATION	1.6731348645328136E-5	DEFECT
// If this is an implied join in a FROM clause, then use ANSI-style joining, and set the // flag on the FromElement that indicates that it was implied in the FROM clause itself.	WITHOUT_CLASSIFICATION	0.9999999811875433	WITHOUT_CLASSIFICATION	1.881245672036411E-8	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// For an explicit many-to-many relationship, add a second join from the intermediate  // (many-to-many) table to the destination table.  Also, make sure that the from element's  // idea of the destination is the destination table.	WITHOUT_CLASSIFICATION	0.9999999955116018	WITHOUT_CLASSIFICATION	4.488398179388871E-9	DEFECT
// Reset the node type, because the rest of the system is expecting FROM_FRAGMENT, all we wanted was // for the factory to create the right sub-class.  This might get reset again later on anyway to make the // SQL generation simpler.	WITHOUT_CLASSIFICATION	0.9999209611238964	WITHOUT_CLASSIFICATION	7.903887610367683E-5	DEFECT
//explicit = true;	WITHOUT_CLASSIFICATION	0.9999970196518457	WITHOUT_CLASSIFICATION	2.980348154198065E-6	DEFECT
//sqlResultTypeList.add( type ); // Generate the select expression.	WITHOUT_CLASSIFICATION	0.9999989659931124	WITHOUT_CLASSIFICATION	1.0340068875882234E-6	DEFECT
// If the expression list has exactly one expression, and the type of the expression is a collection // then this might be a collection function, such as index(c) or size(c).	WITHOUT_CLASSIFICATION	0.9995397208444273	WITHOUT_CLASSIFICATION	4.602791555725762E-4	DEFECT
// Need to parse off the column qualifiers; this is assuming (which is true as of now) // that this is only used from update and delete HQL statement parsing	WITHOUT_CLASSIFICATION	0.9999999973128922	WITHOUT_CLASSIFICATION	2.687107702180254E-9	DEFECT
// for regression testing against output from the old parser... // found it easiest to simply reorder the FromElements here into ascending order // in terms of injecting them into the resulting sql ast in orders relative to those // expected by the old parser; this is definitely another of those "only needed // for regression purposes".  The SyntheticAndFactory, then, simply injects them as it // encounters them.	WITHOUT_CLASSIFICATION	0.9999999921798913	WITHOUT_CLASSIFICATION	7.820108623543497E-9	DEFECT
// The uber-rule here is that we need to include  subclass joins if // the FromElement is in any way dereferenced by a property from // the subclass table; otherwise we end up with column references // qualified by a non-existent table reference in the resulting SQL...	WITHOUT_CLASSIFICATION	0.9999998870235305	WITHOUT_CLASSIFICATION	1.129764695831274E-7	DEFECT
// classic translator does not support collection of ordinal // param metadata	WITHOUT_CLASSIFICATION	0.9998877862762848	WITHOUT_CLASSIFICATION	1.1221372371512016E-4	DEFECT
// The following variables are stacks that keep information about each subexpression // in the list of nested subexpressions we are currently processing.	WITHOUT_CLASSIFICATION	0.9999971771977187	WITHOUT_CLASSIFICATION	2.8228022812865826E-6	DEFECT
// The loop ensures atomicity of the // select + update even for no transaction // or read committed isolation level	WITHOUT_CLASSIFICATION	0.9999923289084567	WITHOUT_CLASSIFICATION	7.671091543312239E-6	DEFECT
// should not be able to reach last without maxPosition being set // unless there are no results	WITHOUT_CLASSIFICATION	0.9999999202026219	WITHOUT_CLASSIFICATION	7.979737806373558E-8	DEFECT
// we found it in the temp PC.  Should indicate we are in the midst of processing a result set // containing eager fetches via join fetch	WITHOUT_CLASSIFICATION	0.9999999997262691	WITHOUT_CLASSIFICATION	2.737310037546334E-10	DEFECT
//do not use proxiesByKey, since not all //proxies that point to this session's //instances are in that collection!	WITHOUT_CLASSIFICATION	0.9999767895569611	WITHOUT_CLASSIFICATION	2.321044303896659E-5	DEFECT
// if there is no TM configured, we will not be able to access // the javax.transaction.Transaction object in order to // register a synch anyway.	WITHOUT_CLASSIFICATION	0.9999999221137021	WITHOUT_CLASSIFICATION	7.788629793913708E-8	DEFECT
// Since the result set cursor is always left at the first // physical row after the "last processed", we need to jump // back one position to get the key value we are interested // in skipping	WITHOUT_CLASSIFICATION	0.9999999991591142	WITHOUT_CLASSIFICATION	8.408859038804977E-10	DEFECT
//true if this is a query and we are loading multiple instances of the same collection role //otherwise this is a CollectionInitializer and we are loading up a single collection or batch	WITHOUT_CLASSIFICATION	0.9999937397796055	WITHOUT_CLASSIFICATION	6.260220394448962E-6	DEFECT
// we don't need to worry about existing version being uninitialized // because this block isn't called by a re-entrant load (re-entrant // loads _always_ have lock mode NONE)	WITHOUT_CLASSIFICATION	0.9999977372478925	WITHOUT_CLASSIFICATION	2.2627521074660716E-6	DEFECT
// add temp entry so that the next step is circular-reference // safe - only needed because some types don't take proper // advantage of two-phase-load (esp. components)	WITHOUT_CLASSIFICATION	0.9998629792571592	WITHOUT_CLASSIFICATION	1.3702074284070235E-4	DEFECT
// assume we are in an auto-commit state	WITHOUT_CLASSIFICATION	0.9999999908614933	WITHOUT_CLASSIFICATION	9.138506785504024E-9	DEFECT
// log a message about potential connection leaks	WITHOUT_CLASSIFICATION	0.999869755085421	WITHOUT_CLASSIFICATION	1.3024491457904274E-4	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// this has been shown to happen occasionally in rare cases // when using a transaction manager + transaction-timeout // where the timeout calls back through Hibernate's // registered transaction synchronization on a separate // "reaping" thread.  In cases where that reaping thread // executes through this block at the same time the main // application thread does we can get into situations where // these CMEs occur.  And though it is not "allowed" per-se, // the end result without handling it specifically is infinite // looping.  So here, we simply break the loop	WITHOUT_CLASSIFICATION	0.9998026720901552	WITHOUT_CLASSIFICATION	1.9732790984479395E-4	DEFECT
// unfortunately this stuff can't be cached because // it is per-invocation, not constant for the // QueryTranslator instance	WITHOUT_CLASSIFICATION	0.999999640101258	WITHOUT_CLASSIFICATION	3.598987420060637E-7	DEFECT
// can't cache this stuff either (per-invocation) // we are given a map of user-alias -> lock mode // create a new map of sql-alias -> lock mode	WITHOUT_CLASSIFICATION	0.9999994178457968	WITHOUT_CLASSIFICATION	5.821542031961264E-7	DEFECT
// don't create a unique key, 'cos some // databases don't like a UK on nullable // columns //getCollectionTable().createUniqueKey( getIdentifier().getConstraintColumns() );	WITHOUT_CLASSIFICATION	0.9999962441987179	WITHOUT_CLASSIFICATION	3.7558012821749867E-6	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998377956857	WITHOUT_CLASSIFICATION	1.622043143640017E-7	DEFECT
//isSet = collection.isSet(); //isSorted = collection.isSorted();	WITHOUT_CLASSIFICATION	0.9999997016206383	WITHOUT_CLASSIFICATION	2.983793616566599E-7	DEFECT
//lists, arrays //sets, maps, bags	WITHOUT_CLASSIFICATION	0.9999980859738533	WITHOUT_CLASSIFICATION	1.9140261466053422E-6	DEFECT
// we finish all the "removes" first to take care of possible unique // constraints and so that we can take better advantage of batching	WITHOUT_CLASSIFICATION	0.9999996938647896	WITHOUT_CLASSIFICATION	3.0613521045898074E-7	DEFECT
//use a combination of foreign key columns and pk columns, since //the ordering of removal and addition is not guaranteed when //a child moves from one parent to another	WITHOUT_CLASSIFICATION	0.9998441647180735	WITHOUT_CLASSIFICATION	1.558352819264147E-4	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is persister-centric and/or EntityInfo-centric ~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998377956857	WITHOUT_CLASSIFICATION	1.622043143640017E-7	DEFECT
//information about properties of this class, //including inherited properties //(only really needed for updatable/insertable properties)	WITHOUT_CLASSIFICATION	0.9955195875847631	WITHOUT_CLASSIFICATION	0.0044804124152369425	DEFECT
// all this only really needs to consider properties // of this class, not its subclasses, but since we // are reusing code used for sequential selects, we // use the subclass closure	WITHOUT_CLASSIFICATION	0.9999962735214776	WITHOUT_CLASSIFICATION	3.7264785224387157E-6	DEFECT
// Here we render the select column list based on the properties defined as being generated. // For partial component generation, we currently just re-select the whole component // rather than trying to handle the individual generated portions.	WITHOUT_CLASSIFICATION	0.99999999790569	WITHOUT_CLASSIFICATION	2.0943099100606036E-9	DEFECT
// this is the root (versioned) table, and we are using version-based // optimistic locking;  if we are not updating the version, also don't // check it (unless this is a "generated" version column)!	WITHOUT_CLASSIFICATION	0.999999730498578	WITHOUT_CLASSIFICATION	2.6950142202156037E-7	DEFECT
//optimistic-lock="all", include all updatable properties //optimistic-lock="dirty", include all properties we are updating this time	WITHOUT_CLASSIFICATION	0.9999990054525941	WITHOUT_CLASSIFICATION	9.945474058454457E-7	DEFECT
// this property belongs to the table, and it is not specifically // excluded from optimistic locking by optimistic-lock="false"	WITHOUT_CLASSIFICATION	0.9999950667068201	WITHOUT_CLASSIFICATION	4.933293179777622E-6	DEFECT
// check to see if the connection is in auto-commit  // mode (no connection means aggressive connection // release outside a JTA transaction context, so MUST // be autocommit mode)	WITHOUT_CLASSIFICATION	0.9999999999298159	WITHOUT_CLASSIFICATION	7.018401016890782E-11	DEFECT
// need to treat this as if it where optimistic-lock="all" (dirty does *not* make sense); // first we need to locate the "loaded" state // // Note, it potentially could be a proxy, so perform the location the safe way...	WITHOUT_CLASSIFICATION	0.9999962678736333	WITHOUT_CLASSIFICATION	3.7321263666549152E-6	DEFECT
// we *always* assume an instance with a null // identifier or no identifier property is unsaved!	WITHOUT_CLASSIFICATION	0.9999999424307682	WITHOUT_CLASSIFICATION	5.7569231839185175E-8	DEFECT
// Need to use the identifier type of the collection owner // since the incoming is value is actually the owner's id. // Using the collection's key type causes problems with // property-ref keys...	WITHOUT_CLASSIFICATION	0.9994316357841463	WITHOUT_CLASSIFICATION	5.683642158537557E-4	DEFECT
//allow any identifier quoted with backtick //only recognizes identifiers beginning with a letter	WITHOUT_CLASSIFICATION	0.9999984793568955	WITHOUT_CLASSIFICATION	1.520643104488208E-6	DEFECT
//following doesn't handle (null, not null) but unnecessary //since this would mean all rows	WITHOUT_CLASSIFICATION	0.9999857392086805	WITHOUT_CLASSIFICATION	1.4260791319472834E-5	DEFECT
// IMPL NOTE : due to the delayed population of setters (setters cached // 	WITHOUT_CLASSIFICATION	0.9999673156523422	WITHOUT_CLASSIFICATION	3.2684347657690573E-5	DEFECT
// we need to dirty check collections, since they can cause an owner // version number increment	WITHOUT_CLASSIFICATION	0.9999999484988807	WITHOUT_CLASSIFICATION	5.1501119285792166E-8	DEFECT
//return the id, so we can use it to reset the proxy id //return result;	WITHOUT_CLASSIFICATION	0.9999988848594217	WITHOUT_CLASSIFICATION	1.1151405782973235E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
// cache the actual id of the object, not the value of the // property-ref, which might not be initialized	WITHOUT_CLASSIFICATION	0.9999974645641346	WITHOUT_CLASSIFICATION	2.535435865342808E-6	DEFECT
// We now have the value of the property-ref we reference.  However, // we need to dig a little deeper, as that property might also be // an entity type, in which case we need to resolve its identitifier	WITHOUT_CLASSIFICATION	0.9999984547629035	WITHOUT_CLASSIFICATION	1.545237096505945E-6	DEFECT
// Retrieve the value of the designated column in the current row of this // ResultSet object as a java.io.Reader object	WITHOUT_CLASSIFICATION	0.9999998823792077	WITHOUT_CLASSIFICATION	1.1762079226721905E-7	DEFECT
//not absolutely necessary, but helps for some //equals()/hashCode() implementations	WITHOUT_CLASSIFICATION	0.9999479508766028	WITHOUT_CLASSIFICATION	5.204912339722654E-5	DEFECT
//this should be a call to resolve(), not resolveIdentifier(),  //'cos it might be a property-ref, and we did not cache the //referenced value	WITHOUT_CLASSIFICATION	0.9999401720980436	WITHOUT_CLASSIFICATION	5.982790195636099E-5	DEFECT
// If we have <tt>not-found="ignore"</tt> association mapped to a // formula, we always need to dirty check it, so we can update the // second-level cache	WITHOUT_CLASSIFICATION	0.9999999978565844	WITHOUT_CLASSIFICATION	2.1434155886910463E-9	DEFECT
// can't just return null here, since that would // cause an owning component to become null	WITHOUT_CLASSIFICATION	0.9999997444760248	WITHOUT_CLASSIFICATION	2.555239752479443E-7	DEFECT
//for arrays, replaceElements() may return a different reference, since //the array length might not match	WITHOUT_CLASSIFICATION	0.999996445554461	WITHOUT_CLASSIFICATION	3.554445539004125E-6	DEFECT
// actual cache of the entries.  soft references are used for both the keys and the // values here since the values pertaining to the MRU entries are kept in a // seperate hard reference cache (to avoid their enqueuement/garbage-collection).	WITHOUT_CLASSIFICATION	0.9999999999477088	WITHOUT_CLASSIFICATION	5.2291226705482464E-11	DEFECT
// as soon as we encounter our first letter, return the substring // from that position	WITHOUT_CLASSIFICATION	0.9999998881293792	WITHOUT_CLASSIFICATION	1.1187062078785031E-7	DEFECT
// Note : expected in the syntax: //      type=listenerClass //          ({sep}type=listenerClass)* // where {sep} is any whitespace or comma	WITHOUT_CLASSIFICATION	0.9999980208247453	WITHOUT_CLASSIFICATION	1.9791752546968712E-6	DEFECT
// isTransactionCallbackRegistered denotes whether any Hibernate // Transaction has registered as a callback against this // JDBCContext; only one such callback is allowed.  Directly // serializing this value causes problems with JDBCTransaction, // or really any Transaction impl where the callback is local // to the Transaction instance itself, since that Transaction // is not serialized along with the JDBCContext.  Thus we // handle that fact here explicitly...	WITHOUT_CLASSIFICATION	0.9929203858458243	WITHOUT_CLASSIFICATION	0.007079614154175619	DEFECT
// note that for sequential scrolling, we make the assumption that // the first persister element is the "root entity"	WITHOUT_CLASSIFICATION	0.999999859994201	WITHOUT_CLASSIFICATION	1.4000579893585756E-7	DEFECT
// We call getKeyFromResultSet() here so that we can know the // key value upon which to perform the breaking logic.  However, // it is also then called from getRowFromResultSet() which is certainly // not the most efficient.  But the call here is needed, and there // currently is no other way without refactoring of the doQuery()/getRowFromResultSet() // methods	WITHOUT_CLASSIFICATION	0.9993050559577263	WITHOUT_CLASSIFICATION	6.949440422736645E-4	DEFECT
// This check is needed since processing leaves the cursor // after the last physical row for the current logical row; // thus if we are after the last physical row, this might be // caused by either: //      1) scrolling to the last logical row //      2) scrolling past the last logical row // In the latter scenario, the previous logical row // really is the last logical row. // // In all other cases, we should process back two // logical records (the current logic row, plus the // previous logical row).	WITHOUT_CLASSIFICATION	0.6941353317914747	DEFECT	0.30586466820852526	WITHOUT_CLASSIFICATION
// and perform the load	WITHOUT_CLASSIFICATION	0.9999999516891006	WITHOUT_CLASSIFICATION	4.831089926824365E-8	DEFECT
//important: reuse the same event instances for performance!	WITHOUT_CLASSIFICATION	0.9990700306983089	WITHOUT_CLASSIFICATION	9.299693016911267E-4	DEFECT
//this is a query and we are loading multiple instances of the same collection role	WITHOUT_CLASSIFICATION	0.9995264602748183	WITHOUT_CLASSIFICATION	4.735397251817757E-4	DEFECT
// we found a collection element in the result set	WITHOUT_CLASSIFICATION	0.9999992488174221	WITHOUT_CLASSIFICATION	7.511825778878869E-7	DEFECT
// we did not find a collection element in the result set, so we // ensure that a collection is created with the owner's identifier, // since what we have is an empty collection	WITHOUT_CLASSIFICATION	0.9999999993902863	WITHOUT_CLASSIFICATION	6.097137398897762E-10	DEFECT
// this is a collection initializer, so we must create a collection // for each of the passed-in keys, to account for the possibility // that the collection is empty and has no rows in the result set	WITHOUT_CLASSIFICATION	0.9999999971858669	WITHOUT_CLASSIFICATION	2.814133179901779E-9	DEFECT
// grab its state from the ResultSet and keep it in the Session // (but don't yet initialize the object itself) // note that we acquire LockMode.READ even if it was not requested	WITHOUT_CLASSIFICATION	0.9999999515305894	WITHOUT_CLASSIFICATION	4.8469410687793546E-8	DEFECT
// a many-to-many; // decrement currentDepth here to allow join across the association table // without exceeding MAX_FETCH_DEPTH (i.e. the "currentDepth - 1" bit)	WITHOUT_CLASSIFICATION	0.9999993789580527	WITHOUT_CLASSIFICATION	6.210419472408405E-7	DEFECT
// if not a composite key, use "foo in (?, ?, ?)" for batching // if no batch, and not a composite key, use "foo = ?"	WITHOUT_CLASSIFICATION	0.9999999886756521	WITHOUT_CLASSIFICATION	1.1324347975171953E-8	DEFECT
//the user visible aliases, which are unknown to the superclass, //these are not the actual "physical" SQL aliases	WITHOUT_CLASSIFICATION	0.9999769887228817	WITHOUT_CLASSIFICATION	2.3011277118336013E-5	DEFECT
//first look for a reference to a projection alias	WITHOUT_CLASSIFICATION	0.9999991965014688	WITHOUT_CLASSIFICATION	8.034985311655286E-7	DEFECT
//first look for a reference to a projection alias	WITHOUT_CLASSIFICATION	0.9999991965014688	WITHOUT_CLASSIFICATION	8.034985311655286E-7	DEFECT
//it does not refer to an alias of a projection, //look for a property	WITHOUT_CLASSIFICATION	0.9999889469020153	WITHOUT_CLASSIFICATION	1.1053097984629995E-5	DEFECT
// determine if the collection elements are entities...	WITHOUT_CLASSIFICATION	0.9999994481799402	WITHOUT_CLASSIFICATION	5.518200598504803E-7	DEFECT
// Let return-propertys override whatever the persister has for aliases.	WITHOUT_CLASSIFICATION	0.9999999464076528	WITHOUT_CLASSIFICATION	5.359234728912324E-8	DEFECT
/**	WITHOUT_CLASSIFICATION	0.5238510211901031	WITHOUT_CLASSIFICATION	0.47614897880989693	DEFECT
// ignore	WITHOUT_CLASSIFICATION	0.9999996022307994	WITHOUT_CLASSIFICATION	3.977692004945396E-7	DEFECT
// ignore	WITHOUT_CLASSIFICATION	0.9999996022307994	WITHOUT_CLASSIFICATION	3.977692004945396E-7	DEFECT
//        }	WITHOUT_CLASSIFICATION	0.9999962328543461	WITHOUT_CLASSIFICATION	3.767145653945702E-6	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//include the discriminator and class-level where, but not filters	WITHOUT_CLASSIFICATION	0.9999999227425737	WITHOUT_CLASSIFICATION	7.725742634302756E-8	DEFECT
//	WITHOUT_CLASSIFICATION	0.9999701292572488	WITHOUT_CLASSIFICATION	2.9870742751172328E-5	DEFECT
//NONE, because its the requested lock mode, not the actual! 	WITHOUT_CLASSIFICATION	0.999954358761503	WITHOUT_CLASSIFICATION	4.5641238496932245E-5	DEFECT
// at this point we have (drivingSqlAlias) the SQL alias of the driving table // corresponding to the given user alias.  However, the driving table is not // (necessarily) the table against which we want to apply locks.  Mainly, // the exception case here is joined-subclass hierarchies where we instead // want to apply the lock against the root table (for all other strategies, // it just happens that driving and root are the same).	WITHOUT_CLASSIFICATION	0.9999998767595675	WITHOUT_CLASSIFICATION	1.2324043257028424E-7	DEFECT
// the column doesnt exist at all.	WITHOUT_CLASSIFICATION	0.9999738964620565	WITHOUT_CLASSIFICATION	2.6103537943552534E-5	DEFECT
// we have a mapped identifier property and the root of // the incoming property path matched that identifier // property	WITHOUT_CLASSIFICATION	0.9999959032589089	WITHOUT_CLASSIFICATION	4.096741091161912E-6	DEFECT
// we have an embedded composite identifier	WITHOUT_CLASSIFICATION	0.9999999982476304	WITHOUT_CLASSIFICATION	1.7523696737302717E-9	DEFECT
// both many-to-one and one-to-one are represented as a // Property.  EntityPersister is relying on this value to // determine "lazy fetch groups" in terms of field-level // interception.  So we need to make sure that we return // true here for the case of many-to-one and one-to-one // with lazy="no-proxy" // // * impl note - lazy="no-proxy" currently forces both // lazy and unwrap to be set to true.  The other case we // are extremely interested in here is that of lazy="proxy" // where lazy is set to true, but unwrap is set to false. // thus we use both here under the assumption that this // return is really only ever used during persister // construction to determine the lazy property/field fetch // groupings.  If that assertion changes then this check // needs to change as well.  Partially, this is an issue with // the overloading of the term "lazy" here...	WITHOUT_CLASSIFICATION	0.9998454257907645	WITHOUT_CLASSIFICATION	1.5457420923550779E-4	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998069892152	WITHOUT_CLASSIFICATION	1.9301078473003982E-7	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ // stuff that is tuplizer-centric, but is passed a session ~~~~~~~~~~~~~~~~ // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999998069892152	WITHOUT_CLASSIFICATION	1.9301078473003982E-7	DEFECT
/*rootTableName = persistentClass.getRootTable().getQualifiedName( 	WITHOUT_CLASSIFICATION	0.9999979004488302	WITHOUT_CLASSIFICATION	2.0995511697429186E-6	DEFECT
// SUBCLASSES	WITHOUT_CLASSIFICATION	0.9999980472556182	WITHOUT_CLASSIFICATION	1.952744381773971E-6	DEFECT
// Custom sql	WITHOUT_CLASSIFICATION	0.9999999202088218	WITHOUT_CLASSIFICATION	7.979117816308778E-8	DEFECT
/*protected void initPropertyPaths(	WITHOUT_CLASSIFICATION	0.9999597582398678	WITHOUT_CLASSIFICATION	4.024176013225757E-5	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
//Custom SQL (would be better if these were private)	WITHOUT_CLASSIFICATION	0.9999999217894523	WITHOUT_CLASSIFICATION	7.821054770733405E-8	DEFECT
// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999999585830717	WITHOUT_CLASSIFICATION	4.141692840407226E-8	DEFECT
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999891405472566	WITHOUT_CLASSIFICATION	1.085945274338996E-5	DEFECT
// aliases for identifier ( alias.id ); skip if the entity defines a non-id property named 'id'	WITHOUT_CLASSIFICATION	0.999999997315102	WITHOUT_CLASSIFICATION	2.6848979289925107E-9	DEFECT
//decide which ResultSet to get the property value from:	WITHOUT_CLASSIFICATION	0.999953278986996	WITHOUT_CLASSIFICATION	4.672101300400633E-5	DEFECT
//note: it is conceptually possible that a UserType could map null to //	WITHOUT_CLASSIFICATION	0.99972111148557	WITHOUT_CLASSIFICATION	2.788885144300704E-4	DEFECT
// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null // is an indication that the specified entity-name (this.getEntityName) should be used.	WITHOUT_CLASSIFICATION	0.9999999928141442	WITHOUT_CLASSIFICATION	7.1858557698183104E-9	DEFECT
// Need to use the identifier type of the collection owner // since the incoming is value is actually the owner's id. // Using the collection's key type causes problems with // property-ref keys...	WITHOUT_CLASSIFICATION	0.9994316357841463	WITHOUT_CLASSIFICATION	5.683642158537557E-4	DEFECT
// cache these since they are stateless // this one could even be static...	WITHOUT_CLASSIFICATION	0.9999984095325213	WITHOUT_CLASSIFICATION	1.59046747868448E-6	DEFECT
//"as" is not in KEYWORDS	WITHOUT_CLASSIFICATION	0.9996233651327905	WITHOUT_CLASSIFICATION	3.766348672095633E-4	DEFECT
// --Commented out by Inspection (12/4/04 9:10 AM): public abstract void addCondition(String alias, String[] columns, String condition);	WITHOUT_CLASSIFICATION	0.9999955832050692	WITHOUT_CLASSIFICATION	4.41679493078814E-6	DEFECT
//use the id column alias	WITHOUT_CLASSIFICATION	0.9999999418369229	WITHOUT_CLASSIFICATION	5.816307707821778E-8	DEFECT
//private List aliases = new ArrayList();	WITHOUT_CLASSIFICATION	0.999999278185484	WITHOUT_CLASSIFICATION	7.218145160426113E-7	DEFECT
//columns.add(columnName); //aliases.add(tableAlias);	WITHOUT_CLASSIFICATION	0.9999980834926823	WITHOUT_CLASSIFICATION	1.9165073177622775E-6	DEFECT
//where fragment must be empty!	WITHOUT_CLASSIFICATION	0.9999989241875533	WITHOUT_CLASSIFICATION	1.0758124467140426E-6	DEFECT
// revert to traditional hibernate behavior of setting initialPoolSize to minPoolSize // unless otherwise specified with a c3p0.*-style parameter.	WITHOUT_CLASSIFICATION	0.9999999821432943	WITHOUT_CLASSIFICATION	1.7856705720302675E-8	DEFECT
//arbitrary on clause ignored!!	WITHOUT_CLASSIFICATION	0.999986664474666	WITHOUT_CLASSIFICATION	1.3335525333969734E-5	DEFECT
// might happen with a managed connection	WITHOUT_CLASSIFICATION	0.9984605270969931	WITHOUT_CLASSIFICATION	0.0015394729030069859	DEFECT
// might happen with a managed connection	WITHOUT_CLASSIFICATION	0.9984605270969931	WITHOUT_CLASSIFICATION	0.0015394729030069859	DEFECT
//if an exception occurs during flush, user must call rollback()	WITHOUT_CLASSIFICATION	0.9999972068797407	WITHOUT_CLASSIFICATION	2.7931202594071813E-6	DEFECT
// Essentially: // 1) If we have a local (Hibernate) transaction in progress //      and it already has the UserTransaction cached, use that //      UserTransaction to determine the status. // 2) If a transaction manager has been located, use //      that transaction manager to determine the status. // 3) Finally, as the last resort, try to lookup the //      UserTransaction via JNDI and use that to determine the //      status.	WITHOUT_CLASSIFICATION	0.9999999163387129	WITHOUT_CLASSIFICATION	8.366128702018546E-8	DEFECT
/*package*/	WITHOUT_CLASSIFICATION	0.999979876236791	WITHOUT_CLASSIFICATION	2.0123763208966183E-5	DEFECT
//swallow it (the transaction _was_ successful or successfully rolled back)	WITHOUT_CLASSIFICATION	0.9999970053504746	WITHOUT_CLASSIFICATION	2.9946495253906864E-6	DEFECT
// ignore it	WITHOUT_CLASSIFICATION	0.9999995583482444	WITHOUT_CLASSIFICATION	4.416517556879499E-7	DEFECT
// we need to dirty check many-to-ones with not-found="ignore" in order  // to update the cache (not the database), since in this case a null // entity reference can lose information	WITHOUT_CLASSIFICATION	0.9999999497752898	WITHOUT_CLASSIFICATION	5.022471029568586E-8	DEFECT
// create our own copy of the user-supplied tuplizer impl map	WITHOUT_CLASSIFICATION	0.9999995498699911	WITHOUT_CLASSIFICATION	4.5013000893870166E-7	DEFECT
// Regions can get instantiated in the course of normal work (e.g. // a named query region will be created the first time the query is // executed), so suspend any ongoing tx	WITHOUT_CLASSIFICATION	0.9996902212602345	WITHOUT_CLASSIFICATION	3.0977873976549916E-4	DEFECT
// then handle any user-defined entity modes...	WITHOUT_CLASSIFICATION	0.9999998448500933	WITHOUT_CLASSIFICATION	1.5514990676260776E-7	DEFECT
// Establish the region root node with a non-locking data version	WITHOUT_CLASSIFICATION	0.9999988224298142	WITHOUT_CLASSIFICATION	1.1775701858929255E-6	DEFECT
// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	WITHOUT_CLASSIFICATION	0.9999965880943033	WITHOUT_CLASSIFICATION	3.4119056967041506E-6	DEFECT
// NOTE : this is being used from the process of shutting down a // SessionFactory. Specific things to consider: // (1) this clearing of the region should not propagate to // other nodes on the cluster (if any); this is the // cache-mode-local option bit... // (2) really just trying a best effort to cleanup after // ourselves; lock failures, etc are not critical here; // this is the fail-silently option bit...	WITHOUT_CLASSIFICATION	0.5419899154840856	DEFECT	0.4580100845159145	WITHOUT_CLASSIFICATION
// need to extract the component values and check for subtype replacements...	WITHOUT_CLASSIFICATION	0.9999994400170323	WITHOUT_CLASSIFICATION	5.599829675397654E-7	DEFECT
// We ignore minimalPutOverride. JBossCache putForExternalRead is // already about as minimal as we can get; it will promptly return // if it discovers that the node we want to write to already exists	WITHOUT_CLASSIFICATION	0.9999996632682996	WITHOUT_CLASSIFICATION	3.367317004386725E-7	DEFECT
// for now, just "re-flatten" the metamodel since this is temporary stuff anyway (HHH-1907)	WITHOUT_CLASSIFICATION	0.9999995884404725	WITHOUT_CLASSIFICATION	4.1155952748542425E-7	DEFECT
// Configure the cache to use our TM	WITHOUT_CLASSIFICATION	0.9999999834593661	WITHOUT_CLASSIFICATION	1.6540633854809293E-8	DEFECT
//This solution would allow us to eliminate the owner arg to disassemble(), but //what if the collection was null, and then later had elements added? seems unsafe //session.getPersistenceContext().getCollectionEntry( (PersistentCollection) value ).getKey();	WITHOUT_CLASSIFICATION	0.9999856315600295	WITHOUT_CLASSIFICATION	1.4368439970514989E-5	DEFECT
// Make sure JBC doesn't look one up	WITHOUT_CLASSIFICATION	0.9999949367385129	WITHOUT_CLASSIFICATION	5.063261487057169E-6	DEFECT
// some collections are not lazy:	WITHOUT_CLASSIFICATION	0.9996650277531917	WITHOUT_CLASSIFICATION	3.3497224680827114E-4	DEFECT
// Here we don't want to suspend the tx. If we do: // 1) We might be caching query results that reflect uncommitted // changes. No tx == no WL on cache node, so other threads // can prematurely see those query results // 2) No tx == immediate replication. More overhead, plus we // spread issue #1 above around the cluster	WITHOUT_CLASSIFICATION	0.999886222151201	WITHOUT_CLASSIFICATION	1.1377784879903014E-4	DEFECT
// return the (fully resolved) identifier value, but do not resolve // to the actual referenced entity instance // NOTE: the owner of the association is not really the owner of the id!	WITHOUT_CLASSIFICATION	0.99999819277811	WITHOUT_CLASSIFICATION	1.807221890011251E-6	DEFECT
// Add a zero (or quite low) timeout option so we don't block. // Ignore any TimeoutException. Basically we forego caching the // query result in order to avoid blocking. // Reads are done with suspended tx, so they should not hold the // lock for long.  Not caching the query result is OK, since // any subsequent read will just see the old result with its // out-of-date timestamp; that result will be discarded and the // db query performed again.	WITHOUT_CLASSIFICATION	0.9999991637819565	WITHOUT_CLASSIFICATION	8.362180434311459E-7	DEFECT
// Impl note: takes advantage of the fact that an escpaed single quote // embedded within a quote-block can really be handled as two seperate // quote-blocks for the purposes of this method...	WITHOUT_CLASSIFICATION	0.998961943181728	WITHOUT_CLASSIFICATION	0.0010380568182718616	DEFECT
// We have the JBCWriteMutex, so no other *local* thread will  // be trying to write this key.  // It's possible here some remote thread has come in and // changed the values again, but since we are reading the // values to write to JBC right now, we know we are writing // the latest values; i.e. we don't assume that what we cached // in entry.update() above is what we should write to JBC *now*. // Our write could be redundant, i.e. we are writing what // some remote thread just came in an wrote.  There is a chance  // that yet another remote thread will update us, and we'll then // overwrite that later data in JBC.  But, all remote nodes will // ignore that change in their localCache; the only place it  // will live will be in JBC, where it can only effect the  // initial state transfer values on newly joined nodes  // (i.e. populateLocalCache()).	WITHOUT_CLASSIFICATION	0.9999999805544677	WITHOUT_CLASSIFICATION	1.9445532262510592E-8	DEFECT
// local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999954346108603	WITHOUT_CLASSIFICATION	4.565389139697805E-6	DEFECT
// local cache, so we use synchronization	WITHOUT_CLASSIFICATION	0.9999954346108603	WITHOUT_CLASSIFICATION	4.565389139697805E-6	DEFECT
// Don't need to lock the cache here, since if someone // else inserted the same pk first, the insert would fail	WITHOUT_CLASSIFICATION	0.9999532301903759	WITHOUT_CLASSIFICATION	4.676980962417627E-5	DEFECT
// we need to grab the version value from the entity, otherwise // we have issues with generated-version entities that may have // multiple actions queued during the same flush	WITHOUT_CLASSIFICATION	0.9999833357043038	WITHOUT_CLASSIFICATION	1.6664295696288508E-5	DEFECT
// we need to obtain the lock before any actions are // executed, since this may be an inverse="true" // bidirectional association and it is one of the // earlier entity actions which actually updates // the database (this action is resposible for // second-level cache invalidation only)	WITHOUT_CLASSIFICATION	0.9999999999530936	WITHOUT_CLASSIFICATION	4.690627675990538E-11	DEFECT
//postDelete: // After actually deleting a row, record the fact that the instance no longer  // exists on the database (needed for identity-column key generation), and // remove it from the session cache	WITHOUT_CLASSIFICATION	0.9999910287618373	WITHOUT_CLASSIFICATION	8.971238162742251E-6	DEFECT
// intentionally empty	WITHOUT_CLASSIFICATION	0.9999991074135116	WITHOUT_CLASSIFICATION	8.925864882922316E-7	DEFECT
//FIXME we don't have the associated entity table name here, has to be done in a second pass	DEFECT	0.9999540594937131	WITHOUT_CLASSIFICATION	4.594050628690873E-5	DEFECT
// For a one-to-many, a <bag> is not really a bag; // it is *really* a set, since it can't contain the // same element twice. It could be considered a bug // in the mapping dtd that <bag> allows <one-to-many>.	DEFECT	0.9984478029335584	WITHOUT_CLASSIFICATION	0.0015521970664416425	DEFECT
// RDMS does not directly support the trim() function, we use rtrim() and ltrim()	DEFECT	0.9999922925551693	WITHOUT_CLASSIFICATION	7.707444830700157E-6	DEFECT
/*         * The following types are not supported in RDMS/JDBC and therefore commented out.         * However, in some cases, mapping them to CHARACTER columns works         * for many applications, but does not work for all cases.         */	DEFECT	0.9758760611437148	WITHOUT_CLASSIFICATION	0.024123938856285256	DEFECT
// The preference here would be //   SQLFunctionTemplate( Hibernate.TIMESTAMP, "current_timestamp(?1)", false) // but this appears not to work. // Jay Nance 2006-09-22	DEFECT	0.952674038182297	DEFECT	0.047325961817702905	WITHOUT_CLASSIFICATION
// note: at least my local SQL Server 2005 Express shows this not working...	DEFECT	0.6957026253383318	DEFECT	0.3042973746616682	WITHOUT_CLASSIFICATION
// note: at least my local MySQL 5.1 install shows this not working...	DEFECT	0.8241601802482953	DEFECT	0.17583981975170468	WITHOUT_CLASSIFICATION
/*	DEFECT	0.9935009427489204	WITHOUT_CLASSIFICATION	0.006499057251079584	DEFECT
//Don't need this, because we should never ever be selecting no columns in an insert ... select... //and because it causes a bug on DB2	DEFECT	0.9978120978712687	WITHOUT_CLASSIFICATION	0.0021879021287314073	DEFECT
// TODO : this is broke for subqueries in statements other than selects...	DEFECT	0.9919804029970771	DEFECT	0.008019597002922929	WITHOUT_CLASSIFICATION
// TODO : should this be an error?	DEFECT	0.6375500502536978	WITHOUT_CLASSIFICATION	0.36244994974630224	DEFECT
// TODO : not sure which (either?) is correct, could not find docs on how to do this. // did find various blogs and forums mentioning that select CURRENT_TIMESTAMP // does not work...	DEFECT	0.999968797525891	DEFECT	3.120247410909376E-5	WITHOUT_CLASSIFICATION
// TODO: figure out how this should be set. /////////////////////////////////////////////////////////////////////////////// // This was the reason for failures regarding INDEX_OP and subclass joins on // theta-join dialects; not sure what behaviour we were trying to emulate ;) //	DEFECT	0.9184547989609619	DEFECT	0.08154520103903802	WITHOUT_CLASSIFICATION
//TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.8039269689338359	DEFECT	0.19607303106616403	WITHOUT_CLASSIFICATION
//TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.8039269689338359	DEFECT	0.19607303106616403	WITHOUT_CLASSIFICATION
// TODO: cannot use generateSuffixes() - it handles the initial suffix differently.	DEFECT	0.8035562561303928	WITHOUT_CLASSIFICATION	0.19644374386960714	DEFECT
// starts with an alias (old style) // semi-bad thing about this: can't re-alias another alias.....	DEFECT	0.9999626905541722	WITHOUT_CLASSIFICATION	3.7309445827783814E-5	DEFECT
//TODO: BUG! this currently fails for named queries for non-POJO entities	DEFECT	0.9735662828269128	DEFECT	0.026433717173087182	WITHOUT_CLASSIFICATION
// this call is side-effecty	DEFECT	0.9999896159449159	WITHOUT_CLASSIFICATION	1.0384055084124176E-5	DEFECT
//TODO: old version did not require hashmap lookup: //keys[collectionOwner].getIdentifier()	DEFECT	0.9788618785575709	WITHOUT_CLASSIFICATION	0.021138121442429193	DEFECT
//TODO: when this is the entry point, we should use an INNER_JOIN for fetching the many-to-many elements!	DEFECT	0.9672265494522821	WITHOUT_CLASSIFICATION	0.03277345054771788	DEFECT
// this is only needed (afaict) for processing results from the query cache; // however, this cannot possibly work in the case of discovered types...	DEFECT	0.9535858790152202	DEFECT	0.0464141209847798	WITHOUT_CLASSIFICATION
//TODO: this requires that the collection is defined after the //      referenced property in the mapping file (ok?)	DEFECT	0.9950856104066783	WITHOUT_CLASSIFICATION	0.004914389593321723	DEFECT
//TODO: is this completely correct?	DEFECT	0.8788004017198419	WITHOUT_CLASSIFICATION	0.1211995982801582	DEFECT
// three general cases we check here as to whether to render a physical SQL join: // 1) is our parent a DotNode as well?  If so, our property reference is // 	DEFECT	0.9999141715977417	WITHOUT_CLASSIFICATION	8.582840225833494E-5	DEFECT
// TODO : currently we really do not handle ValueInclusion.PARTIAL... // ValueInclusion.PARTIAL would indicate parts of a component need to // be included in the select; currently we then just render the entire // component into the select clause in that case.	DEFECT	0.7597327647464465	DEFECT	0.24026723525355348	WITHOUT_CLASSIFICATION
//TODO: inexact, what we really need to know is: are any outer joins used?	DEFECT	0.999364801556418	WITHOUT_CLASSIFICATION	6.35198443582033E-4	DEFECT
// todo : this call will not work for anything other than pojos!	DEFECT	0.9100094371803865	DEFECT	0.0899905628196135	WITHOUT_CLASSIFICATION
//TODO: currently we don't know a SessionFactory reference when building the Tuplizer //      THIS IS A BUG (embedded-xml=false on component) // TODO : fix this after HHH-1907 is complete	DEFECT	0.9978113077652042	DEFECT	0.0021886922347958467	WITHOUT_CLASSIFICATION
// TODO: this disables laziness even in non-pojo entity modes:	DEFECT	0.9972893032414561	WITHOUT_CLASSIFICATION	0.002710696758543948	DEFECT
//TODO: currently broken for unique-key references (does not detect //      change to unique key property of the associated object) //the owner of the association is not the owner of the id	DEFECT	0.8899421893211837	WITHOUT_CLASSIFICATION	0.11005781067881618	DEFECT
//TODO: entities CAN be compared, by PK, fix this! -> only if/when we can extract the id values....	DEFECT	0.5320496339882922	DEFECT	0.46795036601170786	WITHOUT_CLASSIFICATION
//TODO: entities CAN be compared, by PK and entity name, fix this!	DEFECT	0.9001518184365945	WITHOUT_CLASSIFICATION	0.09984818156340552	DEFECT
//TODO: this is kinda inconsistent with CollectionType	DEFECT	0.8128097044603259	WITHOUT_CLASSIFICATION	0.1871902955396742	DEFECT
//TODO: would be nice to use false, but issues with MS SQL	DEFECT	0.8039269689338359	DEFECT	0.19607303106616403	WITHOUT_CLASSIFICATION
// TODO: does not work for EntityMode.DOM4J yet!	DEFECT	0.9998960131175662	DEFECT	1.0398688243382126E-4	WITHOUT_CLASSIFICATION
//TODO: currently broken for unique-key references (does not detect //      change to unique key property of the associated object)	DEFECT	0.9212363747197376	WITHOUT_CLASSIFICATION	0.07876362528026232	DEFECT
//TODO: not really completely correct, since //      the uoe could occur while resolving //      associations, leaving the PC in an //      inconsistent state	DEFECT	0.7242882276508179	WITHOUT_CLASSIFICATION	0.2757117723491822	DEFECT
// could happen for custom Criteria impls.  Not likely, but... // 	DEFECT	0.9382328716857564	WITHOUT_CLASSIFICATION	0.06176712831424362	DEFECT
// This does not support the Cache SQL 'DISTINCT BY (comma-list)' extensions, // but this extension is not supported through Hibernate anyway.	DEFECT	0.9999974721533231	WITHOUT_CLASSIFICATION	2.5278466768490117E-6	DEFECT
// note that this timestamp is not correct if the connection provider // returns an older JDBC connection that was associated with a // transaction that was already begun before openSession() was called // (don't know any possible solution to this!)	DEFECT	0.999851572479135	WITHOUT_CLASSIFICATION	1.4842752086506646E-4	DEFECT
//no need to take a snapshot - this is a  //performance optimization, but not really //important, except for entities with huge  //mutable property values	DEFECT	0.9948788655647758	WITHOUT_CLASSIFICATION	0.005121134435224237	DEFECT
// TODO : this really needs to be delayed unitl after we definitively know the operand node type; // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected type	DEFECT	0.992434145799632	DEFECT	0.007565854200368067	WITHOUT_CLASSIFICATION
// First, validate all the enabled filters... //TODO: this implementation has bad performance	DEFECT	0.6387257562115152	WITHOUT_CLASSIFICATION	0.3612742437884849	DEFECT
// TODO: what if batchUpdate is a callablestatement ? // calls executeBatch()	DEFECT	0.9891578214561523	WITHOUT_CLASSIFICATION	0.010842178543847808	DEFECT
// assume that the row was not there since it previously had only null // values, so do an INSERT instead //TODO: does not respect dynamic-insert	DEFECT	0.9998652691493238	WITHOUT_CLASSIFICATION	1.347308506760922E-4	DEFECT
//TODO: passing null here, because this method is not really used for DOM4J at the moment //      but it is still a bug, if we don't get rid of this!	DEFECT	0.8728358895127039	DEFECT	0.12716411048729623	WITHOUT_CLASSIFICATION
//note that this implementation is kinda broken //for components with many-to-one associations	DEFECT	0.9997018025491801	WITHOUT_CLASSIFICATION	2.9819745081991E-4	DEFECT
// TODO: at the point where we are resolving collection references, we don't // know if the uk value has been resolved (depends if it was earlier or // later in the mapping document) - now, we could try and use e.getStatus() // to decide to semiResolve(), trouble is that initializeEntity() reuses // the same array for resolved and hydrated values	DEFECT	0.8395761429593559	WITHOUT_CLASSIFICATION	0.16042385704064413	DEFECT
//TODO: This is assertion is disabled because there is a bug that means the //	DEFECT	0.7510044461472577	WITHOUT_CLASSIFICATION	0.24899555385274239	DEFECT
// This doesn't actually seem to work but it *might* // work on some dbs. Also it doesn't work if there // are multiple columns of results because it // is not accounting for the suffix: // return new String[] { getDiscriminatorColumnName() };	DEFECT	0.860793957017414	WITHOUT_CLASSIFICATION	0.13920604298258601	DEFECT
// TODO: Deal with the "optional" attribute in the <join> mapping; // this code assumes that optional defaults to "true" because it // doesn't actually seem to work in the fetch="join" code // // Note that actual proper handling of optional-ality here is actually // more involved than this patch assumes.  Remember that we might have // multiple <join/> mappings associated with a single entity.  Really // a couple of things need to happen to properly handle optional here: //  1) First and foremost, when handling multiple <join/>s, we really //      should be using the entity root table as the driving table; //      another option here would be to choose some non-optional joined //      table to use as the driving table.  In all likelihood, just using //      the root table is much simplier //  2) Need to add the FK columns corresponding to each joined table //      to the generated select list; these would then be used when //      iterating the result set to determine whether all non-optional //      data is present // My initial thoughts on the best way to deal with this would be // to introduce a new SequentialSelect abstraction that actually gets // generated in the persisters (ok, SingleTable...) and utilized here. // It would encapsulated all this required optional-ality checking...	DEFECT	0.9620866133265517	DEFECT	0.03791338667344842	WITHOUT_CLASSIFICATION
